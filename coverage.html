
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/baetyl/baetyl/baetyl-agent/clean.go (82.2%)</option>
				
				<option value="file1">github.com/baetyl/baetyl/baetyl-agent/download.go (0.0%)</option>
				
				<option value="file2">github.com/baetyl/baetyl/baetyl-agent/event.go (32.1%)</option>
				
				<option value="file3">github.com/baetyl/baetyl/baetyl-agent/main.go (0.0%)</option>
				
				<option value="file4">github.com/baetyl/baetyl/baetyl-agent/otalog.go (0.0%)</option>
				
				<option value="file5">github.com/baetyl/baetyl/baetyl-agent/process.go (0.0%)</option>
				
				<option value="file6">github.com/baetyl/baetyl/baetyl-agent/report.go (0.0%)</option>
				
				<option value="file7">github.com/baetyl/baetyl/baetyl-function-manager/function.go (85.2%)</option>
				
				<option value="file8">github.com/baetyl/baetyl/baetyl-function-manager/instance.go (0.0%)</option>
				
				<option value="file9">github.com/baetyl/baetyl/baetyl-function-manager/main.go (0.0%)</option>
				
				<option value="file10">github.com/baetyl/baetyl/baetyl-function-manager/ruler.go (0.0%)</option>
				
				<option value="file11">github.com/baetyl/baetyl/baetyl-hub/auth/auth.go (100.0%)</option>
				
				<option value="file12">github.com/baetyl/baetyl/baetyl-hub/common/acknowledge.go (42.9%)</option>
				
				<option value="file13">github.com/baetyl/baetyl/baetyl-hub/common/message.go (73.3%)</option>
				
				<option value="file14">github.com/baetyl/baetyl/baetyl-hub/common/message.pb.go (62.8%)</option>
				
				<option value="file15">github.com/baetyl/baetyl/baetyl-hub/common/packetids.go (100.0%)</option>
				
				<option value="file16">github.com/baetyl/baetyl/baetyl-hub/common/subscribe.go (0.0%)</option>
				
				<option value="file17">github.com/baetyl/baetyl/baetyl-hub/common/topic.go (100.0%)</option>
				
				<option value="file18">github.com/baetyl/baetyl/baetyl-hub/config/config.go (100.0%)</option>
				
				<option value="file19">github.com/baetyl/baetyl/baetyl-hub/config/validate.go (99.0%)</option>
				
				<option value="file20">github.com/baetyl/baetyl/baetyl-hub/persist/boltdb.go (26.6%)</option>
				
				<option value="file21">github.com/baetyl/baetyl/baetyl-hub/persist/factory.go (0.0%)</option>
				
				<option value="file22">github.com/baetyl/baetyl/baetyl-hub/router/deque.go (84.2%)</option>
				
				<option value="file23">github.com/baetyl/baetyl/baetyl-hub/router/node.go (100.0%)</option>
				
				<option value="file24">github.com/baetyl/baetyl/baetyl-hub/router/trie.go (91.7%)</option>
				
				<option value="file25">github.com/baetyl/baetyl/baetyl-hub/rule/manager.go (56.6%)</option>
				
				<option value="file26">github.com/baetyl/baetyl/baetyl-hub/rule/msgchan.go (75.3%)</option>
				
				<option value="file27">github.com/baetyl/baetyl/baetyl-hub/rule/rule.go (77.8%)</option>
				
				<option value="file28">github.com/baetyl/baetyl/baetyl-hub/rule/sink.go (85.7%)</option>
				
				<option value="file29">github.com/baetyl/baetyl/baetyl-hub/rule/sinksub.go (82.4%)</option>
				
				<option value="file30">github.com/baetyl/baetyl/baetyl-hub/server/manager.go (88.5%)</option>
				
				<option value="file31">github.com/baetyl/baetyl/baetyl-hub/session/manager.go (78.9%)</option>
				
				<option value="file32">github.com/baetyl/baetyl/baetyl-hub/session/record.go (76.6%)</option>
				
				<option value="file33">github.com/baetyl/baetyl/baetyl-hub/session/session.go (93.5%)</option>
				
				<option value="file34">github.com/baetyl/baetyl/baetyl-hub/session/session_egress.go (80.0%)</option>
				
				<option value="file35">github.com/baetyl/baetyl/baetyl-hub/session/session_ingress.go (66.1%)</option>
				
				<option value="file36">github.com/baetyl/baetyl/baetyl-hub/utils/binary.go (33.3%)</option>
				
				<option value="file37">github.com/baetyl/baetyl/baetyl-hub/utils/map.go (0.0%)</option>
				
				<option value="file38">github.com/baetyl/baetyl/baetyl-hub/utils/regex.go (100.0%)</option>
				
				<option value="file39">github.com/baetyl/baetyl/baetyl-hub/utils/test.go (100.0%)</option>
				
				<option value="file40">github.com/baetyl/baetyl/baetyl-hub/utils/tomb.go (93.8%)</option>
				
				<option value="file41">github.com/baetyl/baetyl/baetyl-remote-mqtt/main.go (0.0%)</option>
				
				<option value="file42">github.com/baetyl/baetyl/baetyl-remote-mqtt/ruler.go (33.3%)</option>
				
				<option value="file43">github.com/baetyl/baetyl/logger/logger.go (32.8%)</option>
				
				<option value="file44">github.com/baetyl/baetyl/logger/logger_global.go (33.3%)</option>
				
				<option value="file45">github.com/baetyl/baetyl/master/api/server.go (86.4%)</option>
				
				<option value="file46">github.com/baetyl/baetyl/master/api/server_deprecated.go (0.0%)</option>
				
				<option value="file47">github.com/baetyl/baetyl/master/api/service_kv.go (100.0%)</option>
				
				<option value="file48">github.com/baetyl/baetyl/master/config.go (0.0%)</option>
				
				<option value="file49">github.com/baetyl/baetyl/master/database/db.go (100.0%)</option>
				
				<option value="file50">github.com/baetyl/baetyl/master/database/sql.go (80.5%)</option>
				
				<option value="file51">github.com/baetyl/baetyl/master/engine/docker/container.go (10.8%)</option>
				
				<option value="file52">github.com/baetyl/baetyl/master/engine/docker/engine.go (1.0%)</option>
				
				<option value="file53">github.com/baetyl/baetyl/master/engine/docker/instance.go (0.0%)</option>
				
				<option value="file54">github.com/baetyl/baetyl/master/engine/docker/service.go (0.0%)</option>
				
				<option value="file55">github.com/baetyl/baetyl/master/engine/engine.go (20.0%)</option>
				
				<option value="file56">github.com/baetyl/baetyl/master/engine/infostats.go (0.0%)</option>
				
				<option value="file57">github.com/baetyl/baetyl/master/engine/instance.go (0.0%)</option>
				
				<option value="file58">github.com/baetyl/baetyl/master/engine/native/engine.go (11.3%)</option>
				
				<option value="file59">github.com/baetyl/baetyl/master/engine/native/instance.go (0.0%)</option>
				
				<option value="file60">github.com/baetyl/baetyl/master/engine/native/process.go (0.0%)</option>
				
				<option value="file61">github.com/baetyl/baetyl/master/engine/native/service.go (0.0%)</option>
				
				<option value="file62">github.com/baetyl/baetyl/master/engine/supervisor.go (0.0%)</option>
				
				<option value="file63">github.com/baetyl/baetyl/master/inspect.go (44.8%)</option>
				
				<option value="file64">github.com/baetyl/baetyl/master/master.go (21.7%)</option>
				
				<option value="file65">github.com/baetyl/baetyl/master/service.go (73.1%)</option>
				
				<option value="file66">github.com/baetyl/baetyl/master/update.go (50.8%)</option>
				
				<option value="file67">github.com/baetyl/baetyl/protocol/http/client.go (89.1%)</option>
				
				<option value="file68">github.com/baetyl/baetyl/protocol/http/server.go (82.7%)</option>
				
				<option value="file69">github.com/baetyl/baetyl/protocol/mqtt/client.go (91.8%)</option>
				
				<option value="file70">github.com/baetyl/baetyl/protocol/mqtt/dialer.go (83.3%)</option>
				
				<option value="file71">github.com/baetyl/baetyl/protocol/mqtt/dispatcher.go (0.0%)</option>
				
				<option value="file72">github.com/baetyl/baetyl/protocol/mqtt/future.go (100.0%)</option>
				
				<option value="file73">github.com/baetyl/baetyl/protocol/mqtt/handler.go (0.0%)</option>
				
				<option value="file74">github.com/baetyl/baetyl/protocol/mqtt/launcher.go (0.0%)</option>
				
				<option value="file75">github.com/baetyl/baetyl/protocol/mqtt/utils.go (0.0%)</option>
				
				<option value="file76">github.com/baetyl/baetyl/sdk/baetyl-go/client.go (34.0%)</option>
				
				<option value="file77">github.com/baetyl/baetyl/sdk/baetyl-go/config.go (66.7%)</option>
				
				<option value="file78">github.com/baetyl/baetyl/sdk/baetyl-go/config_deprecated.go (100.0%)</option>
				
				<option value="file79">github.com/baetyl/baetyl/sdk/baetyl-go/context.go (0.0%)</option>
				
				<option value="file80">github.com/baetyl/baetyl/sdk/baetyl-go/function.pb.go (35.4%)</option>
				
				<option value="file81">github.com/baetyl/baetyl/sdk/baetyl-go/function_client.go (90.0%)</option>
				
				<option value="file82">github.com/baetyl/baetyl/sdk/baetyl-go/function_server.go (80.0%)</option>
				
				<option value="file83">github.com/baetyl/baetyl/sdk/baetyl-go/inspect.go (0.0%)</option>
				
				<option value="file84">github.com/baetyl/baetyl/sdk/baetyl-go/kv.pb.go (3.3%)</option>
				
				<option value="file85">github.com/baetyl/baetyl/sdk/baetyl-go/service.go (0.0%)</option>
				
				<option value="file86">github.com/baetyl/baetyl/utils/aes.go (78.6%)</option>
				
				<option value="file87">github.com/baetyl/baetyl/utils/cert.go (75.0%)</option>
				
				<option value="file88">github.com/baetyl/baetyl/utils/config.go (94.1%)</option>
				
				<option value="file89">github.com/baetyl/baetyl/utils/defaults.go (85.7%)</option>
				
				<option value="file90">github.com/baetyl/baetyl/utils/env.go (0.0%)</option>
				
				<option value="file91">github.com/baetyl/baetyl/utils/equal.go (100.0%)</option>
				
				<option value="file92">github.com/baetyl/baetyl/utils/path.go (42.5%)</option>
				
				<option value="file93">github.com/baetyl/baetyl/utils/port.go (75.0%)</option>
				
				<option value="file94">github.com/baetyl/baetyl/utils/rsa.go (73.7%)</option>
				
				<option value="file95">github.com/baetyl/baetyl/utils/stat.go (41.3%)</option>
				
				<option value="file96">github.com/baetyl/baetyl/utils/targz.go (100.0%)</option>
				
				<option value="file97">github.com/baetyl/baetyl/utils/tls.go (0.0%)</option>
				
				<option value="file98">github.com/baetyl/baetyl/utils/tomb.go (94.1%)</option>
				
				<option value="file99">github.com/baetyl/baetyl/utils/trace.go (0.0%)</option>
				
				<option value="file100">github.com/baetyl/baetyl/utils/url.go (100.0%)</option>
				
				<option value="file101">github.com/baetyl/baetyl/utils/zip.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "strings"

        "github.com/baetyl/baetyl/logger"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

type cleaner struct {
        prefix   string
        target   string
        lversion string              // ast version
        lvolumes []baetyl.VolumeInfo // last volumes
        log      logger.Logger
}

func newCleaner(prefix, target string, log logger.Logger) *cleaner <span class="cov8" title="1">{
        return &amp;cleaner{
                prefix: prefix,
                target: target,
                log:    log,
        }
}</span>

func (c *cleaner) reset() <span class="cov0" title="0">{
        c.lversion = ""
        c.lvolumes = nil
}</span>

func (c *cleaner) set(version string, volumes []baetyl.VolumeInfo) <span class="cov8" title="1">{
        c.lversion = version
        c.lvolumes = volumes
}</span>

func (c *cleaner) do(version string) <span class="cov8" title="1">{
        if c.lvolumes == nil || version == "" || c.lversion != version </span><span class="cov8" title="1">{
                c.log.Debugf("version (%s) is ignored", version)
                return
        }</span>

        <span class="cov8" title="1">c.log.Infof("start to clean '%s'", c.target)
        defer utils.Trace("end to clean,", c.log.Infof)()

        // list folders to remove
        remove, err := list(c.prefix, c.target, c.lvolumes)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warnf("failed to list old volumes")
                return
        }</span>
        <span class="cov8" title="1">for _, v := range remove </span><span class="cov8" title="1">{
                if os.RemoveAll(v) == nil </span><span class="cov8" title="1">{
                        c.log.Infof("old volume is removed: %s", v)
                }</span> else<span class="cov0" title="0"> {
                        c.log.WithError(err).Warnf("failed to remove old volumes")
                }</span>
        }
}

func list(prefix, target string, volumes []baetyl.VolumeInfo) ([]string, error) <span class="cov8" title="1">{
        keep := map[string]bool{}
        for _, v := range volumes </span><span class="cov8" title="1">{
                // remove prefix from path
                p, err := filepath.Rel(prefix, v.Path)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">ps := strings.Split(p, string(filepath.Separator))
                if len(ps) == 0 </span><span class="cov0" title="0">{
                        // ignore the case that path equals prefix
                        continue</span>
                }
                <span class="cov8" title="1">if ps[0] == ".." </span><span class="cov8" title="1">{
                        // ignore the case that path out of prefix
                        continue</span>
                }
                <span class="cov8" title="1">keep[ps[0]] = len(ps) &gt; 1</span>
        }
        <span class="cov8" title="1">infos, err := ioutil.ReadDir(target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">remove := []string{}
        for _, info := range infos </span><span class="cov8" title="1">{
                // skip the files and only clean folders,
                if !info.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">next, ok := keep[info.Name()]
                if !ok </span><span class="cov8" title="1">{
                        remove = append(remove, filepath.Join(target, info.Name()))
                }</span> else<span class="cov8" title="1"> if next </span><span class="cov8" title="1">{
                        nextremove, err := list(path.Join(prefix, info.Name()), path.Join(target, info.Name()), volumes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">remove = append(remove, nextremove...)</span>
                }
        }
        <span class="cov8" title="1">return remove, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "path"
        "path/filepath"
        "time"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

func (a *agent) downloadVolumes(volumes []baetyl.VolumeInfo) error <span class="cov0" title="0">{
        for _, v := range volumes </span><span class="cov0" title="0">{
                if v.Meta.URL == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_, _, err := a.downloadVolume(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (a *agent) downloadVolume(v baetyl.VolumeInfo) (string, string, error) <span class="cov0" title="0">{
        rp, err := filepath.Rel(baetyl.DefaultDBDir, v.Path)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("path of volume (%s) invalid: %s", v.Name, err.Error())
        }</span>

        <span class="cov0" title="0">hostDir := path.Join(baetyl.DefaultDBDir, rp)
        containerDir := path.Join(baetyl.DefaultDBDir, "volumes", rp)
        containerZipFile := path.Join(containerDir, v.Name+".zip")

        // volume exists
        if utils.FileExists(containerZipFile) </span><span class="cov0" title="0">{
                md5, err := utils.CalculateFileMD5(containerZipFile)
                if err == nil &amp;&amp; md5 == v.Meta.MD5 </span><span class="cov0" title="0">{
                        a.ctx.Log().Debugf("volume (%s) exists", v.Name)
                        return hostDir, containerDir, nil
                }</span>
        }

        <span class="cov0" title="0">res, err := a.http.SendUrl("GET", v.Meta.URL, nil, nil)
        if err != nil || res == nil </span><span class="cov0" title="0">{
                // retry
                time.Sleep(time.Second)
                res, err = a.http.SendUrl("GET", v.Meta.URL, nil, nil)
                if err != nil || res == nil </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("failed to download volume (%s): %v", v.Name, err)
                }</span>
        }
        <span class="cov0" title="0">defer res.Close()

        err = os.MkdirAll(containerDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to prepare volume (%s): %s", v.Name, err.Error())
        }</span>
        <span class="cov0" title="0">err = utils.WriteFile(containerZipFile, res)
        if err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(containerDir)
                return "", "", fmt.Errorf("failed to prepare volume (%s): %s", v.Name, err.Error())
        }</span>

        <span class="cov0" title="0">md5, err := utils.CalculateFileMD5(containerZipFile)
        if err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(containerDir)
                return "", "", fmt.Errorf("failed to calculate MD5 of volume (%s): %s", v.Name, err.Error())
        }</span>
        <span class="cov0" title="0">if md5 != v.Meta.MD5 </span><span class="cov0" title="0">{
                os.RemoveAll(containerDir)
                return "", "", fmt.Errorf("MD5 of volume (%s) invalid", v.Name)
        }</span>

        <span class="cov0" title="0">err = utils.Unzip(containerZipFile, containerDir)
        if err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(containerDir)
                return "", "", fmt.Errorf("failed to unzip volume (%s): %s", v.Name, err.Error())
        }</span>
        <span class="cov0" title="0">return hostDir, containerDir, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/256dpi/gomqtt/packet"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

// EventType the type of event from cloud
type EventType string

// EventHandle the handler of event from cloud
type EventHandle func(e *Event)

// The type of event from cloud
const (
        OTA     EventType = "OTA"
        Update  EventType = "UPDATE" // deprecated
        Unknown EventType = "UNKNOWN"
)

// Event event message
type Event struct {
        Time    time.Time   `json:"time"`
        Type    EventType   `json:"event"`
        Content interface{} `json:"content"`
}

// NewEvent creates a new event
func NewEvent(v []byte) (*Event, error) <span class="cov8" title="1">{
        e := &amp;Event{}
        err := json.Unmarshal(v, e)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event invalid: %s", err.Error())
        }</span>
        <span class="cov8" title="1">switch e.Type </span>{
        case OTA:<span class="cov8" title="1">
                e.Content = &amp;EventOTA{}</span>
        case Update:<span class="cov8" title="1">
                e.Content = &amp;UpdateEvent{}</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("event type (%s) unexpected", e.Type)</span>
        }
        <span class="cov8" title="1">err = json.Unmarshal(v, e)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event content invalid: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return e, nil</span>
}

// EventOTA OTA event
type EventOTA struct {
        Type    string            `json:"type,omitempty"`
        Trace   string            `json:"trace,omitempty"`
        Version string            `json:"version,omitempty"`
        Volume  baetyl.VolumeInfo `json:"volume,omitempty"`
}

// UpdateEvent update event
// TODO: deprecate
type UpdateEvent struct {
        Trace   string            `json:"trace,omitempty"`
        Version string            `json:"version,omitempty"`
        Config  baetyl.VolumeInfo `json:"config,omitempty"`
}

func (a *agent) ProcessPublish(p *packet.Publish) error <span class="cov0" title="0">{
        if p.Message.QOS == 1 </span><span class="cov0" title="0">{
                puback := packet.NewPuback()
                puback.ID = p.ID
                a.mqtt.Send(puback)
        }</span>
        <span class="cov0" title="0">e, err := NewEvent(p.Message.Payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // convert update event to ota event
        <span class="cov0" title="0">ue, ok := e.Content.(*UpdateEvent)
        if ok </span><span class="cov0" title="0">{
                e.Type = OTA
                e.Content = &amp;EventOTA{
                        Type:    baetyl.OTAAPP,
                        Trace:   ue.Trace,
                        Version: ue.Version,
                        Volume:  ue.Config,
                }
        }</span>
        <span class="cov0" title="0">a.ctx.Log().Debugln("event:", string(p.Message.Payload))
        select </span>{
        case a.events &lt;- e:<span class="cov0" title="0"></span>
        case &lt;-a.tomb.Dying():<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (a *agent) ProcessPuback(p *packet.Puback) error <span class="cov0" title="0">{
        return nil
}</span>

func (a *agent) ProcessError(err error) <span class="cov0" title="0">{
        a.ctx.Log().Errorf(err.Error())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "io/ioutil"
        "os"
        "path"
        "strings"

        "github.com/baetyl/baetyl/protocol/http"
        "github.com/baetyl/baetyl/protocol/mqtt"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

// agent agent module
type agent struct {
        cfg  Config
        ctx  baetyl.Context
        tomb utils.Tomb

        // process
        mqtt   *mqtt.Dispatcher
        events chan *Event
        // report
        certSN  string
        certKey []byte
        http    *http.Client
        // clean
        cleaner *cleaner
}

func main() <span class="cov0" title="0">{
        // backward compatibility
        addSymlinkCompatible()
        baetyl.Run(func(ctx baetyl.Context) error </span><span class="cov0" title="0">{
                a, err := newAgent(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer a.close()
                err = a.start(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">ctx.Wait()
                return nil</span>
        })
}

func newAgent(ctx baetyl.Context) (*agent, error) <span class="cov0" title="0">{
        var cfg Config
        err := ctx.LoadConfig(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = defaults(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sn, err := utils.GetSerialNumber(cfg.Remote.MQTT.Cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">key, err := ioutil.ReadFile(cfg.Remote.MQTT.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cli, err := http.NewClient(cfg.Remote.HTTP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;agent{
                cfg:     cfg,
                ctx:     ctx,
                http:    cli,
                events:  make(chan *Event, 1),
                certSN:  sn,
                certKey: key,
                mqtt:    mqtt.NewDispatcher(cfg.Remote.MQTT, ctx.Log()),
                cleaner: newCleaner(baetyl.DefaultDBDir, path.Join(baetyl.DefaultDBDir, "volumes"), ctx.Log().WithField("agent", "cleaner")),
        }, nil</span>
}

func (a *agent) start(ctx baetyl.Context) error <span class="cov0" title="0">{
        err := a.mqtt.Start(a)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return a.tomb.Go(a.reporting, a.processing)</span>
}

func (a *agent) clean(version string) <span class="cov0" title="0">{
        a.cleaner.do(version)
}</span>

func (a *agent) dying() &lt;-chan struct{} <span class="cov0" title="0">{
        return a.tomb.Dying()
}</span>

func (a *agent) close() <span class="cov0" title="0">{
        a.tomb.Kill(nil)
        a.tomb.Wait()
        a.mqtt.Close()
}</span>

func defaults(c *Config) error <span class="cov0" title="0">{
        if c.Remote.MQTT.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote mqtt address missing")
        }</span>
        <span class="cov0" title="0">if c.Remote.HTTP.CA == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("remote http ca missing, must enable ssl")
        }</span>
        <span class="cov0" title="0">if c.Remote.HTTP.Address == "" </span><span class="cov0" title="0">{
                if strings.Contains(c.Remote.MQTT.Address, "bj.baidubce.com") </span><span class="cov0" title="0">{
                        c.Remote.HTTP.Address = "https://iotedge.bj.baidubce.com"
                }</span> else<span class="cov0" title="0"> if strings.Contains(c.Remote.MQTT.Address, "gz.baidubce.com") </span><span class="cov0" title="0">{
                        c.Remote.HTTP.Address = "https://iotedge.gz.baidubce.com"
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("remote http address missing")
                }</span>
        }
        <span class="cov0" title="0">c.Remote.Desire.Topic = fmt.Sprintf(c.Remote.Desire.Topic, c.Remote.MQTT.ClientID)
        c.Remote.Report.Topic = fmt.Sprintf(c.Remote.Report.Topic, c.Remote.MQTT.ClientID)
        c.Remote.MQTT.Subscriptions = append(c.Remote.MQTT.Subscriptions, mqtt.TopicInfo{QOS: 1, Topic: c.Remote.Desire.Topic})
        return nil</span>
}

func addSymlinkCompatible() <span class="cov0" title="0">{
        list := map[string]string{
                // openedge -&gt; baetyl
                baetyl.DefaultMasterConfDir: baetyl.PreviousMasterConfDir,
                baetyl.DefaultDBDir:         baetyl.PreviousDBDir,
                baetyl.DefaultLogDir:        baetyl.PreviousLogDir,
                // baetyl -&gt; openedge
                baetyl.PreviousMasterConfDir: baetyl.DefaultMasterConfDir,
                baetyl.PreviousDBDir:         baetyl.DefaultDBDir,
                baetyl.PreviousLogDir:        baetyl.DefaultLogDir,
        }
        for k, v := range list </span><span class="cov0" title="0">{
                err := addSymlink(k, v)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                }</span>
        }
}

func addSymlink(src, desc string) error <span class="cov0" title="0">{
        if utils.PathExists(src) </span><span class="cov0" title="0">{
                err := utils.CreateSymlink(path.Base(src), desc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "os"
        "time"

        "github.com/baetyl/baetyl/logger"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

type record struct {
        Time  string `json:"time,omitempty"`
        Step  string `json:"step,omitempty"`
        Trace string `json:"trace,omitempty"`
        Error string `json:"error,omitempty"`
}

func newRecord(data []byte) (*record, error) <span class="cov0" title="0">{
        var r record
        err := json.Unmarshal(data, &amp;r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;r, nil</span>
}

type progress struct {
        event   *EventOTA
        records []*record
}

func newProgress(event *EventOTA) *progress <span class="cov0" title="0">{
        return &amp;progress{
                event:   event,
                records: []*record{},
        }
}</span>

func (p *progress) append(step, msg, err string) <span class="cov0" title="0">{
        p.records = append(p.records, &amp;record{Time: time.Now().UTC().String(), Step: step, Error: err})
}</span>

type operator interface {
        report(...*progress) *inspect
        dying() &lt;-chan struct{}
        clean(string)
}

type otalog struct {
        cfg      OTAInfo
        opt      operator
        progress *progress
        rlog     logger.Logger
        log      logger.Logger
}

func newOTALog(cfg OTAInfo, opt operator, event *EventOTA, log logger.Logger) *otalog <span class="cov0" title="0">{
        o := &amp;otalog{
                cfg:      cfg,
                opt:      opt,
                progress: newProgress(event),
        }
        if event == nil </span><span class="cov0" title="0">{
                if !utils.FileExists(cfg.Logger.Path) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">o.rlog = logger.New(cfg.Logger)
                o.log = log</span>
        } else<span class="cov0" title="0"> {
                o.rlog = logger.New(cfg.Logger, baetyl.OTAKeyTrace, event.Trace, baetyl.OTAKeyType, event.Type)
                o.log = log.WithField(baetyl.OTAKeyTrace, event.Trace).WithField(baetyl.OTAKeyType, event.Type)
                o.write(baetyl.OTAReceived, "ota event is received", nil)
        }</span>
        <span class="cov0" title="0">return o</span>
}

func (o *otalog) write(step, msg string, err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                o.progress.append(step, msg, "")
                o.rlog.WithField(baetyl.OTAKeyStep, step).Infof(msg)
        }</span> else<span class="cov0" title="0"> {
                o.progress.append(step, msg, err.Error())
                o.rlog.WithField(baetyl.OTAKeyStep, step).WithError(err).Errorf(msg)
        }</span>
}

func (o *otalog) isFinished() bool <span class="cov0" title="0">{
        l := len(o.progress.records)
        if l == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch o.progress.records[l-1].Step </span>{
        case baetyl.OTAUpdated, baetyl.OTARolledBack, baetyl.OTAFailure, baetyl.OTATimeout:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (o *otalog) isSuccess() bool <span class="cov0" title="0">{
        l := len(o.progress.records)
        if l == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return o.progress.records[l-1].Step == baetyl.OTAUpdated</span>
}

func (o *otalog) load() bool <span class="cov0" title="0">{
        file, err := os.Open(o.cfg.Logger.Path)
        if err != nil </span><span class="cov0" title="0">{
                o.log.WithError(err).Warnf("failed to open log")
                return false
        }</span>
        <span class="cov0" title="0">defer file.Close()

        records := []*record{}
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                r, err := newRecord(scanner.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        o.log.WithError(err).Warnf("failed to parse record")
                        return false
                }</span>
                <span class="cov0" title="0">if o.progress.event == nil &amp;&amp; r.Trace != "" </span><span class="cov0" title="0">{
                        o.progress.event = &amp;EventOTA{
                                Trace: r.Trace,
                        }
                }</span>
                <span class="cov0" title="0">records = append(records, r)</span>
        }

        <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">changed := len(o.progress.records) != len(records)
        o.progress.records = records
        return changed</span>
}

func (o *otalog) wait() <span class="cov0" title="0">{
        o.log.Infof("waiting ota to finish")
        defer o.log.Infof("ota is finished")
        defer o.close()

        ticker := time.NewTicker(time.Second)
        timer := time.NewTimer(o.cfg.Timeout)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if o.load() </span><span class="cov0" title="0">{
                                io := o.opt.report(o.progress)
                                if o.isFinished() </span><span class="cov0" title="0">{
                                        if o.isSuccess() </span><span class="cov0" title="0">{
                                                o.opt.clean(io.Software.ConfVersion)
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }
                        }
                case &lt;-timer.C:<span class="cov0" title="0">
                        o.load()
                        if !o.isFinished() </span><span class="cov0" title="0">{
                                o.write(baetyl.OTATimeout, "ota is timed out", nil)
                                o.log.Warnf("ota is timed out")
                        }</span>
                        <span class="cov0" title="0">o.opt.report(o.progress)
                        return</span>
                case &lt;-o.opt.dying():<span class="cov0" title="0">
                        o.load()
                        o.opt.report(o.progress)
                        return</span>
                }
        }
}

func (o *otalog) close() <span class="cov0" title="0">{
        if o.isFinished() </span><span class="cov0" title="0">{
                err := os.RemoveAll(o.cfg.Logger.Path)
                if err != nil </span><span class="cov0" title="0">{
                        o.log.WithError(err).Warnf("failed to remove log")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "path"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

func (a *agent) processing() error <span class="cov0" title="0">{
        ol := newOTALog(a.cfg.OTA, a, nil, a.ctx.Log().WithField("agent", "otalog"))
        if ol != nil </span><span class="cov0" title="0">{
                ol.wait()
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case e := &lt;-a.events:<span class="cov0" title="0">
                        a.cleaner.reset()
                        a.processEvent(e)</span>
                case &lt;-a.tomb.Dying():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}

func (a *agent) processEvent(e *Event) <span class="cov0" title="0">{
        eo := e.Content.(*EventOTA)
        a.ctx.Log().Infof("process ota: type=%s, trace=%s", eo.Type, eo.Trace)
        ol := newOTALog(a.cfg.OTA, a, eo, a.ctx.Log().WithField("agent", "otalog"))
        defer ol.wait()

        err := a.processOTA(eo)
        if err != nil </span><span class="cov0" title="0">{
                a.ctx.Log().WithError(err).Warnf("failed to process ota event")
                ol.write(baetyl.OTAFailure, "failed to process ota event", err)
        }</span>
}

func (a *agent) processOTA(eo *EventOTA) error <span class="cov0" title="0">{
        hostDir, containerDir, err := a.downloadVolume(eo.Volume)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download volume: %s", err.Error())
        }</span>
        <span class="cov0" title="0">var hostTarget string
        if eo.Type == baetyl.OTAAPP </span><span class="cov0" title="0">{
                hostTarget = path.Join(hostDir, baetyl.AppConfFileName)
                containerAppFile := path.Join(containerDir, baetyl.AppConfFileName)
                containerMetadataFile := path.Join(containerDir, baetyl.MetadataFileName)
                var meta Metadata
                file := containerMetadataFile
                if !utils.FileExists(containerMetadataFile) </span><span class="cov0" title="0">{
                        file = containerAppFile
                }</span>
                <span class="cov0" title="0">if err = utils.LoadYAML(file, &amp;meta); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cfg, err := baetyl.LoadComposeAppConfigCompatible(containerAppFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // check service list, cannot be empty
                <span class="cov0" title="0">if len(cfg.Services) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("app config invalid: service list is empty")
                }</span>
                <span class="cov0" title="0">err = a.downloadVolumes(meta.Volumes)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to download app volumes: %s", err.Error())
                }</span>
                <span class="cov0" title="0">a.cleaner.set(meta.Version, meta.Volumes)</span>
        } else<span class="cov0" title="0"> if eo.Type == baetyl.OTAMST </span><span class="cov0" title="0">{
                hostTarget = path.Join(hostDir, baetyl.DefaultBinFile)
        }</span>
        <span class="cov0" title="0">err = a.ctx.UpdateSystem(eo.Trace, eo.Type, hostTarget)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update system: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "encoding/base64"
        "encoding/json"
        "time"

        "github.com/baetyl/baetyl/logger"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

type inspect struct {
        *baetyl.Inspect `json:",inline"`
        OTA             map[string][]*record `json:"ota,omitempty"`
}

func (a *agent) reporting() error <span class="cov0" title="0">{
        t := time.NewTicker(a.cfg.Remote.Report.Interval)
        a.report()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-t.C:<span class="cov0" title="0">
                        a.report()</span>
                case &lt;-a.tomb.Dying():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}

// Report reports info
func (a *agent) report(pgs ...*progress) *inspect <span class="cov0" title="0">{
        defer utils.Trace("report", logger.Debugf)()

        i, err := a.ctx.InspectSystem()
        if err != nil </span><span class="cov0" title="0">{
                a.ctx.Log().WithError(err).Warnf("failed to inspect stats")
                i = baetyl.NewInspect()
                i.Error = err.Error()
        }</span>

        <span class="cov0" title="0">io := &amp;inspect{Inspect: i}
        for _, pg := range pgs </span><span class="cov0" title="0">{
                if io.OTA == nil </span><span class="cov0" title="0">{
                        io.OTA = map[string][]*record{}
                }</span>
                <span class="cov0" title="0">if pg.event != nil &amp;&amp; pg.event.Trace != "" </span><span class="cov0" title="0">{
                        io.OTA[pg.event.Trace] = pg.records
                }</span>
        }

        <span class="cov0" title="0">payload, err := json.Marshal(io)
        if err != nil </span><span class="cov0" title="0">{
                a.ctx.Log().WithError(err).Warnf("failed to marshal stats")
                return nil
        }</span>
        <span class="cov0" title="0">a.ctx.Log().Debugln("stats", string(payload))
        // TODO: connect with device management on cloud
        // p := packet.NewPublish()
        // p.Message.Topic = a.cfg.Remote.Report.Topic
        // p.Message.Payload = payload
        // err = a.mqtt.Send(p)
        // if err != nil {
        //         a.ctx.Log().WithError(err).Warnf("failed to report stats by mqtt")
        // }
        err = a.send(payload)
        if err != nil </span><span class="cov0" title="0">{
                a.ctx.Log().WithError(err).Warnf("failed to report stats by https")
                return nil
        }</span>
        <span class="cov0" title="0">return io</span>
}

func (a *agent) send(data []byte) error <span class="cov0" title="0">{
        body, key, err := a.encryptData(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">header := map[string]string{
                "x-iot-edge-sn":       a.certSN,
                "x-iot-edge-key":      key,
                "x-iot-edge-clientid": a.cfg.Remote.MQTT.ClientID,
                "Content-Type":        "application/x-www-form-urlencoded",
        }
        _, err = a.http.SendPath("POST", a.cfg.Remote.Report.URL, body, header)
        return err</span>
}

func (a *agent) encryptData(data []byte) ([]byte, string, error) <span class="cov0" title="0">{
        aesKey := utils.NewAesKey()
        // encrypt data using AES
        body, err := utils.AesEncrypt(data, aesKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        // encrypt AES key using RSA
        <span class="cov0" title="0">k, err := utils.RsaPrivateEncrypt(aesKey, a.certKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        // encode key using BASE64
        <span class="cov0" title="0">key := base64.StdEncoding.EncodeToString(k)
        // encode body using BASE64
        body = []byte(base64.StdEncoding.EncodeToString(body))
        return body, key, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "fmt"

        "github.com/baetyl/baetyl/logger"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
        pool "github.com/jolestar/go-commons-pool"
)

// Function function
type Function struct {
        p    Producer
        cfg  FunctionInfo
        ids  chan uint32
        pool *pool.ObjectPool
        log  logger.Logger
        tomb utils.Tomb
}

// NewFunction creates a new function
func NewFunction(cfg FunctionInfo, p Producer) *Function <span class="cov8" title="1">{
        f := &amp;Function{
                p:   p,
                cfg: cfg,
                ids: make(chan uint32, cfg.Instance.Max),
                log: logger.WithField("function", cfg.Name),
        }
        for index := 1; index &lt;= cfg.Instance.Max; index++ </span><span class="cov8" title="1">{
                f.ids &lt;- uint32(index)
        }</span>
        <span class="cov8" title="1">pc := pool.NewDefaultPoolConfig()
        pc.MinIdle = cfg.Instance.Min
        pc.MaxIdle = cfg.Instance.Max
        pc.MaxTotal = cfg.Instance.Max
        pc.MinEvictableIdleTime = cfg.Instance.IdleTime
        pc.TimeBetweenEvictionRuns = cfg.Instance.EvictTime
        f.pool = pool.NewObjectPool(context.Background(), f, pc)
        return f</span>
}

// Call calls function to handle message and return result message
func (f *Function) Call(msg *baetyl.FunctionMessage) (*baetyl.FunctionMessage, error) <span class="cov8" title="1">{
        item, err := f.pool.BorrowObject(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return f.call(item.(Instance), msg, nil)</span>
}

// CallAsync calls function to handle message and return result message
func (f *Function) CallAsync(msg *baetyl.FunctionMessage, cb func(in, out *baetyl.FunctionMessage, err error)) error <span class="cov8" title="1">{
        item, err := f.pool.BorrowObject(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">go f.call(item.(Instance), msg, cb)
        return nil</span>
}

func (f *Function) call(i Instance, in *baetyl.FunctionMessage, c func(in, out *baetyl.FunctionMessage, err error)) (*baetyl.FunctionMessage, error) <span class="cov8" title="1">{
        out, err := i.Call(in)
        if err != nil </span><span class="cov8" title="1">{
                f.log.Errorf("failed to talk with function instance: %s", err.Error())
                err1 := f.pool.InvalidateObject(context.Background(), i)
                if err1 != nil </span><span class="cov0" title="0">{
                        f.p.StopInstance(i) // stop the instance if it cannot be returned to pool
                        f.log.Errorf("failed to invalidate function instance: %s", err1.Error())
                }</span>
        } else<span class="cov8" title="1"> {
                err1 := f.pool.ReturnObject(context.Background(), i)
                if err1 != nil </span><span class="cov0" title="0">{
                        f.p.StopInstance(i) // stop the instance if it cannot be returned to pool
                        f.log.Errorf("failed to return function instance: %s", err1.Error())
                }</span>
        }
        <span class="cov8" title="1">if c != nil </span><span class="cov8" title="1">{
                c(in, out, err)
        }</span>
        <span class="cov8" title="1">return out, err</span>
}

// Close close function and stop all function instances
// The function instance will be stopped in three cases:
// 1. function instance returns a system error
// 2. function instance is not invoked for a period of time [TODO]
// 3. function manager is closed
func (f *Function) Close() error <span class="cov8" title="1">{
        f.pool.Close(context.Background())
        f.log.Debugf("function closed")
        f.tomb.Kill(nil)
        return f.tomb.Wait()
}</span>

// MakeObject creates a new instance
func (f *Function) MakeObject(_ context.Context) (*pool.PooledObject, error) <span class="cov8" title="1">{
        select </span>{
        case id := &lt;-f.ids:<span class="cov8" title="1">
                f.log.Infof("instance created")
                i, err := f.p.StartInstance(id)
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case f.ids &lt;- id:<span class="cov0" title="0"></span>
                        case &lt;-f.tomb.Dying():<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">return pool.NewPooledObject(i), nil</span>
        case &lt;-f.tomb.Dying():<span class="cov0" title="0">
                return nil, fmt.Errorf("function closed")</span>
        }

}

// DestroyObject close an instance
func (f *Function) DestroyObject(ctx context.Context, object *pool.PooledObject) error <span class="cov8" title="1">{
        f.log.Infof("instance destroyed")
        i := object.Object.(Instance)
        f.p.StopInstance(i)
        select </span>{
        case f.ids &lt;- i.ID():<span class="cov8" title="1"></span>
        case &lt;-f.tomb.Dying():<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateObject not implement
func (f *Function) ValidateObject(ctx context.Context, object *pool.PooledObject) bool <span class="cov0" title="0">{
        return true
}</span>

// ActivateObject not implement
func (f *Function) ActivateObject(ctx context.Context, object *pool.PooledObject) error <span class="cov8" title="1">{
        return nil
}</span>

// PassivateObject not implement
func (f *Function) PassivateObject(ctx context.Context, object *pool.PooledObject) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "io"
        "os"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

// Instance function instance interface
type Instance interface {
        ID() uint32
        Name() string
        Call(msg *baetyl.FunctionMessage) (*baetyl.FunctionMessage, error)
        io.Closer
}

// Producer function instance producer interface
type Producer interface {
        StartInstance(id uint32) (Instance, error)
        StopInstance(i Instance) error
}

type producer struct {
        ctx baetyl.Context
        cfg FunctionInfo
}

func newProducer(ctx baetyl.Context, cfg FunctionInfo) Producer <span class="cov0" title="0">{
        return &amp;producer{ctx: ctx, cfg: cfg}
}</span>

// StartInstance starts instance
func (p *producer) StartInstance(id uint32) (Instance, error) <span class="cov0" title="0">{
        name := fmt.Sprintf("%s.%s.%d", p.cfg.Service, p.cfg.Name, id)
        port := "50051"
        serverHost := "0.0.0.0"
        clientHost := name
        if os.Getenv(baetyl.EnvKeyServiceMode) == "native" ||
                /*backward compatibility*/ os.Getenv(baetyl.EnvRunningModeKey) == "native" </span><span class="cov0" title="0">{
                var err error
                port, err = p.ctx.GetAvailablePort()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">serverHost = "127.0.0.1"
                clientHost = serverHost</span>
        }

        <span class="cov0" title="0">address := fmt.Sprintf("%s:%s", serverHost, port)
        dc := map[string]string{
                baetyl.EnvServiceAddressKey:         address, // deprecated, for v0.1.2
                baetyl.EnvServiceInstanceAddressKey: address, // deprecated, for v0.1.3~5
                baetyl.EnvKeyServiceInstanceAddress: address,
        }
        err := p.ctx.StartInstance(p.cfg.Service, name, dc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fcc := baetyl.FunctionClientConfig{}
        fcc.Address = fmt.Sprintf("%s:%s", clientHost, port)
        fcc.Message.Length.Max = p.cfg.Message.Length.Max
        fcc.Timeout = p.cfg.Timeout
        fcc.Backoff = p.cfg.Backoff
        cli, err := baetyl.NewFClient(fcc)
        if err != nil </span><span class="cov0" title="0">{
                p.ctx.StopInstance(p.cfg.Service, name)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;instance{
                id:      id,
                name:    name,
                FClient: cli,
        }, nil</span>
}

// StopInstance stops instance
func (p *producer) StopInstance(i Instance) error <span class="cov0" title="0">{
        i.Close()
        return p.ctx.StopInstance(p.cfg.Service, i.Name())
}</span>

type instance struct {
        id   uint32
        name string
        *baetyl.FClient
}

// ID returns id
func (i *instance) ID() uint32 <span class="cov0" title="0">{
        return i.id
}</span>

// Name returns name
func (i *instance) Name() string <span class="cov0" title="0">{
        return i.name
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "fmt"

        "github.com/baetyl/baetyl/protocol/mqtt"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

func main() <span class="cov0" title="0">{
        baetyl.Run(func(ctx baetyl.Context) error </span><span class="cov0" title="0">{
                var cfg Config
                err := ctx.LoadConfig(&amp;cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">functions := make(map[string]*Function)
                for _, fi := range cfg.Functions </span><span class="cov0" title="0">{
                        functions[fi.Name] = NewFunction(fi, newProducer(ctx, fi))
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        for _, f := range functions </span><span class="cov0" title="0">{
                                f.Close()
                        }</span>
                }()
                <span class="cov0" title="0">rulers := make([]*ruler, 0)
                defer func() </span><span class="cov0" title="0">{
                        for _, ruler := range rulers </span><span class="cov0" title="0">{
                                ruler.close()
                        }</span>
                }()
                <span class="cov0" title="0">for _, ri := range cfg.Rules </span><span class="cov0" title="0">{
                        f, ok := functions[ri.Function.Name]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("function (%s) not found", f.cfg.Name)
                        }</span>
                        <span class="cov0" title="0">c, err := ctx.NewHubClient(ri.ClientID, []mqtt.TopicInfo{ri.Subscribe})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create hub client: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">rulers = append(rulers, newRuler(ri, c, f))</span>
                }
                <span class="cov0" title="0">for _, ruler := range rulers </span><span class="cov0" title="0">{
                        err := ruler.start()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if cfg.Server.Address != "" </span><span class="cov0" title="0">{
                        svr, err := baetyl.NewFServer(cfg.Server, func(ctx context.Context, msg *baetyl.FunctionMessage) (*baetyl.FunctionMessage, error) </span><span class="cov0" title="0">{
                                f, ok := functions[msg.FunctionName]
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("function (%s) not found", msg.FunctionName)
                                }</span>
                                <span class="cov0" title="0">return f.Call(msg)</span>
                        })
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer svr.Close()</span>
                }
                <span class="cov0" title="0">ctx.Wait()
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/256dpi/gomqtt/packet"
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/protocol/mqtt"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/docker/distribution/uuid"
)

type ruler struct {
        cfg RuleInfo
        fun *Function
        hub *mqtt.Dispatcher
        log logger.Logger
}

func newRuler(ri RuleInfo, c *mqtt.Dispatcher, f *Function) *ruler <span class="cov0" title="0">{
        return &amp;ruler{
                cfg: ri,
                hub: c,
                fun: f,
                log: logger.WithField("rule", ri.ClientID),
        }
}</span>

func (rr *ruler) start() error <span class="cov0" title="0">{
        return rr.hub.Start(rr)
}</span>

func (rr *ruler) ProcessPublish(pkt *packet.Publish) error <span class="cov0" title="0">{
        msg := &amp;baetyl.FunctionMessage{
                ID:               uint64(pkt.ID),
                QOS:              uint32(pkt.Message.QOS),
                Topic:            pkt.Message.Topic,
                Payload:          pkt.Message.Payload,
                Timestamp:        time.Now().UTC().Unix(),
                FunctionName:     rr.cfg.Function.Name,
                FunctionInvokeID: uuid.Generate().String(),
        }
        return rr.fun.CallAsync(msg, rr.callback)
}</span>

func (rr *ruler) ProcessPuback(pkt *packet.Puback) error <span class="cov0" title="0">{
        return rr.hub.Send(pkt)
}</span>

func (rr *ruler) ProcessError(err error) <span class="cov0" title="0">{
        rr.log.Errorf(err.Error())
}</span>

func (rr *ruler) close() <span class="cov0" title="0">{
        rr.hub.Close()
}</span>

func (rr *ruler) callback(in, out *baetyl.FunctionMessage, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                for index := 1; index &lt; rr.cfg.Retry.Max &amp;&amp; err != nil; index++ </span><span class="cov0" title="0">{
                        rr.log.Debugf("function (%s) is retried %d time(s)", rr.fun.cfg.Name, index)
                        out, err = rr.fun.Call(in)
                }</span>
        }
        <span class="cov0" title="0">pkt := packet.NewPublish()
        pkt.ID = packet.ID(in.ID)
        pkt.Message.QOS = packet.QOS(rr.cfg.Publish.QOS)
        if in.QOS &lt; rr.cfg.Publish.QOS </span><span class="cov0" title="0">{
                pkt.Message.QOS = packet.QOS(in.QOS)
        }</span>
        <span class="cov0" title="0">pkt.Message.Topic = rr.cfg.Publish.Topic
        if err != nil </span><span class="cov0" title="0">{
                s := map[string]interface{}{
                        "functionMessage": in,
                        "errorMessage":    err.Error(),
                        "errorType":       fmt.Sprintf("%T", err),
                }
                pkt.Message.Payload, _ = json.Marshal(s)
        }</span> else<span class="cov0" title="0"> if out.Payload != nil </span><span class="cov0" title="0">{
                pkt.Message.Payload = out.Payload
        }</span>
        // filter
        <span class="cov0" title="0">if pkt.Message.Payload != nil </span><span class="cov0" title="0">{
                err := rr.hub.Send(pkt)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">if in.QOS == 1 &amp;&amp; (pkt.Message.QOS == 0 || pkt.Message.Payload == nil) </span><span class="cov0" title="0">{
                puback := packet.NewPuback()
                puback.ID = packet.ID(in.ID)
                rr.hub.Send(puback)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "strings"

        "github.com/256dpi/gomqtt/topic"
        "github.com/baetyl/baetyl/baetyl-hub/config"
        "github.com/baetyl/baetyl/baetyl-hub/utils"
)

// all permit actions
const (
        Publish   = "pub"
        Subscribe = "sub"
)

// Auth auth
type Auth struct {
        // for client certs
        certs map[string]cert
        // for client account
        accounts map[string]account
}

// NewAuth creates auth
func NewAuth(principals []config.Principal) *Auth <span class="cov8" title="1">{
        _certs := make(map[string]cert)
        _accounts := make(map[string]account)
        for _, principal := range principals </span><span class="cov8" title="1">{
                authorizer := NewAuthorizer()
                for _, p := range duplicatePubSubPermitRemove(principal.Permissions) </span><span class="cov8" title="1">{
                        for _, topic := range p.Permits </span><span class="cov8" title="1">{
                                authorizer.Add(topic, p.Action)
                        }</span>
                }
                <span class="cov8" title="1">if principal.Password == "" </span><span class="cov8" title="1">{
                        _certs[principal.Username] = cert{
                                Authorizer: authorizer,
                        }
                }</span> else<span class="cov8" title="1"> {
                        _accounts[principal.Username] = account{
                                Password:   principal.Password,
                                Authorizer: authorizer,
                        }
                }</span>
        }
        <span class="cov8" title="1">return &amp;Auth{certs: _certs, accounts: _accounts}</span>
}

func duplicatePubSubPermitRemove(permission []config.Permission) []config.Permission <span class="cov8" title="1">{
        PubPermitList := make(map[string]struct{})
        SubPermitList := make(map[string]struct{})
        for _, _permission := range permission </span><span class="cov8" title="1">{
                switch _permission.Action </span>{
                case Publish:<span class="cov8" title="1">
                        for _, v := range _permission.Permits </span><span class="cov8" title="1">{
                                PubPermitList[v] = struct{}{}
                        }</span>
                case Subscribe:<span class="cov8" title="1">
                        for _, v := range _permission.Permits </span><span class="cov8" title="1">{
                                SubPermitList[v] = struct{}{}
                        }</span>
                }
        }
        <span class="cov8" title="1">return []config.Permission{
                {Action: Publish, Permits: utils.GetKeys(PubPermitList)},
                {Action: Subscribe, Permits: utils.GetKeys(SubPermitList)},
        }</span>
}

// AuthenticateAccount auth client account, then return authorizer if pass
func (a *Auth) AuthenticateAccount(username, password string) *Authorizer <span class="cov8" title="1">{
        _account, ok := a.accounts[username]
        if ok &amp;&amp; len(password) &gt; 0 &amp;&amp; strings.Compare(password, _account.Password) == 0 </span><span class="cov8" title="1">{
                return _account.Authorizer
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AuthenticateCert auth client cert, then return authorizer if pass
func (a *Auth) AuthenticateCert(serialNumber string) *Authorizer <span class="cov8" title="1">{
        _cert, ok := a.certs[serialNumber]
        if ok </span><span class="cov8" title="1">{
                return _cert.Authorizer
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type account struct {
        Password   string
        Authorizer *Authorizer
}

type cert struct {
        Authorizer *Authorizer
}

// Authorizer checks topic permission
type Authorizer struct {
        *topic.Tree
}

// NewAuthorizer create a new authorizer
func NewAuthorizer() *Authorizer <span class="cov8" title="1">{
        return &amp;Authorizer{Tree: topic.NewTree()}
}</span>

// Authorize auth action
func (p *Authorizer) Authorize(action, topic string) bool <span class="cov8" title="1">{
        _actions := p.Match(topic)
        for _, _action := range _actions </span><span class="cov8" title="1">{
                if action == _action.(string) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package common

import (
        "sync/atomic"
)

// Acknowledge acknowledgement
type Acknowledge struct {
        count int32
        done  chan struct{}
}

// NewAcknowledge creates a new acknowledgement
func NewAcknowledge() *Acknowledge <span class="cov8" title="1">{
        return &amp;Acknowledge{
                count: 1,
                done:  make(chan struct{}),
        }
}</span>

// Ack acknowledges after message handled
func (ack *Acknowledge) Ack() <span class="cov8" title="1">{
        if atomic.AddInt32(&amp;ack.count, -1) == 0 </span><span class="cov8" title="1">{
                close(ack.done)
        }</span>
}

// Count returns the ack count
func (ack *Acknowledge) Count() int32 <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;ack.count)
}</span>

// Wait waits until acknowledged or cancelled
func (ack *Acknowledge) Wait(cancel &lt;-chan struct{}) bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-cancel:<span class="cov0" title="0">
                return false</span>
        case &lt;-ack.done:<span class="cov0" title="0">
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package common

import (
        "time"

        "github.com/baetyl/baetyl/baetyl-hub/utils"
        "github.com/golang/protobuf/proto"
        "github.com/jpillora/backoff"
)

// Q0: it means the message with qos=0 published by clients or functions
// Q1: it means the message with qos=1 published by clients or functions
// Cb: it means the callback which called after message handled.
//     For message with qos=1 published by client, the callback used to send puback
// Ack: it means the acknowledgement which acknowledged after message acknowledged.
//      For message with qos=1 sent to client, it will acknowledged if client send back puback

// Flow flows message
type Flow func(*Message)

// Publish publishes message
type Publish func(Message)

// Message MQTT message with client ID
type Message struct {
        Persisted
        TargetQOS   uint32
        TargetTopic string
        Barrier     bool
        Retain      bool
        PacketID    uint32
        callbackPID func(uint32) // callback for PacketID
        SequenceID  uint64
        callbackSID func(uint64) // callback for SequenceID
        acknowledge *Acknowledge
}

// NewMessage creates a message
func NewMessage(qos uint32, topic string, payload []byte, clientID string) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Persisted: Persisted{
                        QOS:      qos,
                        Topic:    topic,
                        Payload:  payload,
                        ClientID: clientID,
                },
        }
}</span>

// UnmarshalMessage creates a message by persisted data
func UnmarshalMessage(k, v []byte) (*Message, error) <span class="cov8" title="1">{
        msg := &amp;Message{SequenceID: utils.U64(k)}
        err := proto.Unmarshal(v, &amp;msg.Persisted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return msg, nil</span>
}

// SetCallbackPID sets packet id and its callback
func (m *Message) SetCallbackPID(pid uint32, callback func(uint32)) <span class="cov0" title="0">{
        m.PacketID = pid
        m.callbackPID = callback
}</span>

// CallbackPID calls the callback with packet id
func (m *Message) CallbackPID() <span class="cov0" title="0">{
        if m.callbackPID != nil </span><span class="cov0" title="0">{
                m.callbackPID(m.PacketID)
        }</span>
}

// SetCallbackSID sets sequence id and its callback
func (m *Message) SetCallbackSID(callback func(uint64)) <span class="cov8" title="1">{
        m.callbackSID = callback
}</span>

// SetAcknowledge sets acknowledge
func (m *Message) SetAcknowledge() <span class="cov8" title="1">{
        m.acknowledge = NewAcknowledge()
}</span>

// SID returns sequence ID
func (m *Message) SID() uint64 <span class="cov8" title="1">{
        return m.SequenceID
}</span>

// Ack acknowledges after message handled
func (m *Message) Ack() <span class="cov8" title="1">{
        if m.acknowledge != nil </span><span class="cov8" title="1">{
                m.acknowledge.Ack()
        }</span>
}

// MsgAck MQTT message with first send time
type MsgAck struct {
        *Message
        FST time.Time // first send time
}

// WaitTimeout waits until finish
func (m *MsgAck) WaitTimeout(bf *backoff.Backoff, republish Publish, cancel &lt;-chan struct{}) <span class="cov8" title="1">{
        if m.acknowledge == nil </span><span class="cov0" title="0">{
                if m.callbackSID != nil </span><span class="cov0" title="0">{
                        m.callbackSID(m.SequenceID)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">timer := time.NewTimer(bf.Max - time.Now().Sub(m.FST))
        defer timer.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-cancel:<span class="cov8" title="1">
                        return</span>
                case &lt;-m.acknowledge.done:<span class="cov8" title="1">
                        if m.callbackSID != nil </span><span class="cov8" title="1">{
                                m.callbackSID(m.SequenceID)
                        }</span>
                        <span class="cov8" title="1">return</span>
                case &lt;-timer.C:<span class="cov8" title="1">
                        timer.Reset(bf.Max)
                        if republish != nil </span><span class="cov8" title="1">{
                                republish(*m.Message)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: message.proto

package common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Persisted struct {
        QOS                  uint32   `protobuf:"varint,1,opt,name=QOS,proto3" json:"QOS,omitempty"`
        Topic                string   `protobuf:"bytes,2,opt,name=Topic,proto3" json:"Topic,omitempty"`
        Payload              []byte   `protobuf:"bytes,3,opt,name=Payload,proto3" json:"Payload,omitempty"`
        ClientID             string   `protobuf:"bytes,4,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Persisted) Reset()         <span class="cov8" title="1">{ *m = Persisted{} }</span>
func (m *Persisted) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Persisted) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Persisted) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_message_f40bb01bdb0366e4, []int{0}
}</span>
func (m *Persisted) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_Persisted.Unmarshal(m, b)
}</span>
func (m *Persisted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_Persisted.Marshal(b, m, deterministic)
}</span>
func (dst *Persisted) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Persisted.Merge(dst, src)
}</span>
func (m *Persisted) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_Persisted.Size(m)
}</span>
func (m *Persisted) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Persisted.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Persisted proto.InternalMessageInfo

func (m *Persisted) GetQOS() uint32 <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.QOS
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Persisted) GetTopic() string <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Topic
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Persisted) GetPayload() []byte <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Payload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Persisted) GetClientID() string <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.ClientID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Transferred struct {
        Persisted            *Persisted `protobuf:"bytes,1,opt,name=Persisted,proto3" json:"Persisted,omitempty"`
        FunctionName         string     `protobuf:"bytes,2,opt,name=FunctionName,proto3" json:"FunctionName,omitempty"`
        FunctionInvokeID     string     `protobuf:"bytes,3,opt,name=FunctionInvokeID,proto3" json:"FunctionInvokeID,omitempty"`
        FunctionInstanceID   string     `protobuf:"bytes,4,opt,name=FunctionInstanceID,proto3" json:"FunctionInstanceID,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *Transferred) Reset()         <span class="cov8" title="1">{ *m = Transferred{} }</span>
func (m *Transferred) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Transferred) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Transferred) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_message_f40bb01bdb0366e4, []int{1}
}</span>
func (m *Transferred) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_Transferred.Unmarshal(m, b)
}</span>
func (m *Transferred) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_Transferred.Marshal(b, m, deterministic)
}</span>
func (dst *Transferred) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Transferred.Merge(dst, src)
}</span>
func (m *Transferred) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_Transferred.Size(m)
}</span>
func (m *Transferred) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Transferred.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Transferred proto.InternalMessageInfo

func (m *Transferred) GetPersisted() *Persisted <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Persisted
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Transferred) GetFunctionName() string <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.FunctionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Transferred) GetFunctionInvokeID() string <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.FunctionInvokeID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Transferred) GetFunctionInstanceID() string <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.FunctionInstanceID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Persisted)(nil), "common.Persisted")
        proto.RegisterType((*Transferred)(nil), "common.Transferred")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("message.proto", fileDescriptor_message_f40bb01bdb0366e4) }</span>

var fileDescriptor_message_f40bb01bdb0366e4 = []byte{
        // 226 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x90, 0xc1, 0x4a, 0x03, 0x31,
        0x10, 0x86, 0x89, 0xd5, 0xea, 0x4e, 0x5b, 0xa8, 0x83, 0x87, 0xe0, 0x69, 0xd9, 0xd3, 0xe2, 0x61,
        0x05, 0x7d, 0x04, 0x8b, 0xb0, 0x17, 0xad, 0xb1, 0x2f, 0x10, 0xb3, 0xa3, 0x04, 0x9b, 0x4c, 0x49,
        0xa2, 0xe0, 0xcb, 0xf9, 0x6c, 0x62, 0x6a, 0xd7, 0x15, 0x7b, 0xcb, 0xf7, 0xff, 0x84, 0xff, 0x63,
        0x60, 0xe6, 0x28, 0x46, 0xfd, 0x42, 0xcd, 0x26, 0x70, 0x62, 0x1c, 0x1b, 0x76, 0x8e, 0x7d, 0x65,
        0xa1, 0x58, 0x52, 0x88, 0x36, 0x26, 0xea, 0x70, 0x0e, 0xa3, 0x87, 0xfb, 0x47, 0x29, 0x4a, 0x51,
        0xcf, 0xd4, 0xf7, 0x13, 0xcf, 0xe0, 0x68, 0xc5, 0x1b, 0x6b, 0xe4, 0x41, 0x29, 0xea, 0x42, 0x6d,
        0x01, 0x25, 0x1c, 0x2f, 0xf5, 0xc7, 0x9a, 0x75, 0x27, 0x47, 0xa5, 0xa8, 0xa7, 0x6a, 0x87, 0x78,
        0x0e, 0x27, 0x37, 0x6b, 0x4b, 0x3e, 0xb5, 0x0b, 0x79, 0x98, 0xbf, 0xf4, 0x5c, 0x7d, 0x0a, 0x98,
        0xac, 0x82, 0xf6, 0xf1, 0x99, 0x42, 0xa0, 0x0e, 0x2f, 0x07, 0xd3, 0x79, 0x73, 0x72, 0x75, 0xda,
        0x6c, 0xb5, 0x9a, 0xbe, 0x50, 0x03, 0xbd, 0x0a, 0xa6, 0xb7, 0x6f, 0xde, 0x24, 0xcb, 0xfe, 0x4e,
        0x3b, 0xfa, 0x71, 0xfa, 0x93, 0xe1, 0x05, 0xcc, 0x77, 0xdc, 0xfa, 0x77, 0x7e, 0xa5, 0x76, 0x91,
        0x1d, 0x0b, 0xf5, 0x2f, 0xc7, 0x06, 0xf0, 0x37, 0x8b, 0x49, 0x7b, 0x43, 0xbd, 0xf6, 0x9e, 0xe6,
        0x69, 0x9c, 0x4f, 0x77, 0xfd, 0x15, 0x00, 0x00, 0xff, 0xff, 0xba, 0xae, 0x40, 0x52, 0x4b, 0x01,
        0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package common

import (
        "sync"

        "github.com/256dpi/gomqtt/packet"
)

// AckV2 acknowledge interface
type AckV2 interface {
        Ack()
        SID() uint64
}

// PacketIDS generates packet id by sequence id for message
type PacketIDS struct {
        min     packet.ID
        max     packet.ID
        index   map[packet.ID]AckV2
        reindex map[uint64]packet.ID
        sync.RWMutex
}

// NewPacketIDS creates a new PacketIDS
func NewPacketIDS() *PacketIDS <span class="cov8" title="1">{
        return &amp;PacketIDS{min: 1, max: 65535, index: make(map[packet.ID]AckV2), reindex: make(map[uint64]packet.ID)}
}</span>

// Ack acknowledges by packet id
func (p *PacketIDS) Ack(id packet.ID) bool <span class="cov8" title="1">{
        p.Lock()
        ack, ok := p.index[id]
        if ok </span><span class="cov8" title="1">{
                delete(p.index, id)
                delete(p.reindex, ack.SID())
                ack.Ack()
        }</span>
        <span class="cov8" title="1">p.Unlock()
        return ok</span>
}

// Set set acknowledge with a new packet id from sequence id
func (p *PacketIDS) Set(ack AckV2) packet.ID <span class="cov8" title="1">{
        p.Lock()
        reindex := false
        id := packet.ID(ack.SID())
        for </span><span class="cov8" title="1">{
                if id &lt; p.min || id &gt; p.max </span><span class="cov8" title="1">{
                        id = p.max
                        reindex = true
                }</span>
                <span class="cov8" title="1">if _, ok := p.index[id]; !ok </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">id--
                reindex = true</span>
        }
        <span class="cov8" title="1">if reindex </span><span class="cov8" title="1">{
                p.reindex[ack.SID()] = id
        }</span>
        <span class="cov8" title="1">p.index[id] = ack
        p.Unlock()
        return id</span>
}

// Get get packet id
func (p *PacketIDS) Get(sid uint64) (pid packet.ID) <span class="cov8" title="1">{
        p.Lock()
        defer p.Unlock()
        if v, ok := p.reindex[sid]; ok </span><span class="cov8" title="1">{
                pid = v
        }</span> else<span class="cov8" title="1"> {
                pid = packet.ID(sid)
        }</span>
        <span class="cov8" title="1">if _, ok := p.index[pid]; !ok </span><span class="cov8" title="1">{
                pid = 0
        }</span>
        <span class="cov8" title="1">return</span>
}

// Size returns the size of index
func (p *PacketIDS) Size() (i int) <span class="cov8" title="1">{
        p.Lock()
        i = len(p.index)
        p.Unlock()
        return
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package common

import (
        "time"
)

// Subscribe MQTT subscribe
type Subscribe struct {
        sequenceID  uint64
        acknowledge *Acknowledge
}

// NewSubscribe creates a subscribe
func NewSubscribe() *Subscribe <span class="cov0" title="0">{
        return &amp;Subscribe{
                sequenceID:  uint64(time.Now().UnixNano()),
                acknowledge: NewAcknowledge(),
        }
}</span>

// Ack acknowledge
func (s *Subscribe) Ack() <span class="cov0" title="0">{
        s.acknowledge.Ack()
}</span>

// SID sequence id
func (s *Subscribe) SID() uint64 <span class="cov0" title="0">{
        return s.sequenceID
}</span>

// WaitTimeout waits until acknowledged, cancelled or timeout
func (s *Subscribe) WaitTimeout(timeout time.Duration, cancel &lt;-chan struct{}) bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-cancel:<span class="cov0" title="0">
                return false</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return false</span>
        case &lt;-s.acknowledge.done:<span class="cov0" title="0">
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package common

import (
        "strings"
)

type subject interface {
        getValue() string
}

// normalSubject
type normalSubject struct {
        value string
}

// singleWildcardSubject
type singleWildcardSubject struct {
        value string
}

// multipleWildcardSubject
type multipleWildcardSubject struct {
        value string
}

func (n normalSubject) getValue() string <span class="cov8" title="1">{
        return n.value
}</span>

func (s singleWildcardSubject) getValue() string <span class="cov8" title="1">{
        return s.value
}</span>

func (m multipleWildcardSubject) getValue() string <span class="cov8" title="1">{
        return m.value
}</span>

// getTopicSubjects convert topic to []subject by subject kind
func getTopicSubjects(topic string) []subject <span class="cov8" title="1">{
        var subjectList []subject
        var topicList = strings.Split(topic, "/")
        for _, value := range topicList </span><span class="cov8" title="1">{
                switch value </span>{
                case SingleWildCard:<span class="cov8" title="1">
                        subjectList = append(subjectList, interface{}(singleWildcardSubject{value}).(subject))</span>
                case MultipleWildCard:<span class="cov8" title="1">
                        subjectList = append(subjectList, interface{}(multipleWildcardSubject{value}).(subject))</span>
                default:<span class="cov8" title="1">
                        subjectList = append(subjectList, interface{}(normalSubject{value}).(subject))</span>
                }
        }
        <span class="cov8" title="1">return subjectList</span>
}

// TopicIsMatch check the given topicRule is matched the given topic or not
func TopicIsMatch(topic string, topicRule string) bool <span class="cov8" title="1">{
        topicSubjects := getTopicSubjects(topic)
        topicRuleSubjects := getTopicSubjects(topicRule)
        topicSubjectsLength := len(topicSubjects)
        topicRuleSubjectsLength := len(topicRuleSubjects)
        var minLength int
        if topicSubjectsLength &lt; topicRuleSubjectsLength </span><span class="cov8" title="1">{
                minLength = topicSubjectsLength
        }</span> else<span class="cov8" title="1"> {
                minLength = topicRuleSubjectsLength
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; minLength; i++ </span><span class="cov8" title="1">{
                topicSubject := topicSubjects[i]
                topicRuleSubject := topicRuleSubjects[i]
                if strings.Compare(topicRuleSubject.getValue(), MultipleWildCard) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if strings.Compare(topicRuleSubject.getValue(), SingleWildCard) != 0 &amp;&amp;
                        strings.Compare(topicRuleSubject.getValue(), topicSubject.getValue()) != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">if topicSubjectsLength &gt; minLength </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if topicRuleSubjectsLength &gt; minLength &amp;&amp;
                strings.Compare(topicRuleSubjects[minLength].getValue(), MultipleWildCard) != 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// ContainsWildcard check topic contains wildCard("#" or "+") or not
func ContainsWildcard(topic string) bool <span class="cov8" title="1">{
        return strings.Contains(topic, SingleWildCard) || strings.Contains(topic, MultipleWildCard)
}</span>

// isSysTopic check topic is SysTopic or not
func isSysTopic(topic string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(topic, SysCmdPrefix)
}</span>

// PubTopicValidate validate MQTT publish topic
func PubTopicValidate(topic string) bool <span class="cov8" title="1">{
        if topic == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(topic) &gt; MaxTopicNameLen || strings.Contains(topic, "\u0000") ||
                strings.Count(topic, TopicSeparator) &gt; MaxSlashCount </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if ContainsWildcard(topic) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if isSysTopic(topic) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// SubTopicValidate validate MQTT subscribe topic
func SubTopicValidate(topic string) bool <span class="cov8" title="1">{
        if topic == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(topic) &gt; MaxTopicNameLen || strings.Contains(topic, "\u0000") ||
                strings.Count(topic, TopicSeparator) &gt; MaxSlashCount </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if isSysTopic(topic) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">splited := strings.Split(topic, TopicSeparator)
        for index := 0; index &lt; len(splited); index++ </span><span class="cov8" title="1">{
                s := splited[index]
                if strings.EqualFold(s, MultipleWildCard) </span><span class="cov8" title="1">{
                        // check that multi is the last symbol
                        if index != len(splited)-1 </span><span class="cov8" title="1">{
                                return false
                        }</span>
                } else<span class="cov8" title="1"> if strings.Contains(s, MultipleWildCard) </span><span class="cov8" title="1">{
                        return false
                }</span> else<span class="cov8" title="1"> if !strings.EqualFold(s, SingleWildCard) &amp;&amp;
                        strings.Contains(s, SingleWildCard) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package config

import (
        "time"

        "github.com/baetyl/baetyl/utils"
        validator "gopkg.in/validator.v2"
)

func init() <span class="cov8" title="1">{
        validator.SetValidationFunc("principals", principalsValidate)
        validator.SetValidationFunc("subscriptions", subscriptionsValidate)
}</span>

// Config all config of edge
type Config struct {
        Listen      []string          `yaml:"listen" json:"listen"`
        Certificate utils.Certificate `yaml:"certificate" json:"certificate"`

        Principals    []Principal    `yaml:"principals" json:"principals" validate:"principals"`
        Subscriptions []Subscription `yaml:"subscriptions" json:"subscriptions" validate:"subscriptions"`

        Message Message `yaml:"message" json:"message"`
        Storage struct {
                Dir string `yaml:"dir" json:"dir" default:"var/db/baetyl/data"`
        } `yaml:"storage" json:"storage"`
        Shutdown struct {
                Timeout time.Duration `yaml:"timeout" json:"timeout" default:"10m"`
        } `yaml:"shutdown" json:"shutdown"`
        Metrics struct {
                Report struct {
                        Interval time.Duration `yaml:"interval" json:"interval" default:"1m"`
                } `yaml:"report" json:"report"`
        } `yaml:"metrics" json:"metrics"`
}

// New config
func New(in []byte) (*Config, error) <span class="cov8" title="1">{
        c := &amp;Config{}
        err := utils.UnmarshalYAML(in, c)
        return c, err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import (
        "fmt"

        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/utils"
        "github.com/deckarep/golang-set"
)

// principalsValidate validate principals config is valid or not
func principalsValidate(v interface{}, param string) error <span class="cov8" title="1">{
        principals := v.([]Principal)
        err := userValidate(principals)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for _, principal := range principals </span><span class="cov8" title="1">{
                for _, permission := range principal.Permissions </span><span class="cov8" title="1">{
                        for _, permit := range permission.Permits </span><span class="cov8" title="1">{
                                if !common.SubTopicValidate(permit) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s topic(%s) invalid", permission.Action, permit)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// userValidate validate username duplicate or not
func userValidate(principals []Principal) error <span class="cov8" title="1">{
        userMap := make(map[string]struct{})
        for _, principal := range principals </span><span class="cov8" title="1">{
                if _, ok := userMap[principal.Username]; ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("username (%s) duplicate", principal.Username)
                }</span>
                <span class="cov8" title="1">userMap[principal.Username] = struct{}{}</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// subscriptionsValidate check the subscriptions config is valid or not
func subscriptionsValidate(v interface{}, param string) error <span class="cov8" title="1">{
        subscriptions := v.([]Subscription)
        for _, s := range subscriptions </span><span class="cov8" title="1">{
                if !common.SubTopicValidate(s.Source.Topic) </span><span class="cov8" title="1">{
                        return fmt.Errorf("[%+v] source topic invalid", s.Source)
                }</span>
                <span class="cov8" title="1">if !common.PubTopicValidate(s.Target.Topic) </span><span class="cov8" title="1">{
                        return fmt.Errorf("[%+v] target topic invalid", s.Target)
                }</span>
        }
        // duplicate source and target config validate
        <span class="cov8" title="1">_, edges := getVertexEdges(subscriptions)
        if dupSubscriptionValidate(edges) </span><span class="cov8" title="1">{
                return fmt.Errorf("duplicate source and target config")
        }</span>
        // cycle found in source and target config
        <span class="cov8" title="1">return cycleFound(edges)</span>
}

// cycleFound is used for finding cycle
func cycleFound(edges [][2]string) error <span class="cov8" title="1">{
        normalEdges, wildcardEdges := classifyEdges(edges)
        // normal source &amp;&amp; target config cycle detect
        if !canFinish(normalEdges) </span><span class="cov8" title="1">{
                return fmt.Errorf("found cycle in source and target config")
        }</span>
        // wildcard source &amp;&amp; target config cycle detect
        <span class="cov8" title="1">targetVertexs := getTargetVertexs(edges)
        for _, e := range wildcardEdges </span><span class="cov8" title="1">{
                for _, v := range targetVertexs </span><span class="cov8" title="1">{
                        if common.TopicIsMatch(v, e[0]) </span><span class="cov8" title="1">{
                                e[0] = v
                                normalEdges = append(normalEdges, e)
                                if !canFinish(normalEdges) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("found cycle in source and target config")
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// canFinish detect a directed graph has cycle or not
// vertexs store graph vertex info, edges store graph edge info
func canFinish(edges [][2]string) bool <span class="cov8" title="1">{
        if len(edges[0]) == 0 || len(edges) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">vertexs := edges2Vertexs(edges)
        graph := make(map[string][]string)
        for i := range edges </span><span class="cov8" title="1">{
                graph[edges[i][1]] = append(graph[edges[i][1]], edges[i][0])
        }</span>
        <span class="cov8" title="1">path := make([]bool, len(vertexs))
        visited := make([]bool, len(vertexs))
        for i := range vertexs </span><span class="cov8" title="1">{
                if visited[i] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if hasCycle(vertexs, vertexs[i], graph, path, visited) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// hasCycle check the directed graph has cycle or not
// graph store some vertex which is associated with the given vertex
// visited represents an vertex visit-status, if true, visited; else none visited
func hasCycle(vertexs []string, start string, graph map[string][]string, path []bool, visited []bool) bool <span class="cov8" title="1">{
        for i := range graph[start] </span><span class="cov8" title="1">{
                if visited[getPosition(graph[start][i], vertexs)] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if path[getPosition(graph[start][i], vertexs)] </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">path[getPosition(graph[start][i], vertexs)] = true
                if hasCycle(vertexs, graph[start][i], graph, path, visited) </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">path[getPosition(graph[start][i], vertexs)] = false</span>
        }
        <span class="cov8" title="1">visited[getPosition(start, vertexs)] = true
        return false</span>
}

// getPosition return the given data's index of the given vertexs
func getPosition(data string, vertexs []string) int <span class="cov8" title="1">{
        for pos := 0; pos &lt; len(vertexs); pos++ </span><span class="cov8" title="1">{
                if vertexs[pos] == data </span><span class="cov8" title="1">{
                        return pos
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// getVertexEdges generate vertexs &amp;&amp; edges
func getVertexEdges(subscriptions []Subscription) ([]string, [][2]string) <span class="cov8" title="1">{
        vertexs := make(map[string]struct{})
        edges := make([][2]string, 0)
        for _, s := range subscriptions </span><span class="cov8" title="1">{
                st := s.Source.Topic
                tt := s.Target.Topic
                vertexs[st] = struct{}{}
                vertexs[tt] = struct{}{}
                edges = append(edges, [2]string{st, tt})
        }</span>
        <span class="cov8" title="1">return utils.GetKeys(vertexs), edges</span>
}

// classifyEdges generate normalEges &amp;&amp; wildcardEdges
func classifyEdges(edges [][2]string) ([][2]string, [][2]string) <span class="cov8" title="1">{
        normalEdges := make([][2]string, 0)
        wildcardEdges := make([][2]string, 0)
        for _, e := range edges </span><span class="cov8" title="1">{
                if common.ContainsWildcard(e[0]) </span><span class="cov8" title="1">{
                        wildcardEdges = append(wildcardEdges, e)
                }</span> else<span class="cov8" title="1"> {
                        normalEdges = append(normalEdges, e)
                }</span>
        }
        <span class="cov8" title="1">return normalEdges, wildcardEdges</span>
}

// edges2Vertexs generate vertexs from given edges
func edges2Vertexs(edges [][2]string) []string <span class="cov8" title="1">{
        vertexs := make(map[string]struct{})
        for _, e := range edges </span><span class="cov8" title="1">{
                vertexs[e[0]] = struct{}{}
                vertexs[e[1]] = struct{}{}
        }</span>
        <span class="cov8" title="1">return utils.GetKeys(vertexs)</span>
}

// getTargetVertexs generate target vertexs from given edges
func getTargetVertexs(edges [][2]string) []string <span class="cov8" title="1">{
        vertexs := make(map[string]struct{})
        for _, e := range edges </span><span class="cov8" title="1">{
                vertexs[e[1]] = struct{}{}
        }</span>
        <span class="cov8" title="1">return utils.GetKeys(vertexs)</span>
}

// dupSubscriptionValidate check subscription config has duplicate config or not
func dupSubscriptionValidate(edges [][2]string) bool <span class="cov8" title="1">{
        _edges := mapset.NewSet()
        for _, element := range edges </span><span class="cov8" title="1">{
                _edges.Add(element)
        }</span>
        <span class="cov8" title="1">if _edges.Cardinality() != len(edges) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package persist

import (
        "time"

        "github.com/baetyl/baetyl/baetyl-hub/utils"
        bolt "github.com/etcd-io/bbolt"
)

// BoltDB use boltdb to persist data
type BoltDB struct {
        *bolt.DB
        bucket []byte
}

// NewBoltDB creates a bolt database
func NewBoltDB(path string) (*BoltDB, error) <span class="cov8" title="1">{
        db, err := bolt.Open(path, 0600, &amp;bolt.Options{Timeout: time.Second})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;BoltDB{DB: db, bucket: []byte(".self")}, nil</span>
}

// Sequence returns the sequence id
func (p *BoltDB) Sequence() (sid uint64, err error) <span class="cov0" title="0">{
        err = p.View(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket(p.bucket)
                if b != nil </span><span class="cov0" title="0">{
                        sid = b.Sequence()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

// Put puts a KV
func (p *BoltDB) Put(key, value []byte) error <span class="cov0" title="0">{
        return p.BucketPut(p.bucket, key, value)
}</span>

// Get gets a KV by key
func (p *BoltDB) Get(key []byte) (value []byte, err error) <span class="cov0" title="0">{
        return p.BucketGet(p.bucket, key)
}</span>

// Fetch fetches a KV by offset
func (p *BoltDB) Fetch(offset []byte) (key, value []byte, err error) <span class="cov0" title="0">{
        err = p.View(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket(p.bucket)
                if b == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">ik, iv := b.Cursor().Seek(offset)
                if len(ik) == 0 || len(iv) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">key = make([]byte, len(ik))
                value = make([]byte, len(iv))
                copy(key, ik)   // copy
                copy(value, iv) // copy
                return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

// Delete deletes a KV
func (p *BoltDB) Delete(key []byte) error <span class="cov0" title="0">{
        return p.BucketDelete(p.bucket, key)
}</span>

// Clean cleans all KVs before timestamp
func (p *BoltDB) Clean(timestamp uint64) (count uint64, err error) <span class="cov0" title="0">{
        err = p.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket(p.bucket)
                if b == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">c := b.Cursor()
                for k, _ := c.First(); k != nil &amp;&amp; utils.U64(k[8:]) &lt; timestamp; k, _ = c.Next() </span><span class="cov0" title="0">{
                        err = b.Delete(k)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">count++</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

// BatchPut puts KVs in batch mode
func (p *BoltDB) BatchPut(kvs []*KV) error <span class="cov0" title="0">{
        return p.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b, err := tx.CreateBucketIfNotExists(p.bucket)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, kv := range kvs </span><span class="cov0" title="0">{
                        err = b.Put(kv.Key, kv.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}

// BatchPutV puts values in batch mode
func (p *BoltDB) BatchPutV(vs [][]byte) error <span class="cov8" title="1">{
        return p.Update(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                b, err := tx.CreateBucketIfNotExists(p.bucket)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // key = sid + ts (16 bytes)
                <span class="cov8" title="1">ts := uint64(time.Now().Unix())
                for _, v := range vs </span><span class="cov8" title="1">{
                        sid, err := b.NextSequence()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = b.Put(utils.U64U64ToB(sid, ts), v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

// BucketPut puts a KV into bucket
func (p *BoltDB) BucketPut(bucket, key, value []byte) error <span class="cov0" title="0">{
        return p.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b, err := tx.CreateBucketIfNotExists(bucket)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return b.Put(key, value)</span>
        })
}

// BucketGet gets a KV from bucket by key
func (p *BoltDB) BucketGet(bucket, key []byte) (value []byte, err error) <span class="cov0" title="0">{
        err = p.View(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket(bucket)
                if b == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">iv := b.Get(key)
                if len(iv) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">value = make([]byte, len(iv))
                copy(value, iv) // copy
                return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

// BatchFetch fetches KVs by offset in batch mode
func (p *BoltDB) BatchFetch(offset []byte, size int) ([]*KV, error) <span class="cov8" title="1">{
        res := make([]*KV, 0)
        err := p.View(func(tx *bolt.Tx) error </span><span class="cov8" title="1">{
                b := tx.Bucket(p.bucket)
                if b == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">i := int(0)
                c := b.Cursor()
                for ik, iv := c.Seek(offset); i &lt; size &amp;&amp; len(ik) != 0 &amp;&amp; len(iv) != 0; ik, iv = c.Next() </span><span class="cov8" title="1">{
                        key := make([]byte, len(ik))
                        value := make([]byte, len(iv))
                        copy(key, ik)   // copy
                        copy(value, iv) // copy
                        res = append(res, &amp;KV{Key: key, Value: value})
                        i++
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return res, err</span>
}

// BucketDelete deletes a KV in bucket by key
func (p *BoltDB) BucketDelete(bucket, key []byte) error <span class="cov0" title="0">{
        return p.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket(bucket)
                if b == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return b.Delete(key)</span>
        })
}

// BucketList lists all KVs in bucket
func (p *BoltDB) BucketList(bucket []byte) (map[string][]byte, error) <span class="cov0" title="0">{
        res := make(map[string][]byte)
        err := p.View(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket(bucket)
                if b == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return b.ForEach(func(ik, iv []byte) error </span><span class="cov0" title="0">{
                        v := make([]byte, len(iv))
                        copy(v, iv) // copy
                        res[string(ik)] = v
                        return nil
                }</span>)
        })
        <span class="cov0" title="0">return res, err</span>
}

// Close closes database
func (p *BoltDB) Close() <span class="cov0" title="0">{
        p.DB.Close()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package persist

import (
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

// KV key-value pair
type KV struct {
        Key   []byte
        Value []byte
}

// Database persistence interfaces
type Database interface {
        Sequence() (uint64, error)
        // Put(key, value []byte) error
        Get(key []byte) ([]byte, error)
        // Fetch(offset []byte) ([]byte, []byte, error)
        Delete(key []byte) error
        Clean(timestamp uint64) (uint64, error)
        Close()

        BatchPut(kvs []*KV) error
        BatchPutV(vs [][]byte) error
        BatchFetch(offset []byte, size int) ([]*KV, error)

        BucketPut(bucket, key, value []byte) error
        BucketGet(bucket, key []byte) ([]byte, error)
        BucketList(bucket []byte) (map[string][]byte, error)
        BucketDelete(bucket, key []byte) error
}

// Factory persistence factory
type Factory struct {
        dir string
        dbs map[string]Database
        sync.Mutex
}

// NewFactory creates a persistence factory
func NewFactory(dir string) (*Factory, error) <span class="cov0" title="0">{
        err := os.MkdirAll(dir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make dir (%s): %s", dir, err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;Factory{dir: dir, dbs: make(map[string]Database)}, nil</span>
}

// NewDB creates a persistence database
func (f *Factory) NewDB(name string) (Database, error) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("name (%s) invalid", name)
        }</span>
        <span class="cov0" title="0">f.Lock()
        defer f.Unlock()
        if db, ok := f.dbs[name]; ok </span><span class="cov0" title="0">{
                return db, nil
        }</span>
        <span class="cov0" title="0">db, err := NewBoltDB(filepath.Join(f.dir, name))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">f.dbs[name] = db
        return db, nil</span>
}

// Close close factory to release all databases
func (f *Factory) Close() <span class="cov0" title="0">{
        f.Lock()
        defer f.Unlock()
        for _, db := range f.dbs </span><span class="cov0" title="0">{
                db.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package router

import "container/list"

type deque struct {
        elements *list.List
}

func newDeque() *deque <span class="cov8" title="1">{
        return &amp;deque{elements: list.New()}
}</span>

// Push add an element in the last
func (d *deque) Push(v interface{}) <span class="cov8" title="1">{
        d.elements.PushBack(v)
}</span>

// Pop remove the last element and return it's value
func (d *deque) Pop() interface{} <span class="cov8" title="1">{
        e := d.elements.Back()
        if e != nil </span><span class="cov8" title="1">{
                d.elements.Remove(e)
                return e.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Peek return the value of the last element
func (d *deque) Peek() interface{} <span class="cov8" title="1">{
        e := d.elements.Back()
        if e != nil </span><span class="cov8" title="1">{
                return e.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Offer add an element in the last
func (d *deque) Offer(v interface{}) <span class="cov8" title="1">{
        d.elements.PushBack(v)
}</span>

// Poll remove the first element and return it's value
func (d *deque) Poll() interface{} <span class="cov8" title="1">{
        e := d.elements.Front()
        if e != nil </span><span class="cov8" title="1">{
                d.elements.Remove(e)
                return e.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Len return the deque's length
func (d *deque) Len() int <span class="cov8" title="1">{
        return d.elements.Len()
}</span>

// Empty validate the deque is empty or not
func (d *deque) Empty() bool <span class="cov8" title="1">{
        return d.elements.Len() == 0
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package router

import "github.com/baetyl/baetyl/baetyl-hub/common"

// SinkSub subscription of sink
type SinkSub interface {
        ID() string // client id for session
        QOS() uint32
        Topic() string
        TargetQOS() uint32
        TargetTopic() string
        Flow(common.Message)
}

// NopSinkSub subscription of sink which does nothing
type NopSinkSub struct {
        id     string
        qos    uint32
        topic  string
        tqos   uint32
        ttopic string
}

// NewNopSinkSub creates a new subscription of sink which does nothing
func NewNopSinkSub(id string, qos uint32, topic string, tqos uint32, ttopic string) *NopSinkSub <span class="cov8" title="1">{
        return &amp;NopSinkSub{id: id, qos: qos, topic: topic, tqos: tqos, ttopic: ttopic}
}</span>

// ID returns the id of subscription
func (s *NopSinkSub) ID() string <span class="cov8" title="1">{
        return s.id
}</span>

// QOS returns the qos of subscription
func (s *NopSinkSub) QOS() uint32 <span class="cov8" title="1">{
        return s.qos
}</span>

// Topic returns the topic of subscribed topic
func (s *NopSinkSub) Topic() string <span class="cov8" title="1">{
        return s.topic
}</span>

// TargetQOS returns the publish qos
func (s *NopSinkSub) TargetQOS() uint32 <span class="cov8" title="1">{
        return s.tqos
}</span>

// TargetTopic returns the publish topic
func (s *NopSinkSub) TargetTopic() string <span class="cov8" title="1">{
        return s.ttopic
}</span>

// Flow flows message to channel
func (s *NopSinkSub) Flow(common.Message) {<span class="cov0" title="0">
}</span>

type node struct {
        children map[string]*node
        sinksubs map[string]SinkSub
}

func newNode() *node <span class="cov8" title="1">{
        return &amp;node{
                children: make(map[string]*node),
                sinksubs: make(map[string]SinkSub),
        }
}</span>

func (n *node) isEmpty() bool <span class="cov8" title="1">{
        return len(n.children) == 0 &amp;&amp; len(n.sinksubs) == 0
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package router

import (
        "strings"
        "sync"

        "github.com/baetyl/baetyl/baetyl-hub/common"
)

// Trie topic tree of *common.SinkSubs
type Trie struct {
        root *node
        sync.RWMutex
}

// NewTrie creates a trie
func NewTrie() *Trie <span class="cov8" title="1">{
        return &amp;Trie{
                root: newNode(),
        }
}</span>

// Add adds subscription to trie
// #+/
func (t *Trie) Add(sub SinkSub) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()

        current := t.root
        nodes := strings.Split(sub.Topic(), "/")
        for _, n := range nodes </span><span class="cov8" title="1">{
                if _, ok := current.children[n]; !ok </span><span class="cov8" title="1">{
                        current.children[n] = newNode()
                }</span>
                <span class="cov8" title="1">current = current.children[n]</span>
        }
        <span class="cov8" title="1">current.sinksubs[sub.ID()] = sub</span>
}

// Remove removes subscription to trie
// #+/
func (t *Trie) Remove(id, topic string) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()

        stack := newDeque()
        stack.Push(t.root)
        nodes := strings.Split(topic, "/")
        for _, n := range nodes </span><span class="cov8" title="1">{
                current := stack.Peek().(*node).children[n]
                if current == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">stack.Push(current)</span>
        }

        <span class="cov8" title="1">t.doRemove(stack, nodes, id)</span>
}

// RemoveAll removes all subscriptions by id
func (t *Trie) RemoveAll(id string) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()

        // TODO: remove all subscriptions by id and add unit test @wangmengtao
        var n *node
        queue := make([]*node, 0)
        queue = append(queue, t.root)
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                n = queue[0]
                delete(n.sinksubs, id)
                for _, c := range n.children </span><span class="cov8" title="1">{
                        queue = append(queue, c)
                }</span>
                <span class="cov8" title="1">queue = queue[1:]</span>
        }
}

func (t *Trie) doRemove(stack *deque, nodes []string, uid string) <span class="cov8" title="1">{
        pos := len(nodes)
        delete(stack.Peek().(*node).sinksubs, uid)

        // Remove empty path in the trie
        for index := pos - 1; index &gt;= 0; index-- </span><span class="cov8" title="1">{
                if stack.Peek().(*node).isEmpty() &amp;&amp; stack.Pop() != t.root </span><span class="cov8" title="1">{
                        delete(stack.Peek().(*node).children, nodes[index])
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// IsMatch IsMatch
// TODO: improve
func (t *Trie) IsMatch(topic string) (bool, uint32) <span class="cov0" title="0">{
        ss := t.Match(topic)
        ok := len(ss) != 0
        qos := uint32(0)
        for _, s := range ss </span><span class="cov0" title="0">{
                if s.QOS() &gt; qos </span><span class="cov0" title="0">{
                        qos = s.QOS()
                }</span>
        }
        <span class="cov0" title="0">return ok, qos</span>
}

// MatchUnique matches subscriptions merged by id
// TODO: improve
func (t *Trie) MatchUnique(topic string) map[string]SinkSub <span class="cov8" title="1">{
        matches := t.Match(topic)
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        // TODO: move dup check logic into Trie.Match
        <span class="cov8" title="1">var ok bool
        var sub, dup SinkSub
        subs := make(map[string]SinkSub)
        for _, sub = range matches </span><span class="cov8" title="1">{
                dup, ok = subs[sub.ID()]
                if !ok </span><span class="cov8" title="1">{
                        subs[sub.ID()] = sub
                }</span> else<span class="cov8" title="1"> if sub.QOS() &gt; dup.QOS() </span><span class="cov8" title="1">{
                        // pick sub with big source qos
                        subs[sub.ID()] = sub
                }</span> else<span class="cov8" title="1"> if sub.QOS() == dup.QOS() &amp;&amp; sub.TargetQOS() &gt; dup.TargetQOS() </span><span class="cov8" title="1">{
                        // pick sub with big target qos if source qos equals
                        subs[sub.ID()] = sub
                }</span>
        }
        <span class="cov8" title="1">return subs</span>
}

// Match Matches topic
func (t *Trie) Match(topic string) []SinkSub <span class="cov8" title="1">{
        t.RLock()
        defer t.RUnlock()

        matched := make([]SinkSub, 0)
        nodes := strings.Split(topic, "/")

        matchedNodes := t.doMatch(nodes)
        for _, node := range matchedNodes </span><span class="cov8" title="1">{
                for _, v := range node.sinksubs </span><span class="cov8" title="1">{
                        matched = append(matched, v)
                }</span>
        }

        <span class="cov8" title="1">return matched</span>
}

func (t *Trie) doMatch(subjects []string) []*node <span class="cov8" title="1">{
        nodeQueue := newDeque()
        var matchedNodes []*node
        flag := false

        // Use breadth-first-search to get all matched node
        nodeQueue.Offer(t.root)
        for _, subject := range subjects </span><span class="cov8" title="1">{
                if !flag </span><span class="cov8" title="1">{
                        amount := nodeQueue.Len()
                        for index := amount; index &gt; 0; index-- </span><span class="cov8" title="1">{
                                nodeQueue.Poll().(*node).attachMultipleMatch(&amp;matchedNodes).attachSingleMatch(nodeQueue, subject)
                        }</span>
                        <span class="cov8" title="1">if nodeQueue.Empty() </span><span class="cov8" title="1">{
                                flag = true
                        }</span>
                }
        }

        // Add the "#" match with zero level, such as "a/#" matching "a"
        <span class="cov8" title="1">for !nodeQueue.Empty() </span><span class="cov8" title="1">{
                matchedNodes = append(matchedNodes, nodeQueue.Poll().(*node).attachMultipleMatch(&amp;matchedNodes))
        }</span>

        <span class="cov8" title="1">return matchedNodes</span>
}

func (n *node) attachMultipleMatch(nodes *[]*node) *node <span class="cov8" title="1">{
        node := n.children[common.MultipleWildCard]
        if node != nil </span><span class="cov8" title="1">{
                *nodes = append(*nodes, node)
        }</span>

        <span class="cov8" title="1">return n</span>
}

func (n *node) attachSingleMatch(nodeQueue *deque, subject string) *node <span class="cov8" title="1">{
        if strings.EqualFold(subject, common.MultipleWildCard) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">node := n.children[subject]
        if node != nil </span><span class="cov8" title="1">{
                nodeQueue.Offer(node)
        }</span>

        <span class="cov8" title="1">node = n.children[common.SingleWildCard]
        if node != nil </span><span class="cov8" title="1">{
                nodeQueue.Offer(node)
        }</span>

        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package rule

import (
        "fmt"
        "sync/atomic"
        "time"

        "github.com/baetyl/baetyl/logger"

        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/config"
        "github.com/baetyl/baetyl/baetyl-hub/router"
        "github.com/baetyl/baetyl/baetyl-hub/utils"
        cmap "github.com/orcaman/concurrent-map"
)

const (
        initial = int32(0)
        started = int32(1)
        closed  = int32(2)
)

var errRuleManagerClosed = fmt.Errorf("rule manager already closed")

// Report reports stats
type report func(map[string]interface{}) error

// Manager manages all rules of message routing
type Manager struct {
        status int32
        broker broker
        report report
        trieq0 *router.Trie
        rules  cmap.ConcurrentMap
        tomb   utils.Tomb
        log    logger.Logger
}

// NewManager creates a new rule manager
func NewManager(c []config.Subscription, b broker, r report) (*Manager, error) <span class="cov8" title="1">{
        m := &amp;Manager{
                broker: b,
                report: r,
                rules:  cmap.New(),
                trieq0: router.NewTrie(),
                log:    logger.WithField("manager", "rule"),
        }
        m.rules.Set(common.RuleMsgQ0, newRuleQos0(m.broker, m.trieq0))
        m.rules.Set(common.RuleTopic, newRuleTopic(m.broker, m.trieq0))
        for _, sub := range c </span><span class="cov8" title="1">{
                err := m.AddSinkSub(common.RuleTopic, sub.Target.Topic, uint32(sub.Source.QOS), sub.Source.Topic, uint32(sub.Target.QOS), sub.Target.Topic)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add subscription (%v): %s", sub.Source, err.Error())
                }</span>
        }
        <span class="cov8" title="1">if r != nil </span><span class="cov0" title="0">{
                return m, m.tomb.Gos(m.reporting)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// Start starts all rules
func (m *Manager) Start() <span class="cov8" title="1">{
        if !atomic.CompareAndSwapInt32(&amp;m.status, initial, started) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for item := range m.rules.IterBuffered() </span><span class="cov8" title="1">{
                r := item.Val.(base)
                // r.log.Info("To start rule")
                if err := r.start(); err != nil </span><span class="cov0" title="0">{
                        m.log.WithError(err).Infof("failed to start rule (%s)", r.uid())
                }</span>
        }
}

// Close closes this manager
func (m *Manager) Close() <span class="cov8" title="1">{
        if !atomic.CompareAndSwapInt32(&amp;m.status, started, closed) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m.log.Infof("rule manager closing")
        defer m.log.Infof("rule manager closed, remaining offsets: %d", m.broker.OffsetChanLen())
        m.tomb.Kill()
        defer m.tomb.Wait()
        for item := range m.rules.IterBuffered() </span><span class="cov8" title="1">{
                r := item.Val.(base)
                // r.log.Info("To stop rule")
                r.stop()
        }</span>
        // Wait all sinked messages are handled
        // TODO: how to handle the case of session closed by client during waiting
        <span class="cov8" title="1">for item := range m.rules.IterBuffered() </span><span class="cov8" title="1">{
                r := item.Val.(base)
                r.wait(false)
        }</span>
        // wait all offsets persisted
        <span class="cov8" title="1">m.broker.WaitOffsetPersisted()</span>
}

// AddRuleSess adds a new rule for session during running
func (m *Manager) AddRuleSess(id string, persistent bool, publish, republish common.Publish) error <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;m.status) == closed </span><span class="cov0" title="0">{
                return errRuleManagerClosed
        }</span>
        <span class="cov8" title="1">if _, ok := m.rules.Get(id); ok </span><span class="cov0" title="0">{
                return fmt.Errorf("rule (%s) exists", id)
        }</span>
        <span class="cov8" title="1">m.rules.Set(id, newRuleSess(id, persistent, m.broker, m.trieq0, publish, republish))
        return nil</span>
}

// StartRule starts a rule
func (m *Manager) StartRule(id string) error <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;m.status) == closed </span><span class="cov0" title="0">{
                return errRuleManagerClosed
        }</span> else<span class="cov8" title="1"> if atomic.LoadInt32(&amp;m.status) == initial </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">item, ok := m.rules.Get(id)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("rule (%s) not found", id)
        }</span>
        <span class="cov8" title="1">r := item.(base)
        // r.log.Info("To start rule")
        return r.start()</span>
}

// RemoveRule removes a sink for session
func (m *Manager) RemoveRule(id string) error <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;m.status) == closed </span><span class="cov0" title="0">{
                return errRuleManagerClosed
        }</span>
        <span class="cov8" title="1">if item, ok := m.rules.Get(id); ok </span><span class="cov8" title="1">{
                m.rules.Remove(id)
                r := item.(base)
                // r.log.Info("To stop rule")
                r.stop()
                r.wait(true)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddSinkSub adds a sink subscription
func (m *Manager) AddSinkSub(ruleid, subid string, subqos uint32, subtopic string, pubqos uint32, pubtopic string) error <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;m.status) == closed </span><span class="cov0" title="0">{
                return errRuleManagerClosed
        }</span>
        <span class="cov8" title="1">item, ok := m.rules.Get(ruleid)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("rule (%s) not found", ruleid)
        }</span>
        <span class="cov8" title="1">r := item.(base)
        r.register(newSinkSub(subid, subqos, subtopic, pubqos, pubtopic, r.channel()))
        return nil</span>
}

// RemoveSinkSub removes a sink subscription
func (m *Manager) RemoveSinkSub(id, topic string) error <span class="cov0" title="0">{
        if atomic.LoadInt32(&amp;m.status) == closed </span><span class="cov0" title="0">{
                return errRuleManagerClosed
        }</span>
        <span class="cov0" title="0">item, ok := m.rules.Get(id)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("rule (%s) not found", id)
        }</span>
        <span class="cov0" title="0">item.(base).remove(id, topic)
        return nil</span>
}

func (m *Manager) reporting() error <span class="cov0" title="0">{
        defer m.log.Debugf("status logging task stopped")

        var err error
        t := time.NewTicker(m.broker.Config().Metrics.Report.Interval)
        defer t.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-m.tomb.Dying():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        ruleStats := map[string]interface{}{}
                        for item := range m.rules.IterBuffered() </span><span class="cov0" title="0">{
                                r := item.Val.(base)
                                ruleStats[r.uid()] = r.info()
                        }</span>
                        <span class="cov0" title="0">stats := map[string]interface{}{
                                "rule_count": len(ruleStats),
                                "rule_stats": ruleStats,
                        }
                        err = m.report(stats)
                        if err != nil </span><span class="cov0" title="0">{
                                m.log.Warnf("failed to report rule stats")
                        }</span>
                        <span class="cov0" title="0">m.log.Debugln(stats)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package rule

import (
        "fmt"
        "time"

        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/utils"
        "github.com/baetyl/baetyl/logger"
        "github.com/jpillora/backoff"
)

var errMsgChanClosed = fmt.Errorf("message channel is closed")
var errMsgDiscarded = fmt.Errorf("message is discarded since channel is full")

// Q0: it means the message with QOS=0 published by clients or functions
// Q1: it means the message with QOS=1 published by clients or functions

// msgchan message channel routed from sink
type msgchan struct {
        msgq0            chan *common.Message
        msgq1            chan *common.Message
        msgack           chan *common.MsgAck // TODO: move to sink?
        persist          func(uint64)
        msgtomb          utils.Tomb
        acktomb          utils.Tomb
        quitTimeout      time.Duration
        publish          common.Publish
        republish        common.Publish
        republishBackoff *backoff.Backoff
        log              logger.Logger
}

// newMsgChan creates a new message channel
func newMsgChan(l0, l1 int, publish, republish common.Publish, republishTimeout time.Duration, quitTimeout time.Duration, persist func(uint64), log logger.Logger) *msgchan <span class="cov8" title="1">{
        backoff := &amp;backoff.Backoff{
                Min:    time.Millisecond * 100,
                Max:    republishTimeout,
                Factor: 2,
        }
        return &amp;msgchan{
                msgq0:            make(chan *common.Message, l0),
                msgq1:            make(chan *common.Message, l1),
                msgack:           make(chan *common.MsgAck, l1),
                publish:          publish,
                republish:        republish,
                republishBackoff: backoff,
                quitTimeout:      quitTimeout,
                persist:          persist,
                log:              log,
        }
}</span>

// MsgQ0ChanLen returns length of channel of message published with qos=0
func (c *msgchan) msgq0ChanLen() int <span class="cov0" title="0">{
        return len(c.msgq0)
}</span>

// MsgQ1ChanLen returns length of channel of message published with qos=1
func (c *msgchan) msgq1ChanLen() int <span class="cov0" title="0">{
        return len(c.msgq1)
}</span>

func (c *msgchan) start() error <span class="cov8" title="1">{
        err := c.acktomb.Gos(c.goWaitingAck)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.msgtomb.Gos(c.goProcessingQ0, c.goProcessingQ1)</span>
}

// TODO: only handle messages with qos 0 before system closed. [bce-iot-6545]
func (c *msgchan) close(force bool) <span class="cov8" title="1">{
        c.log.Debugf("message channel closing")

        c.msgtomb.Kill()
        if force </span><span class="cov8" title="1">{
                c.acktomb.Kill()
        }</span>
        <span class="cov8" title="1">err := c.msgtomb.Wait()
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Debugf("message channel closed")
        }</span>
        <span class="cov8" title="1">if !force </span><span class="cov8" title="1">{
                c.acktomb.Kill()
        }</span>
        <span class="cov8" title="1">err = c.acktomb.Wait()
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Debugf("message channel closed")
        }</span>
}

// PutQ0 put message published with qos=0
func (c *msgchan) putQ0(msg *common.Message) <span class="cov8" title="1">{
        if !c.msgtomb.Alive() </span><span class="cov8" title="1">{
                c.log.WithError(errMsgChanClosed).Errorf("failed to put message (qos=0)")
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case c.msgq0 &lt;- msg:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"> // discard if channel is full
                c.discard(msg)</span>
        }
}

// PutQ1 put message published with qos=1
func (c *msgchan) putQ1(msg *common.Message) <span class="cov8" title="1">{
        select </span>{
        case &lt;-c.msgtomb.Dying():<span class="cov0" title="0">
                c.log.WithError(errMsgChanClosed).Errorf("failed to put message (qos=1)")</span>
        case c.msgq1 &lt;- msg:<span class="cov8" title="1"></span>
        }
}

// ProcessingQ0 processing message with QOS=0
func (c *msgchan) goProcessingQ0() error <span class="cov8" title="1">{
        c.log.Debugf("task of processing message from channel (Q0) begins")
        defer c.log.Debugf("task of processing message from channel (Q0) stopped")

loop:
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.msgtomb.Dying():<span class="cov8" title="1">
                        break loop</span>
                case msg := &lt;-c.msgq0:<span class="cov8" title="1">
                        c.process(msg)</span>
                }
        }
        // Try to handle all message with qos=0
        <span class="cov8" title="1">endTime := time.Now().Add(c.quitTimeout)
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg := &lt;-c.msgq0:<span class="cov0" title="0">
                        c.process(msg)</span>
                case &lt;-time.After(endTime.Sub(time.Now())):<span class="cov0" title="0">
                        c.log.Warnf("timed out to process inflight messages from channel (Q0) during shutdown")
                        return nil</span>
                case &lt;-c.acktomb.Dying():<span class="cov8" title="1">
                        c.log.Debugf("interrupted to process inflight messages from channel (Q0) during session close")
                        return nil</span>
                default:<span class="cov8" title="1">
                        c.log.Debugf("finished to process inflight messages from channel (Q0)")
                        return nil</span>
                }
        }
}

// ProcessingQ1 processing message with QOS=1
func (c *msgchan) goProcessingQ1() error <span class="cov8" title="1">{
        c.log.Debugf("task of processing message from channel (Q1) begins")
        defer c.log.Debugf("task of processing message from channel (Q1) stopped")

loop:
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.msgtomb.Dying():<span class="cov8" title="1">
                        break loop</span>
                case msg := &lt;-c.msgq1:<span class="cov8" title="1">
                        c.process(msg)</span>
                }
        }
        // Try to handle all message with qos=1
        <span class="cov8" title="1">endTime := time.Now().Add(c.quitTimeout)
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg := &lt;-c.msgq1:<span class="cov0" title="0">
                        c.process(msg)</span>
                case &lt;-time.After(endTime.Sub(time.Now())):<span class="cov0" title="0">
                        c.log.Warnf("timed out to process inflight messages (qos=1) during shutdown")
                        return nil</span>
                case &lt;-c.acktomb.Dying():<span class="cov8" title="1">
                        c.log.Debugf("interrupted to process inflight messages (qos=1) during session close")
                        return nil</span>
                default:<span class="cov8" title="1">
                        c.log.Debugf("finished to process inflight messages (qos=1)")
                        return nil</span>
                }
        }
}

func (c *msgchan) goWaitingAck() error <span class="cov8" title="1">{
        c.log.Debugf("task of waiting acknowledge begins")
        defer c.log.Debugf("task of waiting acknowledge stopped")

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.acktomb.Dying():<span class="cov8" title="1">
                        return nil</span>
                case msg := &lt;-c.msgack:<span class="cov8" title="1">
                        msg.WaitTimeout(c.republishBackoff, c.republish, c.acktomb.Dying())</span>
                }
        }
}

func (c *msgchan) process(msg *common.Message) <span class="cov8" title="1">{
        if msg.QOS == 0 </span><span class="cov8" title="1">{
                c.publish(*msg)
                return
        }</span>
        <span class="cov8" title="1">msg.SetCallbackSID(c.persist)
        if !msg.Barrier </span><span class="cov8" title="1">{
                if msg.TargetQOS == 1 </span><span class="cov8" title="1">{
                        msg.SetAcknowledge()
                }</span>
                <span class="cov8" title="1">c.publish(*msg)</span>
        }
        <span class="cov8" title="1">select </span>{
        case c.msgack &lt;- &amp;common.MsgAck{Message: msg, FST: time.Now()}:<span class="cov8" title="1"></span>
        case &lt;-c.acktomb.Dying():<span class="cov0" title="0">
                return</span>
        }
}

func (c *msgchan) discard(msg *common.Message) <span class="cov0" title="0">{
        c.log.Debugf(errMsgDiscarded.Error())
        if msg.QOS == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">msg.SetCallbackSID(c.persist)
        select </span>{
        case c.msgack &lt;- &amp;common.MsgAck{Message: msg, FST: time.Now()}:<span class="cov0" title="0"></span>
        case &lt;-c.acktomb.Dying():<span class="cov0" title="0">
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package rule

import (
        "strconv"
        "sync"

        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/router"
        "github.com/baetyl/baetyl/logger"
)

type base interface {
        uid() string
        start() (err error)
        stop()
        wait(bool)
        channel() *msgchan
        register(sub *sinksub)
        remove(id, topic string)
        info() map[string]interface{}
}

type rulebase struct {
        id      string
        sink    *sink
        broker  broker
        msgchan *msgchan
        once    sync.Once
        log     logger.Logger
}

func newRuleBase(id string, persistent bool, b broker, r *router.Trie, publish, republish common.Publish) *rulebase <span class="cov8" title="1">{
        log := logger.WithField("rule", id)
        rb := &amp;rulebase{
                id:     id,
                broker: b,
                log:    log,
        }
        persist := rb.persist
        if !persistent </span><span class="cov8" title="1">{
                persist = nil
        }</span>
        <span class="cov8" title="1">rb.msgchan = newMsgChan(
                b.Config().Message.Egress.Qos0.Buffer.Size,
                b.Config().Message.Egress.Qos1.Buffer.Size,
                publish,
                republish,
                b.Config().Message.Egress.Qos1.Retry.Interval,
                b.Config().Shutdown.Timeout,
                persist,
                log,
        )
        rb.sink = newSink(id, b, r, rb.msgchan)
        return rb</span>
}

func newRuleQos0(b broker, r *router.Trie) *rulebase <span class="cov8" title="1">{
        return newRuleBase(common.RuleMsgQ0, false, b, r, nil, nil)
}</span>

func newRuleTopic(b broker, r *router.Trie) *rulebase <span class="cov8" title="1">{
        rb := newRuleBase(common.RuleTopic, true, b, r, nil, nil)
        rb.msgchan.publish = rb.publish
        return rb
}</span>

func newRuleSess(id string, p bool, b broker, r *router.Trie, publish, republish common.Publish) base <span class="cov8" title="1">{
        return newRuleBase(id, p, b, r, publish, republish)
}</span>

func (r *rulebase) uid() string <span class="cov0" title="0">{
        return r.id
}</span>

func (r *rulebase) publish(msg common.Message) <span class="cov8" title="1">{
        msg.QOS = msg.TargetQOS
        msg.Topic = msg.TargetTopic
        msg.SequenceID = 0
        if msg.QOS == 1 </span><span class="cov8" title="1">{
                msg.SetCallbackPID(0, func(_ uint32) </span><span class="cov8" title="1">{ msg.Ack() }</span>)
        }
        <span class="cov8" title="1">r.broker.Flow(&amp;msg)</span>
}

func (r *rulebase) start() (err error) <span class="cov8" title="1">{
        r.once.Do(func() </span><span class="cov8" title="1">{
                err = r.msgchan.start()
                if err != nil </span><span class="cov0" title="0">{
                        r.msgchan.close(true)
                }</span>
                <span class="cov8" title="1">err = r.sink.start()
                if err != nil </span><span class="cov0" title="0">{
                        r.stop()
                        r.wait(true)
                }</span>
        })
        <span class="cov8" title="1">return</span>
}

func (r *rulebase) stop() <span class="cov8" title="1">{
        r.log.Debugf("rule closing")
        r.sink.stop()
}</span>

func (r *rulebase) wait(force bool) <span class="cov8" title="1">{
        r.sink.wait()
        r.msgchan.close(force)
        r.log.Debugf("rule closed")
}</span>

func (r *rulebase) channel() *msgchan <span class="cov8" title="1">{
        return r.msgchan
}</span>

func (r *rulebase) register(sub *sinksub) <span class="cov8" title="1">{
        r.sink.register(sub)
}</span>

func (r *rulebase) remove(id, topic string) <span class="cov0" title="0">{
        r.sink.remove(id, topic)
}</span>

func (r *rulebase) persist(sid uint64) <span class="cov8" title="1">{
        err := r.broker.PersistOffset(r.id, sid)
        if err != nil </span><span class="cov0" title="0">{
                r.log.WithError(err).Errorf("failed to persist offset")
        }</span>
}

func (r *rulebase) info() map[string]interface{} <span class="cov0" title="0">{
        offsetPersisted := "-"
        if v, _ := r.broker.OffsetPersisted(r.uid()); v != nil </span><span class="cov0" title="0">{
                offsetPersisted = strconv.FormatUint(*v, 10)
        }</span>
        <span class="cov0" title="0">return map[string]interface{}{
                "persisted_offset":      offsetPersisted,
                "buffered_offset":       r.sink.getOffset(),
                "buffered_message_qos0": len(r.msgchan.msgq0),
                "buffered_message_qos1": len(r.msgchan.msgq1),
                "buffered_message_ack":  len(r.msgchan.msgack),
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package rule

import (
        "sync/atomic"
        "time"

        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/router"
        "github.com/baetyl/baetyl/baetyl-hub/utils"
        "github.com/baetyl/baetyl/logger"
)

type sink struct {
        id      string
        offset  uint64
        broker  broker
        msgchan *msgchan
        trieq0  *router.Trie
        trieq1  *router.Trie
        tomb    utils.Tomb
        log     logger.Logger
}

func newSink(id string, b broker, r *router.Trie, msgchan *msgchan) *sink <span class="cov8" title="1">{
        s := &amp;sink{
                id:      id,
                broker:  b,
                trieq0:  r,
                trieq1:  router.NewTrie(),
                msgchan: msgchan,
                log:     logger.WithField("sink", id),
        }
        return s
}</span>

func (s *sink) getOffset() uint64 <span class="cov8" title="1">{
        return atomic.LoadUint64(&amp;s.offset)
}</span>

func (s *sink) setOffset(v uint64) <span class="cov8" title="1">{
        atomic.StoreUint64(&amp;s.offset, v)
}</span>

// Register adds a subscription
func (s *sink) register(sub *sinksub) <span class="cov8" title="1">{
        s.trieq0.Add(sub)
        s.trieq1.Add(sub)
}</span>

// Remove removes a subscription
func (s *sink) remove(id, topic string) <span class="cov0" title="0">{
        s.trieq0.Remove(id, topic)
        s.trieq1.Remove(id, topic)
}</span>

// RemoveAll removes all subscriptions by id
func (s *sink) removeAll(id string) <span class="cov0" title="0">{
        s.trieq0.RemoveAll(id)
}</span>

func (s *sink) start() error <span class="cov8" title="1">{
        if s.id == common.RuleMsgQ0 </span><span class="cov8" title="1">{
                return s.tomb.Gos(s.goRoutingQ0)
        }</span>

        <span class="cov8" title="1">offset, err := s.broker.InitOffset(s.id, s.msgchan.persist != nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.setOffset(offset)
        return s.tomb.Gos(s.goRoutingQ1)</span>
}

func (s *sink) stop() <span class="cov8" title="1">{
        s.log.Debugf("sink stopping")
        s.trieq0.RemoveAll(s.id)
        s.tomb.Kill()
}</span>

func (s *sink) wait() <span class="cov8" title="1">{
        err := s.tomb.Wait()
        s.log.WithError(err).Debugf("sink stopped")
}</span>

func (s *sink) goRoutingQ0() error <span class="cov8" title="1">{
        s.log.Debugf("task of routing message (Q0) begins")
        defer s.log.Debugf("task of routing message (Q0) stopped")

        var msg *common.Message
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.tomb.Dying():<span class="cov8" title="1">
                        return nil</span>
                case msg = &lt;-s.broker.MsgQ0Chan():<span class="cov8" title="1">
                        matches := s.trieq0.MatchUnique(msg.Topic)
                        for _, sub := range matches </span><span class="cov8" title="1">{
                                sub.Flow(*msg)
                        }</span>
                }
        }
}

func (s *sink) goRoutingQ1() error <span class="cov8" title="1">{
        s.log.Debugf("task of routing message (Q1) begins with offset=%d", s.getOffset())
        defer s.log.Debugf("task of routing message (Q1) stopped")

        var (
                err    error
                msg    *common.Message
                msgs   []*common.Message
                length int
        )
        ticker := time.NewTicker(time.Millisecond * 10)
        maxBatchSize := s.broker.Config().Message.Egress.Qos1.Batch.Max
        for </span><span class="cov8" title="1">{
                if !s.tomb.Alive() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">msgs, err = s.broker.FetchQ1(s.getOffset(), maxBatchSize)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).Errorf("failed to fetch message")
                        select </span>{
                        case &lt;-s.tomb.Dying():<span class="cov0" title="0">
                                return nil</span>
                        case &lt;-time.After(time.Second):<span class="cov0" title="0">
                                continue</span>
                        }
                }
                <span class="cov8" title="1">length = len(msgs)
                if length == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-s.tomb.Dying():<span class="cov8" title="1">
                                return nil</span>
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                continue</span>
                        }
                }
                <span class="cov8" title="1">s.log.Debugf("%d message(s) fetched", length)
                if length != 1 </span><span class="cov8" title="1">{
                        for _, msg = range msgs[:length-1] </span><span class="cov8" title="1">{
                                matches := s.trieq1.MatchUnique(msg.Topic)
                                for _, sub := range matches </span><span class="cov8" title="1">{
                                        sub.Flow(*msg)
                                }</span>
                        }
                }
                <span class="cov8" title="1">msg = msgs[length-1]
                matches := s.trieq1.MatchUnique(msg.Topic)
                for _, sub := range matches </span><span class="cov8" title="1">{
                        sub.Flow(*msg)
                }</span>
                <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                        // put barrier to make sure offset update in db even no message routed
                        msg.Barrier = true
                        s.msgchan.putQ0(msg)
                }</span>
                <span class="cov8" title="1">s.setOffset(msg.SequenceID + 1)</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package rule

import (
        "github.com/baetyl/baetyl/baetyl-hub/common"
)

// sinksub subscription of sink
type sinksub struct {
        id      string
        qos     uint32
        topic   string
        tqos    uint32
        ttopic  string
        channel *msgchan
}

// Newsinksub creates a new subscription of sink
func newSinkSub(subid string, subqos uint32, subtopic string, pubqos uint32, pubtopic string, channel *msgchan) *sinksub <span class="cov8" title="1">{
        return &amp;sinksub{
                id:      subid,
                qos:     subqos,
                topic:   subtopic,
                tqos:    pubqos,
                ttopic:  pubtopic,
                channel: channel,
        }
}</span>

// ID returns id of sinksub
func (s *sinksub) ID() string <span class="cov8" title="1">{
        return s.id
}</span>

// QOS returns qos of sinksub
func (s *sinksub) QOS() uint32 <span class="cov0" title="0">{
        return s.qos
}</span>

// Topic returns topic of sinksub
func (s *sinksub) Topic() string <span class="cov8" title="1">{
        return s.topic
}</span>

// TargetQOS returns target qos of sinksub
func (s *sinksub) TargetQOS() uint32 <span class="cov0" title="0">{
        return s.tqos
}</span>

// TargetTopic returns target topic of sinksub
func (s *sinksub) TargetTopic() string <span class="cov0" title="0">{
        return s.ttopic
}</span>

// Flow flows message
func (s *sinksub) Flow(msg common.Message) <span class="cov8" title="1">{
        // set target topic
        if s.ttopic != "" </span><span class="cov8" title="1">{
                msg.TargetTopic = s.ttopic
        }</span> else<span class="cov8" title="1"> {
                msg.TargetTopic = msg.Topic
        }</span>
        // qos only can decrease without increasing
        <span class="cov8" title="1">sqos := s.qos
        if msg.QOS &lt; sqos </span><span class="cov8" title="1">{
                sqos = msg.QOS
        }</span>
        <span class="cov8" title="1">if sqos == 0 </span><span class="cov8" title="1">{
                msg.TargetQOS = 0
                s.channel.putQ0(&amp;msg)
        }</span> else<span class="cov8" title="1"> {
                msg.TargetQOS = s.tqos
                s.channel.putQ1(&amp;msg)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package server

import (
        "github.com/256dpi/gomqtt/transport"
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/protocol/mqtt"
        "github.com/baetyl/baetyl/utils"
)

// Handle handles connection
type Handle func(transport.Conn)

// Manager manager of servers
type Manager struct {
        servers []transport.Server
        handle  Handle
        tomb    utils.Tomb
        log     logger.Logger
}

// NewManager creates a server manager
func NewManager(addrs []string, cert utils.Certificate, handle Handle) (*Manager, error) <span class="cov8" title="1">{
        launcher, err := mqtt.NewLauncher(cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := &amp;Manager{
                servers: make([]transport.Server, 0),
                handle:  handle,
                log:     logger.WithField("manager", "server"),
        }
        for _, addr := range addrs </span><span class="cov8" title="1">{
                svr, err := launcher.Launch(addr)
                if err != nil </span><span class="cov8" title="1">{
                        m.Close()
                        return nil, err
                }</span>
                <span class="cov8" title="1">m.servers = append(m.servers, svr)</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// Start starts all servers
func (m *Manager) Start() <span class="cov8" title="1">{
        for _, item := range m.servers </span><span class="cov8" title="1">{
                svr := item
                m.tomb.Go(func() error </span><span class="cov8" title="1">{
                        for </span><span class="cov8" title="1">{
                                conn, err := svr.Accept()
                                if err != nil </span><span class="cov8" title="1">{
                                        if !m.tomb.Alive() </span><span class="cov8" title="1">{
                                                return nil
                                        }</span>
                                        <span class="cov0" title="0">m.log.WithError(err).Errorf("failed to accept connection")
                                        continue</span>
                                }
                                <span class="cov8" title="1">go m.handle(conn)</span>
                        }
                })
        }
}

// Close closes server manager
func (m *Manager) Close() error <span class="cov8" title="1">{
        m.tomb.Kill(nil)
        for _, svr := range m.servers </span><span class="cov8" title="1">{
                svr.Close()
        }</span>
        <span class="cov8" title="1">return m.tomb.Wait()</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package session

import (
        "github.com/256dpi/gomqtt/transport"
        "github.com/baetyl/baetyl/baetyl-hub/auth"
        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/config"
        "github.com/baetyl/baetyl/baetyl-hub/persist"
        "github.com/baetyl/baetyl/baetyl-hub/rule"
        "github.com/baetyl/baetyl/logger"
        cmap "github.com/orcaman/concurrent-map"
)

// Manager session manager
type Manager struct {
        auth     *auth.Auth
        recorder *recorder
        sessions cmap.ConcurrentMap
        flow     common.Flow
        conf     *config.Message
        rules    *rule.Manager
        log      logger.Logger
}

// NewManager creates a session manager
func NewManager(conf *config.Config, flow common.Flow, rules *rule.Manager, pf *persist.Factory) (*Manager, error) <span class="cov8" title="1">{
        sessionDB, err := pf.NewDB("session.db")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Manager{
                auth:     auth.NewAuth(conf.Principals),
                rules:    rules,
                flow:     flow,
                conf:     &amp;conf.Message,
                recorder: newRecorder(sessionDB),
                sessions: cmap.New(),
                log:      logger.WithField("manager", "session"),
        }, nil</span>
}

// Handle handles connection
func (m *Manager) Handle(conn transport.Conn) <span class="cov0" title="0">{
        defer conn.Close()
        conn.SetReadLimit(int64(m.conf.Length.Max))
        newSession(conn, m).Handle()
}</span>

// Close closes all sessions, called by rule manager
func (m *Manager) Close() <span class="cov8" title="1">{
        m.log.Infof("session manager closing")
        for item := range m.sessions.IterBuffered() </span><span class="cov8" title="1">{
                item.Val.(*session).close(true)
        }</span>
        <span class="cov8" title="1">m.log.Infof("session manager closed")</span>
}

// Called by session during onConnect
func (m *Manager) register(sess *session) error <span class="cov8" title="1">{
        if old, ok := m.sessions.Get(sess.id); ok </span><span class="cov8" title="1">{
                old.(*session).close(true)
        }</span>
        <span class="cov8" title="1">m.sessions.Set(sess.id, sess)
        return m.rules.AddRuleSess(sess.id, !sess.clean, sess.publish, sess.republish)</span>
}

// Called by session when error raises
func (m *Manager) remove(id string) <span class="cov8" title="1">{
        m.sessions.Remove(id)
        err := m.rules.RemoveRule(id)
        if err != nil </span><span class="cov8" title="1">{
                m.log.WithError(err).Debugf("failed to remove rule")
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package session

import (
        "encoding/json"
        "fmt"
        "sync"

        "github.com/256dpi/gomqtt/packet"
        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/persist"
        "github.com/baetyl/baetyl/logger"
)

// recorder records session info
type recorder struct {
        db  persist.Database
        log logger.Logger
        sync.Mutex
}

// NewRecorder creates a recorder
func newRecorder(db persist.Database) *recorder <span class="cov8" title="1">{
        return &amp;recorder{
                db:  db,
                log: logger.WithField("session", "recorder"),
        }
}</span>

// AddSub adds subscription to id
func (c *recorder) addSub(id string, sub packet.Subscription) error <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()

        subs, err := c.getsubs(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">subs[sub.Topic] = sub
        creates, err := json.Marshal(subs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal subscriptions: %s", err.Error())
        }</span>
        <span class="cov8" title="1">err = c.db.BucketPut(common.BucketNameDotSubscription, []byte(id), creates)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to persist subscriptions: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("subscription persisted: qos=%d, topic=%s, id=%s", sub.QOS, sub.Topic, id)
        return nil</span>
}

// RemoveSub removes subscription from id
func (c *recorder) removeSub(id, topic string) error <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()

        subs, err := c.getsubs(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">delete(subs, topic)
        creates, err := json.Marshal(subs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal subscriptions: %s", err.Error())
        }</span>
        <span class="cov8" title="1">err = c.db.BucketPut(common.BucketNameDotSubscription, []byte(id), creates)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to persist subscriptions: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("subscription removed: topic=%s, id=%s", topic, id)
        return nil</span>
}

// GetSubs gets subscriptions of id
func (c *recorder) getSubs(id string) ([]packet.Subscription, error) <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()

        subs, err := c.getsubs(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res := make([]packet.Subscription, 0)
        for _, sub := range subs </span><span class="cov8" title="1">{
                res = append(res, sub)
        }</span>
        <span class="cov8" title="1">c.log.Debugf("%d subscription(s) got: id=%s", len(res), id)
        return res, nil</span>
}

func (c *recorder) getsubs(id string) (map[string]packet.Subscription, error) <span class="cov8" title="1">{
        olds, err := c.db.BucketGet(common.BucketNameDotSubscription, []byte(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subscriptions: %s", err.Error())
        }</span>
        <span class="cov8" title="1">subs := make(map[string]packet.Subscription)
        if olds != nil </span><span class="cov8" title="1">{
                err = json.Unmarshal(olds, &amp;subs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal subscriptions: %s", err.Error())
                }</span>
        }
        <span class="cov8" title="1">return subs, nil</span>
}

// SetRetained sets retained message of topic
func (c *recorder) setRetained(topic string, msg *packet.Message) error <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()
        if !msg.Retain </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">value, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = c.db.BucketPut(common.BucketNameDotRetained, []byte(topic), value)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Errorf("failed to persist retain message: topic=%s", topic)
                return fmt.Errorf("failed to persist retain message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("retain message persisited: topic=%s", topic)
        return nil</span>
}

// GetRetained gets retained message of all topics
func (c *recorder) getRetained() ([]*packet.Message, error) <span class="cov8" title="1">{
        l, err := c.db.BucketList(common.BucketNameDotRetained)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Errorf("failed to get retaind message")
                return nil, fmt.Errorf("failed to get retain message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">result := make([]*packet.Message, 0)
        for _, v := range l </span><span class="cov8" title="1">{
                var msg packet.Message
                err := json.Unmarshal(v, &amp;msg)
                if err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).Warnf("failed to unmarshal retain message")
                }</span>
                <span class="cov8" title="1">result = append(result, &amp;msg)</span>
        }
        <span class="cov8" title="1">c.log.Debugf("%d retain message(s) got", len(result))
        return result, nil</span>
}

// RemoveRetained removes retain message of topic
func (c *recorder) removeRetained(topic string) error <span class="cov8" title="1">{
        err := c.db.BucketDelete(common.BucketNameDotRetained, []byte(topic))
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Errorf("failed to remove retain message: topic=%s", topic)
                return fmt.Errorf("failed to remove retain message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("retain message removed: topic=%s", topic)
        return nil</span>
}

// SetWill sets will message of cleint
func (c *recorder) setWill(id string, msg *packet.Message) error <span class="cov8" title="1">{
        value, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal will message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">err = c.db.BucketPut(common.BucketNameDotWill, []byte(id), value)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Errorf("failed to persist will message: topic=%s, id=%s", msg.Topic, id)
                return fmt.Errorf("failed to persist will message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("will message persisted: topic=%s, id=%s", msg.Topic, id)
        return nil</span>
}

// GetWill gets will message of cleint
func (c *recorder) getWill(id string) (*packet.Message, error) <span class="cov8" title="1">{
        data, err := c.db.BucketGet(common.BucketNameDotWill, []byte(id))
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Errorf("failed to get will message: id=%s", id)
                return nil, fmt.Errorf("failed to get will message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var msg packet.Message
        err = json.Unmarshal(data, &amp;msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal will message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("will message got: topic=%s, id=%s", msg.Topic, id)
        return &amp;msg, nil</span>
}

// RemoveWill removes will message of cleint
func (c *recorder) removeWill(id string) error <span class="cov8" title="1">{
        err := c.db.BucketDelete(common.BucketNameDotWill, []byte(id))
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Errorf("failed to remove will message: id=%s", id)
                return fmt.Errorf("failed to remove will message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">c.log.Debugf("will message removed: id=%s", id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package session

import (
        "fmt"
        "sync"

        "github.com/256dpi/gomqtt/packet"
        "github.com/256dpi/gomqtt/transport"
        "github.com/baetyl/baetyl/baetyl-hub/auth"
        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/router"
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/utils"
)

// session session of a client
// ingress data flow: client -&gt; session(onPublish) -&gt; broker -&gt; database -&gt; session(Ack)
// egress data flow: broker(rule) -&gt; session(doQ0/doQ1) -&gt; client -&gt; session(onPuback)
type session struct {
        id       string
        clean    bool
        clientID string
        conn     transport.Conn
        subs     map[string]packet.Subscription
        manager  *Manager
        pids     *common.PacketIDS
        log      logger.Logger
        once     sync.Once
        tomb     utils.Tomb
        sync.Mutex

        authorizer *auth.Authorizer
        //  cache
        permittedPublishTopics map[string]struct{}
}

func newSession(conn transport.Conn, manager *Manager) *session <span class="cov8" title="1">{
        return &amp;session{
                conn:                   conn,
                manager:                manager,
                subs:                   make(map[string]packet.Subscription),
                pids:                   common.NewPacketIDS(),
                log:                    logger.WithField("mqtt", "session"),
                permittedPublishTopics: make(map[string]struct{}),
        }
}</span>

func (s *session) send(p packet.Generic, async bool) error <span class="cov8" title="1">{
        s.Lock()
        defer s.Unlock()
        err := s.conn.Send(p, async)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send message: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *session) sendConnack(code packet.ConnackCode) error <span class="cov8" title="1">{
        ack := packet.Connack{
                SessionPresent: false, // TODO: to support
                ReturnCode:     code,
        }
        return s.send(&amp;ack, false)
}</span>

func (s *session) saveWillMessage(p *packet.Connect) error <span class="cov8" title="1">{
        if p.Will == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.manager.recorder.setWill(s.id, p.Will)</span>
}

// TODO: need to send will message after client reconnected if baetyl panicked
// Situations in which the Will Message is published include, but are not limited to:
// * An I/O error or network failure detected by the Server.
// * The Client fails to communicate within the Keep Alive time.
// * The Client closes the Network Connection without first sending a DISCONNECT Packet. The Server closes the Network Connection because of a protocol error.
func (s *session) sendWillMessage() <span class="cov8" title="1">{
        msg, err := s.manager.recorder.getWill(s.id)
        if err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).Errorf("failed to get will message")
        }</span>
        <span class="cov8" title="1">if msg == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = s.retainMessage(msg)
        if err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).Errorf("failed to retain will message")
        }</span>
        <span class="cov8" title="1">s.manager.flow(common.NewMessage(uint32(msg.QOS), msg.Topic, msg.Payload, s.clientID))</span>
}

func (s *session) retainMessage(msg *packet.Message) error <span class="cov8" title="1">{
        if len(msg.Payload) == 0 </span><span class="cov8" title="1">{
                return s.manager.recorder.removeRetained(msg.Topic)
        }</span>
        <span class="cov8" title="1">return s.manager.recorder.setRetained(msg.Topic, msg)</span>
}

// TODO: 
func (s *session) sendRetainMessage(p *packet.Subscribe) error <span class="cov8" title="1">{
        msgs, err := s.manager.recorder.getRetained()
        if err != nil || len(msgs) == 0 </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">t := router.NewTrie()
        for _, sub := range p.Subscriptions </span><span class="cov8" title="1">{
                t.Add(router.NewNopSinkSub(s.id, uint32(sub.QOS), sub.Topic, uint32(sub.QOS), ""))
        }</span>
        // TODO: improve and test, to resend if not acked?
        <span class="cov8" title="1">for _, msg := range msgs </span><span class="cov8" title="1">{
                if ok, qos := t.IsMatch(msg.Topic); ok </span><span class="cov8" title="1">{
                        m := common.NewMessage(uint32(msg.QOS), msg.Topic, msg.Payload, s.clientID)
                        if qos &gt; m.QOS </span><span class="cov0" title="0">{
                                m.TargetQOS = m.QOS
                        }</span> else<span class="cov8" title="1"> {
                                m.TargetQOS = qos
                        }</span>
                        <span class="cov8" title="1">m.TargetTopic = msg.Topic
                        m.Retain = true
                        s.publish(*m)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *session) genSubAck(subs []packet.Subscription) []packet.QOS <span class="cov8" title="1">{
        rv := make([]packet.QOS, len(subs))
        for i, sub := range subs </span><span class="cov8" title="1">{
                if !common.SubTopicValidate(sub.Topic) </span><span class="cov8" title="1">{
                        s.log.Errorf("subscribe topic (%s) invalid", sub.Topic)
                        rv[i] = packet.QOSFailure
                }</span> else<span class="cov8" title="1"> if !s.authorizer.Authorize(auth.Subscribe, sub.Topic) </span><span class="cov8" title="1">{
                        s.log.Errorf("subscribe topic (%s) not permitted", sub.Topic)
                        rv[i] = packet.QOSFailure
                }</span> else<span class="cov8" title="1"> if sub.QOS &gt; 1 </span><span class="cov8" title="1">{
                        s.log.Errorf("subscribe QOS (%d) not supported", sub.QOS)
                        rv[i] = packet.QOSFailure
                }</span> else<span class="cov8" title="1"> {
                        rv[i] = sub.QOS
                }</span>
        }
        <span class="cov8" title="1">return rv</span>
}

// Close closes this session, only called by session manager
func (s *session) close(will bool) <span class="cov8" title="1">{
        s.once.Do(func() </span><span class="cov8" title="1">{
                s.tomb.Kill(nil)
                s.log.Infof("session closing, messages (unack): %d", s.pids.Size())
                defer s.log.Infof("session closed, messages (unack): %d", s.pids.Size())
                s.manager.remove(s.id)
                if will </span><span class="cov8" title="1">{
                        s.sendWillMessage()
                }</span>
                <span class="cov8" title="1">s.conn.Close()
                s.manager.recorder.removeWill(s.id)</span>
        })
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package session

import (
        "github.com/256dpi/gomqtt/packet"
        "github.com/baetyl/baetyl/baetyl-hub/common"
)

func (s *session) publish(msg common.Message) <span class="cov8" title="1">{
        pub := new(packet.Publish)
        pub.Message.QOS = packet.QOS(msg.TargetQOS)
        pub.Message.Topic = msg.TargetTopic
        pub.Message.Payload = msg.Payload
        pub.Message.Retain = msg.Retain
        if msg.TargetQOS == 1 </span><span class="cov8" title="1">{
                pid := s.pids.Set(&amp;msg)
                pub.ID = packet.ID(pid)
        }</span>
        <span class="cov8" title="1">if err := s.send(pub, true); err != nil </span><span class="cov0" title="0">{
                s.close(true)
        }</span>
}

func (s *session) republish(msg common.Message) <span class="cov8" title="1">{
        if msg.TargetQOS != 1 </span><span class="cov0" title="0">{
                s.log.Errorf("unexpcted: qos must be 1")
        }</span>
        <span class="cov8" title="1">pid := s.pids.Get(msg.SequenceID)
        if pid == 0 </span><span class="cov0" title="0">{
                s.log.Errorf("failed to find packet to republish")
                return
        }</span>
        <span class="cov8" title="1">pub := new(packet.Publish)
        pub.ID = packet.ID(pid)
        pub.Dup = true
        pub.Message.QOS = 1
        pub.Message.Topic = msg.TargetTopic
        pub.Message.Payload = msg.Payload
        if err := s.send(pub, true); err != nil </span><span class="cov0" title="0">{
                s.close(true)
        }</span>
        <span class="cov8" title="1">s.log.Debugf("message (pid=%d) resent", pid)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package session

import (
        "fmt"

        "github.com/256dpi/gomqtt/packet"
        "github.com/baetyl/baetyl/baetyl-hub/auth"
        "github.com/baetyl/baetyl/baetyl-hub/common"
        "github.com/baetyl/baetyl/baetyl-hub/utils"
        "github.com/baetyl/baetyl/protocol/mqtt"
        "github.com/docker/distribution/uuid"
)

// Handle handles mqtt connection
func (s *session) Handle() <span class="cov8" title="1">{
        var err error
        var pkt packet.Generic
        for </span><span class="cov8" title="1">{
                pkt, err = s.conn.Receive()
                if err != nil </span><span class="cov0" title="0">{
                        if !s.tomb.Alive() </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">s.log.WithError(err).Warnf("failed to reveive message")
                        s.close(true)
                        return</span>
                }
                <span class="cov8" title="1">if _, ok := pkt.(*packet.Connect); !ok &amp;&amp; s.authorizer == nil </span><span class="cov0" title="0">{
                        s.log.Errorf("only connect packet is allowed before auth")
                        s.close(true)
                        return
                }</span>
                <span class="cov8" title="1">switch p := pkt.(type) </span>{
                case *packet.Connect:<span class="cov0" title="0">
                        s.log.Debugln("received:", p.Type())
                        err = s.onConnect(p)</span>
                case *packet.Publish:<span class="cov8" title="1">
                        s.log.Debugf("received: %s, pid: %d, qos: %d, topic: %s", p.Type(), p.ID, p.Message.QOS, p.Message.Topic)
                        err = s.onPublish(p)</span>
                case *packet.Puback:<span class="cov0" title="0">
                        s.log.Debugf("received: %s, pid: %d", p.Type(), p.ID)
                        err = s.onPuback(p)</span>
                case *packet.Subscribe:<span class="cov0" title="0">
                        s.log.Debugf("received: %s, subs: %v", p.Type(), p.Subscriptions)
                        err = s.onSubscribe(p)</span>
                case *packet.Pingreq:<span class="cov0" title="0">
                        s.log.Debugln("received:", p.Type())
                        err = s.onPingreq(p)</span>
                case *packet.Pingresp:<span class="cov0" title="0">
                        s.log.Debugln("received:", p.Type())
                        err = nil</span> // just ignore
                case *packet.Disconnect:<span class="cov0" title="0">
                        s.log.Debugln("received:", p.Type())
                        s.close(false)
                        return</span>
                case *packet.Unsubscribe:<span class="cov0" title="0">
                        s.log.Debugf("received: %s, topics: %v", p.Type(), p.Topics)
                        err = s.onUnsubscribe(p)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("packet (%v) not supported", p)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        s.log.Errorf(err.Error())
                        s.close(true)
                        break</span>
                }
        }
}

func (s *session) onConnect(p *packet.Connect) error <span class="cov8" title="1">{
        s.log = s.log.WithField("client", p.ClientID)
        if p.Version != packet.Version31 &amp;&amp; p.Version != packet.Version311 </span><span class="cov8" title="1">{
                s.sendConnack(packet.InvalidProtocolVersion)
                return fmt.Errorf("MQTT protocol version (%d) invalid", p.Version)
        }</span>
        // username must set
        <span class="cov8" title="1">if p.Username == "" </span><span class="cov0" title="0">{
                s.sendConnack(packet.BadUsernameOrPassword)
                return fmt.Errorf("username not set")
        }</span>
        <span class="cov8" title="1">if p.Password != "" </span><span class="cov8" title="1">{
                // if password is set, to use account auth
                s.authorizer = s.manager.auth.AuthenticateAccount(p.Username, p.Password)
                if s.authorizer == nil </span><span class="cov8" title="1">{
                        s.sendConnack(packet.BadUsernameOrPassword)
                        return fmt.Errorf("username (%s) or password not permitted", p.Username)
                }</span>
        } else<span class="cov0" title="0"> if mqtt.IsTwoWayTLS(s.conn) </span><span class="cov0" title="0">{
                // if it is two-way tls, to use cert auth
                s.authorizer = s.manager.auth.AuthenticateCert(p.Username)
                if s.authorizer == nil </span><span class="cov0" title="0">{
                        s.sendConnack(packet.BadUsernameOrPassword)
                        return fmt.Errorf("username (%s) is not permitted over tls", p.Username)
                }</span>
        } else<span class="cov0" title="0"> {
                s.sendConnack(packet.BadUsernameOrPassword)
                return fmt.Errorf("password not set")
        }</span>
        <span class="cov8" title="1">if !utils.IsClientID(p.ClientID) </span><span class="cov0" title="0">{
                s.sendConnack(packet.IdentifierRejected)
                return fmt.Errorf("client ID (%s) invalid", p.ClientID)
        }</span>
        <span class="cov8" title="1">if p.Will != nil </span><span class="cov8" title="1">{
                // TODO: remove?
                if !common.PubTopicValidate(p.Will.Topic) </span><span class="cov0" title="0">{
                        return fmt.Errorf("will topic (%s) invalid", p.Will.Topic)
                }</span>
                <span class="cov8" title="1">if !s.authorizer.Authorize(auth.Publish, p.Will.Topic) </span><span class="cov8" title="1">{
                        s.sendConnack(packet.NotAuthorized)
                        return fmt.Errorf("will topic (%s) not permitted", p.Will.Topic)
                }</span>
                <span class="cov8" title="1">if p.Will.QOS &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("will QOS (%d) not supported", p.Will.QOS)
                }</span>
        }
        <span class="cov8" title="1">var err error
        s.clientID = p.ClientID
        s.clean = p.CleanSession
        if p.ClientID == "" </span><span class="cov0" title="0">{
                s.id = common.PrefixTmp + uuid.Generate().String()
                s.clean = true
        }</span> else<span class="cov8" title="1"> {
                s.id = common.PrefixSess + p.ClientID
        }</span>
        <span class="cov8" title="1">err = s.manager.register(s)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create session rule: %s", err.Error())
        }</span>
        <span class="cov8" title="1">subs, err := s.manager.recorder.getSubs(s.id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if s.clean </span><span class="cov8" title="1">{
                for _, sub := range subs </span><span class="cov8" title="1">{
                        err = s.manager.recorder.removeSub(s.id, sub.Topic)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">s.log.Debugf("session state cleaned")</span>
        } else<span class="cov8" title="1"> {
                // bce-iot-5347
                // Re-check subscriptions, if subscription not permit, log error and skip
                rv := s.genSubAck(subs)
                for i, sub := range subs </span><span class="cov8" title="1">{
                        if rv[i] == packet.QOSFailure </span><span class="cov0" title="0">{
                                s.log.Errorf("failed to resubscribe topic (%s)", sub.Topic)
                                err = s.manager.recorder.removeSub(s.id, sub.Topic)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">s.subs[sub.Topic] = sub
                        err := s.manager.rules.AddSinkSub(s.id, s.id, uint32(sub.QOS), sub.Topic, uint32(sub.QOS), "")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resubscribe: %s", err.Error())
                        }</span>
                        <span class="cov8" title="1">s.log.Infof("topic (%s) resubscribed", sub.Topic)</span>
                }
                <span class="cov8" title="1">s.log.Debugf("session state resumed")</span>
        }
        <span class="cov8" title="1">err = s.saveWillMessage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = s.sendConnack(packet.ConnectionAccepted)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = s.manager.rules.StartRule(s.id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.log.Infof("session connected")
        return nil</span>
}

func (s *session) onPublish(p *packet.Publish) error <span class="cov8" title="1">{
        if _, ok := s.permittedPublishTopics[p.Message.Topic]; !ok </span><span class="cov8" title="1">{
                // TODO: remove?
                if !common.PubTopicValidate(p.Message.Topic) </span><span class="cov0" title="0">{
                        return fmt.Errorf("publish topic (%s) invalid", p.Message.Topic)
                }</span>
                <span class="cov8" title="1">if !s.authorizer.Authorize(auth.Publish, p.Message.Topic) </span><span class="cov8" title="1">{
                        return fmt.Errorf("publish topic (%s) not permitted", p.Message.Topic)
                }</span>
                <span class="cov8" title="1">s.permittedPublishTopics[p.Message.Topic] = struct{}{}</span>
        }
        <span class="cov8" title="1">if p.Message.QOS &gt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("publish QOS (%d) not supported", p.Message.QOS)
        }</span>
        <span class="cov8" title="1">err := s.retainMessage(&amp;p.Message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">msg := common.NewMessage(uint32(p.Message.QOS), p.Message.Topic, p.Message.Payload, s.clientID)
        if p.Message.QOS == 1 </span><span class="cov8" title="1">{
                msg.SetCallbackPID(uint32(p.ID), s.callback)
        }</span>
        <span class="cov8" title="1">s.manager.flow(msg)
        return nil</span>
}

func (s *session) onPuback(p *packet.Puback) error <span class="cov8" title="1">{
        // s.log.Debugf("receive puback: pid=%d", p.ID)
        if !s.pids.Ack(p.ID) </span><span class="cov0" title="0">{
                s.log.Warnf("puback(pid=%d) not found", p.ID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *session) onSubscribe(p *packet.Subscribe) error <span class="cov8" title="1">{
        ack := packet.NewSuback()
        rv := s.genSubAck(p.Subscriptions)
        for i, sub := range p.Subscriptions </span><span class="cov8" title="1">{
                if rv[i] == packet.QOSFailure </span><span class="cov8" title="1">{
                        s.log.Errorf("failed to subscribe topic (%s)", sub.Topic)
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := s.subs[sub.Topic]; !ok </span><span class="cov8" title="1">{
                        err := s.manager.rules.AddSinkSub(s.id, s.id, uint32(sub.QOS), sub.Topic, uint32(sub.QOS), "")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">s.log.Infof("topic (%s) subscribed", sub.Topic)
                        s.subs[sub.Topic] = sub
                        if !s.clean </span><span class="cov8" title="1">{
                                err := s.manager.recorder.addSub(s.id, sub)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if s.subs[sub.Topic].QOS != sub.QOS </span><span class="cov8" title="1">{
                                // s.manager.rules.RemoveSinkSub(s.id, sub.Topic)
                                err := s.manager.rules.AddSinkSub(s.id, s.id, uint32(sub.QOS), sub.Topic, uint32(sub.QOS), "")
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">s.log.Infof("topic (%s) subscribed", sub.Topic)
                                s.subs[sub.Topic] = sub
                                if !s.clean </span><span class="cov8" title="1">{
                                        err := s.manager.recorder.removeSub(s.id, sub.Topic)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">err = s.manager.recorder.addSub(s.id, sub)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">ack.ID = p.ID
        ack.ReturnCodes = rv
        err := s.send(ack, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return s.sendRetainMessage(p)</span>
}

func (s *session) onUnsubscribe(p *packet.Unsubscribe) error <span class="cov8" title="1">{
        ack := packet.NewUnsuback()
        for _, topic := range p.Topics </span><span class="cov8" title="1">{
                if _, ok := s.subs[topic]; ok </span><span class="cov8" title="1">{
                        err := s.manager.rules.RemoveSinkSub(s.id, topic)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Errorf(err.Error())
                        }</span>
                        <span class="cov8" title="1">delete(s.subs, topic)
                        if !s.clean </span><span class="cov8" title="1">{
                                s.manager.recorder.removeSub(s.id, topic)
                        }</span>
                        <span class="cov8" title="1">s.log.Infof("topic (%s) is unsubscribed", topic)</span>
                } else<span class="cov8" title="1"> {
                        s.log.Warnf("topic (%s) is not subscribed yet", topic)
                }</span>
        }
        <span class="cov8" title="1">ack.ID = p.ID
        return s.send(ack, true)</span>
}

func (s *session) onPingreq(p *packet.Pingreq) error <span class="cov0" title="0">{
        return s.send(packet.NewPingresp(), true)
}</span>

func (s *session) callback(pid uint32) <span class="cov8" title="1">{
        ack := packet.NewPuback()
        ack.ID = packet.ID(pid)
        err := s.send(ack, true)
        if err != nil </span><span class="cov0" title="0">{
                s.close(true)
                return
        }</span>
        <span class="cov8" title="1">s.log.Debugf("puback(pid=%d) sent", pid)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import (
        "encoding/binary"
)

// U64U64ToB converts two uint64 to bytes
func U64U64ToB(sid, ts uint64) []byte <span class="cov0" title="0">{
        r := make([]byte, 16)
        binary.BigEndian.PutUint64(r, sid)
        binary.BigEndian.PutUint64(r[8:], ts)
        return r
}</span>

// U64U64 gets two uint64 from bytes
func U64U64(v []byte) (uint64, uint64) <span class="cov0" title="0">{
        return binary.BigEndian.Uint64(v), binary.BigEndian.Uint64(v[8:])
}</span>

// U64ToB converts uint64 to bytes
func U64ToB(v uint64) []byte <span class="cov8" title="1">{
        r := make([]byte, 8)
        binary.BigEndian.PutUint64(r, v)
        return r
}</span>

// U16 gets uint16 from bytes
func U16(v []byte) uint16 <span class="cov0" title="0">{
        return binary.BigEndian.Uint16(v)
}</span>

// U64 gets uint64 from bytes
func U64(v []byte) uint64 <span class="cov8" title="1">{
        return binary.BigEndian.Uint64(v)
}</span>

// PutU16 puts uint16 into bytes
func PutU16(dst []byte, v uint16) <span class="cov0" title="0">{
        binary.BigEndian.PutUint16(dst, v)
}</span>

// PutU64 puts uint64 into bytes
func PutU64(dst []byte, v uint64) <span class="cov0" title="0">{
        binary.BigEndian.PutUint64(dst, v)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "strings"
)

// GetKeys gets all keys of map
func GetKeys(m map[string]struct{}) []string <span class="cov0" title="0">{
        keys := reflect.ValueOf(m).MapKeys()
        result := make([]string, 0)
        for _, key := range keys </span><span class="cov0" title="0">{
                result = append(result, key.Interface().(string))
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Append appends map
func Append(a []string, m map[string]string) []string <span class="cov0" title="0">{
        for k, v := range m </span><span class="cov0" title="0">{
                a = append(a, KV2S(k, v))
        }</span>
        <span class="cov0" title="0">return a</span>
}

// KV2S generates string from key-value
func KV2S(k string, v interface{}) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s=%v", k, v)
}</span>

// M2A generates array from map
func M2A(m map[string]interface{}) []string <span class="cov0" title="0">{
        a := make([]string, 0)
        for k, v := range m </span><span class="cov0" title="0">{
                a = append(a, KV2S(k, v))
        }</span>
        <span class="cov0" title="0">return a</span>
}

// A2S generates string from array
func A2S(a []string) string <span class="cov0" title="0">{
        return strings.Join(a, " ")
}</span>

// M2S generates string from map
func M2S(m map[string]interface{}) string <span class="cov0" title="0">{
        return A2S(M2A(m))
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import "regexp"

// IsClientID checks clientID
func IsClientID(v string) bool <span class="cov8" title="1">{
        if v == "" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">r := regexp.MustCompile("^[0-9A-Za-z_-]{1,128}$")
        return r.MatchString(v)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "bytes"
        "math/rand"
        "strings"
)

// random string char fields
const randomStrChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"

// GenRandomStr generate specified length random string
func GenRandomStr(length int) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        strArray := strings.Split(randomStrChars, "")
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                buf.WriteString(strArray[rand.Intn(len(strArray))])
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import (
        "fmt"
        "sync"

        tb "gopkg.in/tomb.v2"
)

const (
        ini = int32(0)
        gos = int32(1)
)

// Tomb wraps tomb.Tomb
type Tomb struct {
        tb.Tomb
        s int32
        m sync.Mutex
}

// Gos goes functions
func (t *Tomb) Gos(fs ...func() error) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov8" title="1">{
                        err = fmt.Errorf("%v", p)
                }</span>
        }()
        <span class="cov8" title="1">t.m.Lock()
        defer t.m.Unlock()
        t.s = gos
        for _, f := range fs </span><span class="cov8" title="1">{
                t.Go(f)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Kill signal
func (t *Tomb) Kill() <span class="cov8" title="1">{
        t.Tomb.Kill(nil)
}</span>

// KillWith signal with error
func (t *Tomb) KillWith(err error) <span class="cov0" title="0">{
        t.Tomb.Kill(err)
}</span>

// Wait waits goroutines terminated
func (t *Tomb) Wait() (err error) <span class="cov8" title="1">{
        t.m.Lock()
        if t.s == gos </span><span class="cov8" title="1">{
                err = t.Tomb.Wait()
        }</span>
        <span class="cov8" title="1">t.m.Unlock()
        return</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package main

import (
        "fmt"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

// mo bridge module of mqtt servers
type mo struct {
        cfg Config
        rrs []*ruler
}

func main() <span class="cov0" title="0">{
        baetyl.Run(func(ctx baetyl.Context) error </span><span class="cov0" title="0">{
                var cfg Config
                err := ctx.LoadConfig(&amp;cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">remotes := make(map[string]Remote)
                for _, remote := range cfg.Remotes </span><span class="cov0" title="0">{
                        remotes[remote.Name] = remote
                }</span>
                <span class="cov0" title="0">rulers := make([]*ruler, 0)
                for _, rule := range cfg.Rules </span><span class="cov0" title="0">{
                        remote, ok := remotes[rule.Remote.Name]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("remote (%s) not found", rule.Remote.Name)
                        }</span>
                        <span class="cov0" title="0">rulers = append(rulers, create(rule, ctx.Config().Hub, remote.ClientInfo))</span>
                }
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        for _, ruler := range rulers </span><span class="cov0" title="0">{
                                ruler.close()
                        }</span>
                }()
                <span class="cov0" title="0">for _, ruler := range rulers </span><span class="cov0" title="0">{
                        err := ruler.start()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">ctx.Wait()
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package main

import (
        "github.com/256dpi/gomqtt/packet"
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/protocol/mqtt"
)

type ruler struct {
        rule   *Rule
        hub    *mqtt.Dispatcher
        remote *mqtt.Dispatcher
        log    logger.Logger
}

func create(rule Rule, hub, remote mqtt.ClientInfo) *ruler <span class="cov0" title="0">{
        defaults(&amp;rule, &amp;hub, &amp;remote)
        log := logger.WithField("rule", rule.Remote.Name)
        return &amp;ruler{
                rule:   &amp;rule,
                hub:    mqtt.NewDispatcher(hub, log),
                remote: mqtt.NewDispatcher(remote, log),
                log:    log,
        }
}</span>

func (rr *ruler) start() error <span class="cov0" title="0">{
        hubHandler := mqtt.NewHandlerWrapper(
                func(p *packet.Publish) error </span><span class="cov0" title="0">{
                        return rr.remote.Send(p)
                }</span>,
                func(p *packet.Puback) error <span class="cov0" title="0">{
                        return rr.remote.Send(p)
                }</span>,
                func(e error) <span class="cov0" title="0">{
                        rr.log.Errorln("hub error:", e.Error())
                }</span>,
        )
        <span class="cov0" title="0">if err := rr.hub.Start(hubHandler); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">remoteHandler := mqtt.NewHandlerWrapper(
                func(p *packet.Publish) error </span><span class="cov0" title="0">{
                        return rr.hub.Send(p)
                }</span>,
                func(p *packet.Puback) error <span class="cov0" title="0">{
                        return rr.hub.Send(p)
                }</span>,
                func(e error) <span class="cov0" title="0">{
                        rr.log.Errorln("remote error:", e.Error())
                }</span>,
        )
        <span class="cov0" title="0">if err := rr.remote.Start(remoteHandler); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rr *ruler) close() <span class="cov0" title="0">{
        rr.hub.Close()
        rr.remote.Close()
}</span>

func defaults(rule *Rule, hub, remote *mqtt.ClientInfo) <span class="cov8" title="1">{
        // set remote client id
        // rules[].remote.clientid &gt; remotes[].clientid &gt; rules[].remote.name
        if rule.Remote.ClientID != "" </span><span class="cov8" title="1">{
                remote.ClientID = rule.Remote.ClientID
        }</span> else<span class="cov8" title="1"> if remote.ClientID == "" </span><span class="cov8" title="1">{
                remote.ClientID = rule.Remote.Name
        }</span>
        // set hub client id
        // rules[].hub.clientid &gt; remote.ClientID
        <span class="cov8" title="1">if rule.Hub.ClientID != "" </span><span class="cov8" title="1">{
                hub.ClientID = rule.Hub.ClientID
        }</span> else<span class="cov8" title="1"> {
                hub.ClientID = remote.ClientID
        }</span>
        <span class="cov8" title="1">hub.Subscriptions = rule.Hub.Subscriptions
        remote.Subscriptions = rule.Remote.Subscriptions</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package logger

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/sirupsen/logrus"
        lumberjack "gopkg.in/natefinch/lumberjack.v2"
)

// Logger of module
type Logger interface {
        WithField(key string, value interface{}) Logger
        WithError(err error) Logger
        Debugf(format string, args ...interface{})
        Infof(format string, args ...interface{})
        Warnf(format string, args ...interface{})
        Errorf(format string, args ...interface{})
        Fatalf(format string, args ...interface{})
        Debugln(args ...interface{})
        Infoln(args ...interface{})
        Warnln(args ...interface{})
        Errorln(args ...interface{})
        Fatalln(args ...interface{})
}

type logger struct {
        entry *logrus.Entry
}

func (l *logger) WithField(key string, value interface{}) Logger <span class="cov0" title="0">{
        return &amp;logger{l.entry.WithField(key, value)}
}</span>

func (l *logger) WithError(err error) Logger <span class="cov0" title="0">{
        return &amp;logger{l.entry.WithError(err)}
}</span>

func (l *logger) Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.entry.Debugf(format, args...)
}</span>

func (l *logger) Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        l.entry.Infof(format, args...)
}</span>

func (l *logger) Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.entry.Warnf(format, args...)
}</span>

func (l *logger) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.entry.Errorf(format, args...)
}</span>

func (l *logger) Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.entry.Fatalf(format, args...)
}</span>

func (l *logger) Debugln(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Debugln(args...)
}</span>

func (l *logger) Infoln(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Infoln(args...)
}</span>

func (l *logger) Warnln(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Warnln(args...)
}</span>

func (l *logger) Errorln(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Errorln(args...)
}</span>

func (l *logger) Fatalln(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Fatalln(args...)
}</span>

// New create a new logger
func New(c LogInfo, fields ...string) Logger <span class="cov8" title="1">{
        logLevel, err := logrus.ParseLevel(c.Level)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to parse log level (%s), use default level (info)", c.Level)
                logLevel = logrus.InfoLevel
        }</span>

        <span class="cov8" title="1">var fileHook logrus.Hook
        if c.Path != "" </span><span class="cov0" title="0">{
                err = os.MkdirAll(filepath.Dir(c.Path), 0755)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "failed to create log directory: %s", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        fileHook, err = newFileHook(fileConfig{
                                Filename:   c.Path,
                                Formatter:  newFormatter(c.Format),
                                Level:      logLevel,
                                MaxAge:     c.Age.Max,  //days
                                MaxSize:    c.Size.Max, // megabytes
                                MaxBackups: c.Backup.Max,
                                Compress:   true,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "failed to create log file hook: %s", err.Error())
                        }</span>
                }
        }

        <span class="cov8" title="1">entry := logrus.NewEntry(logrus.New())
        entry.Level = logLevel
        entry.Logger.Level = logLevel
        entry.Logger.Formatter = newFormatter(c.Format)
        if fileHook != nil </span><span class="cov0" title="0">{
                entry.Logger.Hooks.Add(fileHook)
        }</span>
        <span class="cov8" title="1">logrusFields := logrus.Fields{}
        for index := 0; index &lt; len(fields)-1; index = index + 2 </span><span class="cov8" title="1">{
                logrusFields[fields[index]] = fields[index+1]
        }</span>
        <span class="cov8" title="1">return &amp;logger{entry.WithFields(logrusFields)}</span>
}

// InitLogger init global logger
func InitLogger(c LogInfo, fields ...string) Logger <span class="cov8" title="1">{
        Global = New(c, fields...)
        return Global
}</span>

type fileConfig struct {
        Filename   string
        MaxSize    int
        MaxAge     int
        MaxBackups int
        LocalTime  bool
        Compress   bool
        Level      logrus.Level
        Formatter  logrus.Formatter
}

type fileHook struct {
        config fileConfig
        writer io.Writer
}

func newFileHook(config fileConfig) (logrus.Hook, error) <span class="cov0" title="0">{
        hook := fileHook{
                config: config,
        }

        var zeroLevel logrus.Level
        if hook.config.Level == zeroLevel </span><span class="cov0" title="0">{
                hook.config.Level = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">var zeroFormatter logrus.Formatter
        if hook.config.Formatter == zeroFormatter </span><span class="cov0" title="0">{
                hook.config.Formatter = new(logrus.TextFormatter)
        }</span>

        <span class="cov0" title="0">hook.writer = &amp;lumberjack.Logger{
                Filename:   config.Filename,
                MaxSize:    config.MaxSize,
                MaxAge:     config.MaxAge,
                MaxBackups: config.MaxBackups,
                LocalTime:  config.LocalTime,
                Compress:   config.Compress,
        }

        return &amp;hook, nil</span>
}

// Levels Levels
func (hook *fileHook) Levels() []logrus.Level <span class="cov0" title="0">{
        return []logrus.Level{
                logrus.PanicLevel,
                logrus.FatalLevel,
                logrus.ErrorLevel,
                logrus.WarnLevel,
                logrus.InfoLevel,
                logrus.DebugLevel,
        }
}</span>

// Fire Fire
func (hook *fileHook) Fire(entry *logrus.Entry) (err error) <span class="cov0" title="0">{
        if hook.config.Level &lt; entry.Level </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">b, err := hook.config.Formatter.Format(entry)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">hook.writer.Write(b)
        return nil</span>
}

func newFormatter(format string) logrus.Formatter <span class="cov8" title="1">{
        var formatter logrus.Formatter
        if strings.ToLower(format) == "json" </span><span class="cov0" title="0">{
                formatter = &amp;logrus.JSONFormatter{}
        }</span> else<span class="cov8" title="1"> {
                formatter = &amp;logrus.TextFormatter{FullTimestamp: true, DisableColors: true}
        }</span>
        <span class="cov8" title="1">return formatter</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package logger

import (
        "os"

        "github.com/sirupsen/logrus"
)

// Global the global logger
var Global Logger

func init() <span class="cov8" title="1">{
        entry := logrus.NewEntry(logrus.New())
        entry.Level = logrus.InfoLevel
        entry.Logger.Out = os.Stdout
        entry.Logger.Level = logrus.InfoLevel
        entry.Logger.Formatter = newFormatter("text")
        Global = &amp;logger{entry}
}</span>

// WithField to global logger
func WithField(key string, value interface{}) Logger <span class="cov0" title="0">{
        return Global.WithField(key, value)
}</span>

// WithError to global logger
func WithError(err error) Logger <span class="cov0" title="0">{
        return Global.WithError(err)
}</span>

// Debugf to global logger
func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        Global.Debugf(format, args...)
}</span>

// Infof to global logger
func Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        Global.Infof(format, args...)
}</span>

// Warnf to global logger
func Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        Global.Warnf(format, args...)
}</span>

// Errorf to global logger
func Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        Global.Errorf(format, args...)
}</span>

// Fatalf to global logger
func Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        Global.Fatalf(format, args...)
}</span>

// Debugln to global logger
func Debugln(args ...interface{}) <span class="cov0" title="0">{
        Global.Debugln(args...)
}</span>

// Infoln to global logger
func Infoln(args ...interface{}) <span class="cov0" title="0">{
        Global.Infoln(args...)
}</span>

// Warnln to global logger
func Warnln(args ...interface{}) <span class="cov0" title="0">{
        Global.Warnln(args...)
}</span>

// Errorln to global logger
func Errorln(args ...interface{}) <span class="cov0" title="0">{
        Global.Errorln(args...)
}</span>

// Fatalln to global logger
func Fatalln(args ...interface{}) <span class="cov0" title="0">{
        Global.Fatalln(args)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package api

import (
        "net"
        "os"
        "path/filepath"
        "syscall"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/utils"
        grpc "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

// Conf the configuration of database
type Conf struct {
        Address string
}

// APIServer api server to handle grpc message
type APIServer struct {
        conf Conf
        svr  *grpc.Server
}

// NewAPIServer creates a new api server
func NewAPIServer(conf Conf) *APIServer <span class="cov8" title="1">{
        return &amp;APIServer{conf: conf, svr: grpc.NewServer()}
}</span>

// Start start api server
func (s *APIServer) Start() error <span class="cov8" title="1">{
        uri, err := utils.ParseURL(s.conf.Address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if uri.Scheme == "unix" </span><span class="cov8" title="1">{
                if err := syscall.Unlink(uri.Host); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf(err.Error())
                }</span>
                <span class="cov8" title="1">dir := filepath.Dir(uri.Host)
                err := os.MkdirAll(dir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to make directory %s : %s", dir, err.Error())
                }</span>
        }
        <span class="cov8" title="1">listener, err := net.Listen(uri.Scheme, uri.Host)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Infof("api server is listening at: %s", s.conf.Address)
        reflection.Register(s.svr)
        go func() </span><span class="cov8" title="1">{
                if err := s.svr.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        logger.Infof("api server shutdown: %v", err)
                }</span>
        }()
        <span class="cov8" title="1">return nil</span>
}

// Close closes api server
func (s *APIServer) Close() <span class="cov8" title="1">{
        if s.svr != nil </span><span class="cov8" title="1">{
                s.svr.GracefulStop()
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "strconv"
        "time"

        "github.com/baetyl/baetyl/master/engine"
        "github.com/baetyl/baetyl/protocol/http"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

// Master master interface
type Master interface {
        Auth(u, p string) bool

        // for system
        InspectSystem() ([]byte, error)
        UpdateSystem(trace, tp, target string) error

        // for instance
        ReportInstance(serviceName, instanceName string, partialStats engine.PartialStats) error
        StartInstance(serviceName, instanceName string, dynamicConfig map[string]string) error
        StopInstance(serviceName, instanceName string) error
}

// Server master api server
type Server struct {
        m Master
        s *http.Server
}

// New creates new api server
func New(c http.ServerInfo, m Master) (*Server, error) <span class="cov0" title="0">{
        svr, err := http.NewServer(c, m.Auth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s := &amp;Server{
                m: m,
                s: svr,
        }
        // v0, deprecated
        s.s.Handle(s.inspectSystemV0, "GET", "/system/inspect")
        s.s.Handle(s.updateSystem, "PUT", "/system/update")
        s.s.Handle(s.getAvailablePort, "GET", "/ports/available")
        s.s.Handle(s.startInstance, "PUT", "/services/{serviceName}/instances/{instanceName}/start")
        s.s.Handle(s.stopInstance, "PUT", "/services/{serviceName}/instances/{instanceName}/stop")

        // v1
        s.s.Handle(s.inspectSystem, "GET", "/v1/system/inspect")
        s.s.Handle(s.updateSystem, "PUT", "/v1/system/update")
        s.s.Handle(s.getAvailablePort, "GET", "/v1/ports/available")
        s.s.Handle(s.reportInstance, "PUT", "/v1/services/{serviceName}/instances/{instanceName}/report")
        s.s.Handle(s.startInstance, "PUT", "/v1/services/{serviceName}/instances/{instanceName}/start")
        s.s.Handle(s.stopInstance, "PUT", "/v1/services/{serviceName}/instances/{instanceName}/stop")
        return s, s.s.Start()</span>
}

// Close closes api server
func (s *Server) Close() error <span class="cov0" title="0">{
        return s.s.Close()
}</span>

func (s *Server) inspectSystem(_ http.Params, reqBody []byte) ([]byte, error) <span class="cov0" title="0">{
        return s.m.InspectSystem()
}</span>

/**********************************
agent version &lt; 0.1.4
{
        "file": "var/db/baetyl/app/V1"
}
***********************************/
/**********************************
agent version = 0.1.4
{
        "path": "var/db/baetyl/app/V1"
}
***********************************/
/**********************************
agent version &gt; 0.1.4
// master will write the ota log to 'var/db/baetyl/ota.log'
// agent will report the content of 'var/db/baetyl/ota.log' to cloud.
// update application
{
        "type": "APP"
        "path": "var/db/baetyl/ota/app/V1"
        "trace": "xxxx-xx-xx-xxxxxxxx"
}
// update master
{
        "type": "MST"
        "path": "var/db/baetyl/ota/mst/0.1.6/baetyl"
        "trace": "xxxx-xx-xx-xxxxxxxx"
}
***********************************/
func (s *Server) updateSystem(_ http.Params, reqBody []byte) ([]byte, error) <span class="cov0" title="0">{
        if reqBody == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request body invalid")
        }</span>
        <span class="cov0" title="0">args := make(map[string]string)
        err := json.Unmarshal(reqBody, &amp;args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tp, ok := args["type"]
        if !ok </span><span class="cov0" title="0">{
                tp = "APP"
        }</span>
        <span class="cov0" title="0">target, ok := args["path"]
        if !ok </span><span class="cov0" title="0">{
                // backward compatibility, agent version &lt; 0.1.4
                target = args["file"]
        }</span>
        <span class="cov0" title="0">trace, _ := args["trace"]
        go s.m.UpdateSystem(trace, tp, target)
        return nil, nil</span>
}

func (s *Server) getAvailablePort(_ http.Params, reqBody []byte) ([]byte, error) <span class="cov0" title="0">{
        port, err := utils.GetAvailablePort("127.0.0.1")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">res := make(map[string]string)
        res["port"] = strconv.Itoa(port)
        return json.Marshal(res)</span>
}

func (s *Server) reportInstance(params http.Params, reqBody []byte) ([]byte, error) <span class="cov0" title="0">{
        if reqBody == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request body invalid")
        }</span>
        <span class="cov0" title="0">serviceName, ok := params["serviceName"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request params invalid, missing service name")
        }</span>
        <span class="cov0" title="0">instanceName, ok := params["instanceName"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request params invalid, missing instance name")
        }</span>
        <span class="cov0" title="0">stats := make(map[string]interface{})
        err := json.Unmarshal(reqBody, &amp;stats)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nil, s.m.ReportInstance(serviceName, instanceName, stats)</span>
}

func (s *Server) startInstance(params http.Params, reqBody []byte) ([]byte, error) <span class="cov0" title="0">{
        if reqBody == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request body invalid")
        }</span>
        <span class="cov0" title="0">serviceName, ok := params["serviceName"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request params invalid, missing service name")
        }</span>
        <span class="cov0" title="0">instanceName, ok := params["instanceName"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request params invalid, missing instance name")
        }</span>
        <span class="cov0" title="0">dynamicConfig := make(map[string]string)
        err := json.Unmarshal(reqBody, &amp;dynamicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nil, s.m.StartInstance(serviceName, instanceName, dynamicConfig)</span>
}

func (s *Server) stopInstance(params http.Params, _ []byte) ([]byte, error) <span class="cov0" title="0">{
        serviceName, ok := params["serviceName"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request params invalid, missing service name")
        }</span>
        <span class="cov0" title="0">instanceName, ok := params["instanceName"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request params invalid, missing instance name")
        }</span>
        <span class="cov0" title="0">return nil, s.m.StopInstance(serviceName, instanceName)</span>
}

// deprecated

func (s *Server) inspectSystemV0(_ http.Params, reqBody []byte) ([]byte, error) <span class="cov0" title="0">{
        data, err := s.m.InspectSystem()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">v1 := &amp;baetyl.Inspect{}
        err = json.Unmarshal(data, v1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return toInspectSystemV0(v1)</span>
}

func toInspectSystemV0(v1 *baetyl.Inspect) ([]byte, error) <span class="cov0" title="0">{
        v0 := &amp;InspectV0{
                Time:     v1.Time,
                Error:    v1.Error,
                Software: v1.Software,
                Services: v1.Services,
                Volumes:  v1.Volumes,
        }
        v0.Hardware.HostInfo = v1.Hardware.HostInfo
        v0.Hardware.DiskInfo = v1.Hardware.DiskInfo
        v0.Hardware.NetInfo = v1.Hardware.NetInfo
        v0.Hardware.MemInfo = v1.Hardware.MemInfo
        v0.Hardware.CPUInfo = &amp;CPUInfoV0{}
        v0.Hardware.CPUInfo.UsedPercent = v1.Hardware.CPUInfo.UsedPercent
        v0.Hardware.GPUInfo = []GPUInfoV0{}
        for _, v := range v1.Hardware.GPUInfo.GPUs </span><span class="cov0" title="0">{
                v0.Hardware.GPUInfo = append(v0.Hardware.GPUInfo, GPUInfoV0{
                        ID:    v.Index,
                        Model: v.Model,
                        Mem: utils.MemInfo{
                                Total:       v.MemTotal,
                                Free:        v.MemFree,
                                UsedPercent: v.MemUsedPercent,
                        },
                })
        }</span>
        <span class="cov0" title="0">return json.Marshal(v0)</span>
}

// InspectV0 all baetyl information and status inspected
type InspectV0 struct {
        // exception information
        Error string `json:"error,omitempty"`
        // inspect time
        Time time.Time `json:"time,omitempty"`
        // software information
        Software baetyl.Software `json:"software,omitempty"`
        // hardware information
        Hardware HardwareV0 `json:"hardware,omitempty"`
        // service information, including service name, instance running status, etc.
        Services baetyl.Services `json:"services,omitempty"`
        // storage volume information, including name and version
        Volumes baetyl.Volumes `json:"volumes,omitempty"`
}

// HardwareV0 hardware information
type HardwareV0 struct {
        // host information
        HostInfo *utils.HostInfo `json:"host_stats,omitempty"`
        // net information of host
        NetInfo *utils.NetInfo `json:"net_stats,omitempty"`
        // memory usage information of host
        MemInfo *utils.MemInfo `json:"mem_stats,omitempty"`
        // CPU usage information of host
        CPUInfo *CPUInfoV0 `json:"cpu_stats,omitempty"`
        // disk usage information of host
        DiskInfo *utils.DiskInfo `json:"disk_stats,omitempty"`
        // CPU usage information of host
        GPUInfo []GPUInfoV0 `json:"gpu_stats,omitempty"`
}

// CPUInfoV0 CPU information
type CPUInfoV0 struct {
        UsedPercent float64 `json:"used_percent,omitempty"`
}

// GPUInfoV0 GPU information
type GPUInfoV0 struct {
        ID    string        `json:"id,omitempty"`
        Model string        `json:"model,omitempty"`
        Mem   utils.MemInfo `json:"mem_stat,omitempty"`
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package api

import (
        "context"
        "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/golang/protobuf/ptypes/empty"
)

// KV kv interface
type KV interface {
        Set(kv *baetyl.KV) error
        Get(key []byte) (*baetyl.KV, error)
        Del(key []byte) error
        List(prefix []byte) (*baetyl.KVs, error)
}

// KVService kv server
type KVService struct {
        kv KV
}

// NewKVService new kv service
func NewKVService(kv KV) baetyl.KVServiceServer <span class="cov8" title="1">{
        return &amp;KVService{kv: kv}
}</span>

// Set set kv
func (s *KVService) Set(ctx context.Context, kv *baetyl.KV) (*empty.Empty, error) <span class="cov8" title="1">{
        return new(empty.Empty), s.kv.Set(kv)
}</span>

// Get get kv
func (s *KVService) Get(ctx context.Context, kv *baetyl.KV) (*baetyl.KV, error) <span class="cov8" title="1">{
        return s.kv.Get(kv.Key)
}</span>

// Del del kv
func (s *KVService) Del(ctx context.Context, kv *baetyl.KV) (*empty.Empty, error) <span class="cov8" title="1">{
        return new(empty.Empty), s.kv.Del(kv.Key)
}</span>

// List list kvs with prefix
func (s *KVService) List(ctx context.Context, kv *baetyl.KV) (*baetyl.KVs, error) <span class="cov8" title="1">{
        return s.kv.List(kv.Key)
}</span>

// RegisterKVService register kv service
func (s *APIServer) RegisterKVService(server baetyl.KVServiceServer) <span class="cov8" title="1">{
        baetyl.RegisterKVServiceServer(s.svr, server)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package master

import (
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
)

// Validate validates config
// TODO: it is not good idea to set envs here
func (c *Config) Validate() error <span class="cov0" title="0">{
        addr := c.Server.Address
        url, err := utils.ParseURL(addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse address of server: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if runtime.GOOS != "linux" &amp;&amp; url.Scheme == "unix" </span><span class="cov0" title="0">{
                return fmt.Errorf("unix domain socket only support on linux, please to use tcp socket")
        }</span>
        <span class="cov0" title="0">if url.Scheme != "unix" &amp;&amp; url.Scheme != "tcp" </span><span class="cov0" title="0">{
                return fmt.Errorf("only support unix domian socket or tcp socket")
        }</span>

        // address in container
        <span class="cov0" title="0">if url.Scheme == "unix" </span><span class="cov0" title="0">{
                sock, err := filepath.Abs(url.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = os.MkdirAll(filepath.Dir(sock), 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">utils.SetEnv(baetyl.EnvKeyMasterAPISocket, sock)
                unixPrefix := "unix://"
                if c.Mode != "native" </span><span class="cov0" title="0">{
                        unixPrefix += "/"
                }</span>
                <span class="cov0" title="0">utils.SetEnv(baetyl.EnvKeyMasterAPIAddress, unixPrefix+baetyl.DefaultSockFile)
                // TODO: remove, backward compatibility
                utils.SetEnv(baetyl.EnvMasterAPIKey, unixPrefix+baetyl.DefaultSockFile)</span>
        } else<span class="cov0" title="0"> {
                if c.Mode != "native" </span><span class="cov0" title="0">{
                        parts := strings.SplitN(url.Host, ":", 2)
                        addr = fmt.Sprintf("tcp://host.docker.internal:%s", parts[1])
                }</span>
                <span class="cov0" title="0">utils.SetEnv(baetyl.EnvKeyMasterAPIAddress, addr)
                // TODO: remove, backward compatibility
                utils.SetEnv(baetyl.EnvMasterAPIKey, addr)</span>
        }

        <span class="cov0" title="0">if c.SNFile != "" </span><span class="cov0" title="0">{
                snByte, err := ioutil.ReadFile(c.SNFile)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("failed to load SN file: %s", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        sn := strings.TrimSpace(string(snByte))
                        utils.SetEnv(baetyl.EnvKeyHostSN, sn)
                }</span>
        }

        <span class="cov0" title="0">utils.SetEnv(baetyl.EnvKeyMasterAPIVersion, "v1")
        utils.SetEnv(baetyl.EnvKeyHostOS, runtime.GOOS)
        utils.SetEnv(baetyl.EnvKeyServiceMode, c.Mode)
        // TODO: remove, backward compatibility
        utils.SetEnv(baetyl.EnvMasterAPIVersionKey, "v1")
        utils.SetEnv(baetyl.EnvHostOSKey, runtime.GOOS)
        utils.SetEnv(baetyl.EnvRunningModeKey, c.Mode)

        hi := utils.GetHostInfo()
        if hi.HostID != "" </span><span class="cov0" title="0">{
                utils.SetEnv(baetyl.EnvKeyHostID, hi.HostID)
                // TODO: remove, backward compatibility
                utils.SetEnv(baetyl.EnvHostID, hi.HostID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package database

import (
        "errors"
        "io"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

// Factories of database
var Factories = map[string]func(conf Conf) (DB, error){}

// DB the backend database
type DB interface {
        Conf() Conf

        Set(kv *baetyl.KV) error
        Get(key []byte) (*baetyl.KV, error)
        Del(key []byte) error
        List(prefix []byte) (*baetyl.KVs, error)

        io.Closer
}

// Conf the configuration of database
type Conf struct {
        Driver string
        Source string
}

// New KV database by given name
func New(conf Conf) (DB, error) <span class="cov8" title="1">{
        if f, ok := Factories[conf.Driver]; ok </span><span class="cov8" title="1">{
                return f(conf)
        }</span>
        <span class="cov8" title="1">return nil, errors.New("no such kind database")</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package database

import (
        "database/sql"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

var placeholderValue = "(?)"
var placeholderKeyValue = "(?,?)"
var schema = map[string][]string{
        "sqlite3": []string{
                `CREATE TABLE IF NOT EXISTS kv (
                        key TEXT PRIMARY KEY,
                        value BLOB,
                        ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP) WITHOUT ROWID`,
        },
}

func init() <span class="cov8" title="1">{
        Factories["sqlite3"] = _new
}</span>

// sqldb the backend SQL DB to persist values
type sqldb struct {
        *sql.DB
        conf Conf
}

// New creates a new sql database
func _new(conf Conf) (DB, error) <span class="cov8" title="1">{
        db, err := sql.Open(conf.Driver, conf.Source)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, v := range schema[conf.Driver] </span><span class="cov8" title="1">{
                if _, err = db.Exec(v); err != nil </span><span class="cov0" title="0">{
                        db.Close()
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return &amp;sqldb{DB: db, conf: conf}, nil</span>
}

// Conf returns the configuration
func (d *sqldb) Conf() Conf <span class="cov8" title="1">{
        return d.conf
}</span>

// Set put key and value into SQL DB
func (d *sqldb) Set(kv *baetyl.KV) error <span class="cov8" title="1">{
        stmt, err := d.Prepare("insert into kv(key,value) values (?,?) on conflict(key) do update set value=excluded.value")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        _, err = stmt.Exec(kv.Key, kv.Value)
        return err</span>
}

// Get gets value by key from SQL DB
func (d *sqldb) Get(key []byte) (*baetyl.KV, error) <span class="cov8" title="1">{
        rows, err := d.Query("select value from kv where key=?", key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        kv := &amp;baetyl.KV{Key: key}
        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;kv.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return kv, nil</span>
        }
        <span class="cov8" title="1">return kv, nil</span>
}

// Del deletes key and value from SQL DB
func (d *sqldb) Del(key []byte) error <span class="cov8" title="1">{
        _, err := d.Exec("delete from kv where key=?", key)
        return err
}</span>

// List list kvs with the prefix
func (d *sqldb) List(prefix []byte) (*baetyl.KVs, error) <span class="cov8" title="1">{
        rows, err := d.Query("select key, value from kv where key like ?", append(prefix, byte('%')))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        kvs := &amp;baetyl.KVs{}
        for rows.Next() </span><span class="cov8" title="1">{
                kv := new(baetyl.KV)
                err = rows.Scan(&amp;kv.Key, &amp;kv.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">kvs.Kvs = append(kvs.Kvs, kv)</span>
        }
        <span class="cov8" title="1">return kvs, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package docker

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "reflect"
        "runtime"
        "time"

        "github.com/baetyl/baetyl/master/engine"
        "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/filters"
        "github.com/docker/docker/api/types/network"
        volumetypes "github.com/docker/docker/api/types/volume"
        "github.com/docker/docker/pkg/stdcopy"
)

const defaultNetworkName = "baetyl"

// ComposeNetworks alias of map[string]baetyl.ComposeNetwork
type ComposeNetworks map[string]baetyl.ComposeNetwork

// ComposeVolumes alias of map[string]baetyl.ComposeVolume
type ComposeVolumes map[string]baetyl.ComposeVolume

type containerConfigs struct {
        config        container.Config
        hostConfig    container.HostConfig
        networkConfig network.NetworkingConfig
}

func (e *dockerEngine) initVolumes(volumeInfos ComposeVolumes) error <span class="cov0" title="0">{
        ctx := context.Background()
        args := filters.NewArgs()
        args.Add("label", "baetyl=baetyl")
        vlBody, err := e.cli.VolumeList(ctx, args)
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Errorf("failed to list volumes")
        }</span>
        <span class="cov0" title="0">if vlBody.Warnings != nil </span><span class="cov0" title="0">{
                e.log.Warnln(vlBody.Warnings)
        }</span>
        <span class="cov0" title="0">vsMap := map[string]*types.Volume{}
        for _, v := range vlBody.Volumes </span><span class="cov0" title="0">{
                vsMap[v.Name] = v
        }</span>
        <span class="cov0" title="0">for name, volumeInfo := range volumeInfos </span><span class="cov0" title="0">{
                volumeInfo.Labels["baetyl"] = "baetyl"
                if vl, ok := vsMap[name]; ok </span><span class="cov0" title="0">{
                        t := baetyl.ComposeVolume{
                                Driver:     vl.Driver,
                                DriverOpts: vl.Options,
                                Labels:     vl.Labels,
                        }
                        // it is recommanded to add version info into volume name to avoid duplicate name conflict
                        if !reflect.DeepEqual(t, volumeInfo) </span><span class="cov0" title="0">{
                                return fmt.Errorf("volume (%s) with different properties exists", name)
                        }</span>
                        <span class="cov0" title="0">e.log.Debugf("volume %s already exists", name)
                        continue</span>
                }
                <span class="cov0" title="0">volumeParams := volumetypes.VolumeCreateBody{
                        Name:       name,
                        Driver:     volumeInfo.Driver,
                        DriverOpts: volumeInfo.DriverOpts,
                        Labels:     volumeInfo.Labels,
                }
                _, err := e.cli.VolumeCreate(ctx, volumeParams)
                if err != nil </span><span class="cov0" title="0">{
                        e.log.WithError(err).Errorf("failed to create volume %s", name)
                }</span>
                <span class="cov0" title="0">e.log.Debugf("volume %s created", name)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *dockerEngine) initNetworks(networks ComposeNetworks) error <span class="cov8" title="1">{
        ctx := context.Background()
        args := filters.NewArgs()
        args.Add("type", "custom")
        args.Add("label", "baetyl=baetyl")
        nws, err := e.cli.NetworkList(ctx, types.NetworkListOptions{Filters: args})
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Errorf("failed to list custom networks")
                return err
        }</span>
        <span class="cov8" title="1">nwMap := map[string]types.NetworkResource{}
        for _, val := range nws </span><span class="cov8" title="1">{
                nwMap[val.Name] = val
        }</span>
        <span class="cov8" title="1">if networks == nil </span><span class="cov8" title="1">{
                networks = make(map[string]baetyl.ComposeNetwork)
        }</span>
        // add baetyl as default network
        <span class="cov8" title="1">networks[defaultNetworkName] = baetyl.ComposeNetwork{
                Driver:     "bridge",
                DriverOpts: make(map[string]string),
                Labels:     make(map[string]string),
        }
        for networkName, network := range networks </span><span class="cov8" title="1">{
                network.Labels["baetyl"] = "baetyl"
                if nw, ok := nwMap[networkName]; ok </span><span class="cov8" title="1">{
                        t := baetyl.ComposeNetwork{
                                Driver:     nw.Driver,
                                DriverOpts: nw.Options,
                                Labels:     nw.Labels,
                        }
                        // it is recommanded to add version info into network name to avoid duplicate name conflict
                        if !reflect.DeepEqual(t, network) </span><span class="cov0" title="0">{
                                e.log.Warnf("network (%s:%s) exists with different properties", nw.ID[:12], networkName)
                        }</span>
                        <span class="cov8" title="1">e.networks[networkName] = nw.ID
                        e.log.Debugf("network (%s:%s) exists", nw.ID[:12], networkName)</span>
                } else<span class="cov0" title="0"> {
                        networkParams := types.NetworkCreate{
                                Driver:  network.Driver,
                                Options: network.DriverOpts,
                                Scope:   "local",
                                Labels:  network.Labels,
                        }
                        nw, err := e.cli.NetworkCreate(ctx, networkName, networkParams)
                        if err != nil </span><span class="cov0" title="0">{
                                e.log.WithError(err).Errorf("failed to create network (%s)", networkName)
                                return err
                        }</span>
                        <span class="cov0" title="0">if nw.Warning != "" </span><span class="cov0" title="0">{
                                e.log.Warnf(nw.Warning)
                        }</span>
                        <span class="cov0" title="0">e.networks[networkName] = nw.ID
                        e.log.Debugf("network (%s:%s) created", e.networks[networkName][:12], networkName)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (e *dockerEngine) connectNetworks(endpointSettings map[string]*network.EndpointSettings, containerID string) error <span class="cov0" title="0">{
        ctx := context.Background()
        for _, endpointSetting := range endpointSettings </span><span class="cov0" title="0">{
                err := e.cli.NetworkConnect(ctx, endpointSetting.NetworkID, containerID, endpointSetting)
                if err != nil </span><span class="cov0" title="0">{
                        e.log.WithError(err).Errorf("can not connect instance %s to network %s", containerID[:12], endpointSetting.NetworkID[:12])
                        return err
                }</span>
                <span class="cov0" title="0">e.log.Debugf("connect instance %s to network %s", containerID[:12], endpointSetting.NetworkID[:12])</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (e *dockerEngine) pullImage(name string) error <span class="cov0" title="0">{
        out, err := e.cli.ImagePull(context.Background(), name, types.ImagePullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to pull image (%s)", name)
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()
        io.Copy(ioutil.Discard, out)
        e.log.Debugf("image (%s) pulled", name)
        return nil</span>
}

func (e *dockerEngine) startContainer(name string, cfg containerConfigs) (string, error) <span class="cov0" title="0">{
        ctx := context.Background()
        container, err := e.cli.ContainerCreate(ctx, &amp;cfg.config, &amp;cfg.hostConfig, nil, name)
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to create container (%s)", name)
                return "", err
        }</span>
        <span class="cov0" title="0">if len(cfg.networkConfig.EndpointsConfig) &gt; 0 </span><span class="cov0" title="0">{
                err = e.connectNetworks(cfg.networkConfig.EndpointsConfig, container.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">err = e.cli.ContainerStart(ctx, container.ID, types.ContainerStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to start container (%s:%s)", container.ID[:12], name)
                return "", err
        }</span>
        <span class="cov0" title="0">e.log.Debugf("container (%s:%s) started", container.ID[:12], name)
        return container.ID, nil</span>
}

func (e *dockerEngine) restartContainer(cid string) error <span class="cov0" title="0">{
        ctx := context.Background()
        err := e.cli.ContainerRestart(ctx, cid, &amp;e.grace)
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to restart container (%s)", cid[:12])
        }</span> else<span class="cov0" title="0"> {
                e.log.Debugf("container (%s) restarted", cid[:12])
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (e *dockerEngine) waitContainer(cid string) error <span class="cov0" title="0">{
        t := time.Now()
        ctx := context.Background()
        statusChan, errChan := e.cli.ContainerWait(ctx, cid, container.WaitConditionNotRunning)
        select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                e.logsContainer(cid, t)
                e.log.WithError(err).Warnf("failed to wait container (%s)", cid[:12])
                return err</span>
        case status := &lt;-statusChan:<span class="cov0" title="0">
                e.logsContainer(cid, t)
                e.log.Debugf("container (%s) exit status: %v", cid[:12], status)
                if status.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(status.Error.Message)
                }</span> else<span class="cov0" title="0"> if status.StatusCode != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("container exit code: %d", status.StatusCode)
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
}

func (e *dockerEngine) stopContainer(cid string) error <span class="cov0" title="0">{
        e.log.Debugf("container (%s) is stopping", cid[:12])

        ctx := context.Background()
        err := e.cli.ContainerStop(ctx, cid, &amp;e.grace)
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to stop container (%s)", cid[:12])
                return err
        }</span>
        <span class="cov0" title="0">statusChan, errChan := e.cli.ContainerWait(ctx, cid, container.WaitConditionNotRunning)
        select </span>{
        case &lt;-time.After(e.grace):<span class="cov0" title="0">
                // e.cli.ContainerKill(ctx, cid, "9")
                e.log.Warnf("timed out to wait container (%s)", cid[:12])
                return fmt.Errorf("timed out to wait container (%s)", cid[:12])</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                e.log.WithError(err).Warnf("failed to wait container (%s)", cid[:12])
                return err</span>
        case status := &lt;-statusChan:<span class="cov0" title="0">
                e.log.Debugf("container (%s) exit status: %v", cid[:12], status)
                return nil</span>
        }
}

func (e *dockerEngine) removeContainer(cid string) error <span class="cov0" title="0">{
        ctx := context.Background()
        err := e.cli.ContainerRemove(ctx, cid, types.ContainerRemoveOptions{Force: true})
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to remove container (%s)", cid[:12])
        }</span> else<span class="cov0" title="0"> {
                e.log.Debugf("container (%s) removed", cid[:12])
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (e *dockerEngine) removeContainerByName(name string) error <span class="cov0" title="0">{
        ctx := context.Background()
        args := filters.NewArgs()
        args.Add("name", name)
        containers, err := e.cli.ContainerList(ctx, types.ContainerListOptions{Filters: args, All: true})
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to list container (%s)", name)
                return err
        }</span>
        <span class="cov0" title="0">if len(containers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err = e.cli.ContainerRemove(ctx, containers[0].ID, types.ContainerRemoveOptions{Force: true})
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to remove container (%s:%s)", containers[0].ID[:12], name)
        }</span> else<span class="cov0" title="0"> {
                e.log.Debugf("container (%s:%s) removed", containers[0].ID[:12], name)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (e *dockerEngine) statsContainer(cid string) engine.PartialStats <span class="cov0" title="0">{
        t := time.Now().UTC()
        ctx := context.Background()
        sresp, err := e.cli.ContainerStats(ctx, cid, false)
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to stats container (%s)", cid[:12])
                return engine.PartialStats{"error": err.Error()}
        }</span>
        <span class="cov0" title="0">defer sresp.Body.Close()
        var tstats types.Stats
        err = json.NewDecoder(sresp.Body).Decode(&amp;tstats)
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to read stats response of container (%s)", cid[:12])
                return engine.PartialStats{"error": err.Error()}
        }</span>

        <span class="cov0" title="0">if tstats.Read.IsZero() || tstats.PreRead.IsZero() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var cpuPercent = 0.0
        if runtime.GOOS != "windows" </span><span class="cov0" title="0">{
                cpuDelta := float64(tstats.CPUStats.CPUUsage.TotalUsage - tstats.PreCPUStats.CPUUsage.TotalUsage)
                systemDelta := float64(tstats.CPUStats.SystemUsage - tstats.PreCPUStats.SystemUsage)
                cpuPercent = (cpuDelta / systemDelta) * float64(len(tstats.CPUStats.CPUUsage.PercpuUsage))
        }</span> else<span class="cov0" title="0"> {
                possIntervals := uint64(tstats.Read.Sub(tstats.PreRead).Nanoseconds()) / 100 * uint64(tstats.NumProcs)
                intervalsUsed := tstats.CPUStats.CPUUsage.TotalUsage - tstats.PreCPUStats.CPUUsage.TotalUsage
                if possIntervals &gt; 0 </span><span class="cov0" title="0">{
                        cpuPercent = float64(intervalsUsed) / float64(possIntervals)
                }</span>
        }

        <span class="cov0" title="0">UsedPercent := 0.0
        if tstats.MemoryStats.Limit &gt; 0 </span><span class="cov0" title="0">{
                UsedPercent = float64(tstats.MemoryStats.Usage) / float64(tstats.MemoryStats.Limit)
        }</span>

        <span class="cov0" title="0">return engine.PartialStats{
                "cpu_stats": utils.CPUInfo{
                        Time:        t,
                        UsedPercent: cpuPercent,
                },
                "mem_stats": utils.MemInfo{
                        Time:        t,
                        Total:       tstats.MemoryStats.Limit,
                        Used:        tstats.MemoryStats.Usage,
                        UsedPercent: UsedPercent,
                },
        }</span>
}

func (e *dockerEngine) logsContainer(cid string, since time.Time) error <span class="cov0" title="0">{
        ctx := context.Background()
        r, err := e.cli.ContainerLogs(ctx, cid, types.ContainerLogsOptions{
                ShowStdout: false,
                ShowStderr: true, // only read error message
                Since:      since.Format("2006-01-02T15:04:05"),
        })
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to log container (%s)", cid[:12])
                return err
        }</span>
        <span class="cov0" title="0">defer r.Close()
        scanner := bufio.NewScanner(r)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Bytes()
                if len(line) &lt;= 8 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">switch stdcopy.StdType(line[0]) </span>{
                case stdcopy.Stderr:<span class="cov0" title="0">
                        e.log.Errorf("container (%s) %s", cid[:12], string(line[8:]))</span>
                case stdcopy.Stdin, stdcopy.Stdout:<span class="cov0" title="0">
                        e.log.Debugf("container (%s) %s", cid[:12], string(line[8:]))</span>
                default:<span class="cov0" title="0">
                        e.log.Debugf("container (%s) %s", cid[:12], string(line))</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package docker

import (
        "fmt"
        "path"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/network"
        "github.com/docker/docker/client"
        "github.com/docker/docker/pkg/sysinfo"
        "github.com/docker/go-connections/nat"
        cmap "github.com/orcaman/concurrent-map"
)

// NAME ot docker engine
const NAME = "docker"

func init() <span class="cov8" title="1">{
        engine.Factories()[NAME] = New
}</span>

// New docker engine
func New(stats engine.InfoStats, opts engine.Options) (engine.Engine, error) <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithVersion(opts.APIVersion))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">e := &amp;dockerEngine{
                InfoStats: stats,
                cli:       cli,
                networks:  make(map[string]string),
                pwd:       opts.Pwd,
                grace:     opts.Grace,
                log:       logger.WithField("engine", NAME),
        }
        return e, nil</span>
}

type dockerEngine struct {
        engine.InfoStats
        cli      *client.Client
        networks map[string]string
        pwd      string // work directory
        grace    time.Duration
        tomb     utils.Tomb
        log      logger.Logger
}

func (e *dockerEngine) Name() string <span class="cov0" title="0">{
        return NAME
}</span>

// Recover recover old services when master restart
func (e *dockerEngine) Recover() <span class="cov0" title="0">{
        // clean old services in docker mode
        e.clean()
}</span>

// Prepare prepares all images
func (e *dockerEngine) Prepare(cfg baetyl.ComposeAppConfig) <span class="cov0" title="0">{
        var wg sync.WaitGroup
        ss := cfg.Services
        for _, s := range ss </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(i string, w *sync.WaitGroup) </span><span class="cov0" title="0">{
                        defer w.Done()
                        e.pullImage(i)
                }</span>(s.Image, &amp;wg)
        }
        <span class="cov0" title="0">wg.Add(1)
        go func(nw map[string]baetyl.ComposeNetwork, w *sync.WaitGroup) </span><span class="cov0" title="0">{
                defer w.Done()
                e.initNetworks(nw)
        }</span>(cfg.Networks, &amp;wg)

        <span class="cov0" title="0">wg.Add(1)
        go func(vs map[string]baetyl.ComposeVolume, w *sync.WaitGroup) </span><span class="cov0" title="0">{
                defer w.Done()
                e.initVolumes(vs)
        }</span>(cfg.Volumes, &amp;wg)
        <span class="cov0" title="0">wg.Wait()</span>
}

// Clean recover all old instances
func (e *dockerEngine) clean() <span class="cov0" title="0">{
        sss := map[string]map[string]attribute{}
        if e.LoadStats(&amp;sss) </span><span class="cov0" title="0">{
                for sn, instances := range sss </span><span class="cov0" title="0">{
                        for in, instance := range instances </span><span class="cov0" title="0">{
                                id := instance.Container.ID
                                if id == "" </span><span class="cov0" title="0">{
                                        e.log.Warnf("[%s][%s] container id not found, maybe running mode changed", sn, in)
                                        continue</span>
                                }
                                <span class="cov0" title="0">err := e.stopContainer(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        e.log.Warnf("[%s][%s] failed to stop the old container (%s)", sn, in, id[:12])
                                }</span> else<span class="cov0" title="0"> {
                                        e.log.Infof("[%s][%s] old container (%s) stopped", sn, in, id[:12])
                                }</span>
                                <span class="cov0" title="0">err = e.removeContainer(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        e.log.Warnf("[%s][%s] failed to remove the old container (%s)", sn, in, id[:12])
                                }</span> else<span class="cov0" title="0"> {
                                        e.log.Infof("[%s][%s] old container (%s) removed", sn, in, id[:12])
                                }</span>
                        }
                }
        }
}

// Run a new service
func (e *dockerEngine) Run(name string, cfg baetyl.ComposeService, vs map[string]baetyl.ComposeVolume) (engine.Service, error) <span class="cov0" title="0">{
        if runtime.GOOS == "linux" &amp;&amp; cfg.Resources.CPU.Cpus &gt; 0 </span><span class="cov0" title="0">{
                sysInfo := sysinfo.New(true)
                if !sysInfo.CPUCfsPeriod || !sysInfo.CPUCfsQuota </span><span class="cov0" title="0">{
                        e.log.Warnf("configuration 'resources.cpu.cpus' of service (%s) is ignored, because host kernel does not support CPU cfs period/quota or the cgroup is not mounted.", name)
                        cfg.Resources.CPU.Cpus = 0
                }</span>
        }
        <span class="cov0" title="0">binds := make([]string, 0)
        volumes := map[string]struct{}{}
        for _, m := range cfg.Volumes </span><span class="cov0" title="0">{
                if _, ok := vs[m.Source]; !ok </span><span class="cov0" title="0">{
                        if m.Type == "volume" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("volume '%s' not found", m.Source)
                        }</span>
                        // for preventing path escape
                        <span class="cov0" title="0">m.Source = path.Join(e.pwd, path.Join("/", m.Source))</span>
                }
                <span class="cov0" title="0">f := fmtVolumeRW
                if m.ReadOnly </span><span class="cov0" title="0">{
                        f = fmtVolumeRO
                }</span>
                <span class="cov0" title="0">binds = append(binds, fmt.Sprintf(f, m.Source, path.Clean(m.Target)))
                volumes[m.Target] = struct{}{}</span>
        }

        <span class="cov0" title="0">sock := utils.GetEnv(baetyl.EnvKeyMasterAPISocket)
        if sock != "" </span><span class="cov0" title="0">{
                binds = append(binds, fmt.Sprintf(fmtVolumeRO, sock, path.Join("/", baetyl.DefaultSockFile)))
        }</span>
        <span class="cov0" title="0">exposedPorts, portBindings, err := nat.ParsePortSpecs(cfg.Ports)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">deviceBindings, err := e.parseDeviceSpecs(cfg.Devices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var params containerConfigs
        params.config = container.Config{
                Image:        strings.TrimSpace(cfg.Image),
                Env:          utils.AppendEnv(cfg.Environment.Envs, false),
                Cmd:          cfg.Command.Cmd,
                Hostname:     cfg.Hostname,
                ExposedPorts: exposedPorts,
                Volumes:      volumes,
                Labels:       map[string]string{"baetyl": "baetyl", "service": name},
        }
        endpointsConfig := map[string]*network.EndpointSettings{}
        if cfg.NetworkMode != "" </span><span class="cov0" title="0">{
                if len(cfg.Networks.ServiceNetworks) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("'network_mode' and 'networks' cannot be combined")
                }</span>
        } else<span class="cov0" title="0"> {
                for networkName, networkInfo := range cfg.Networks.ServiceNetworks </span><span class="cov0" title="0">{
                        cfg.NetworkMode = networkName
                        endpointsConfig[networkName] = &amp;network.EndpointSettings{
                                NetworkID: e.networks[networkName],
                                Aliases:   networkInfo.Aliases,
                                IPAddress: networkInfo.Ipv4Address,
                        }
                }</span>
                <span class="cov0" title="0">if cfg.NetworkMode == "" </span><span class="cov0" title="0">{
                        cfg.NetworkMode = defaultNetworkName
                }</span>
        }
        <span class="cov0" title="0">params.networkConfig = network.NetworkingConfig{
                EndpointsConfig: endpointsConfig,
        }
        params.hostConfig = container.HostConfig{
                Binds:        binds,
                Runtime:      cfg.Runtime,
                PortBindings: portBindings,
                NetworkMode:  container.NetworkMode(cfg.NetworkMode),
                // container is supervised by baetyl,
                RestartPolicy: container.RestartPolicy{Name: "no"},
                Resources: container.Resources{
                        CpusetCpus: cfg.Resources.CPU.SetCPUs,
                        NanoCPUs:   int64(cfg.Resources.CPU.Cpus * 1e9),
                        Memory:     cfg.Resources.Memory.Limit,
                        MemorySwap: cfg.Resources.Memory.Swap,
                        PidsLimit:  &amp;cfg.Resources.Pids.Limit,
                        Devices:    deviceBindings,
                },
        }
        s := &amp;dockerService{
                name:      name,
                cfg:       cfg,
                engine:    e,
                params:    params,
                instances: cmap.New(),
                log:       e.log.WithField("service", name),
        }
        err = s.Start()
        if err != nil </span><span class="cov0" title="0">{
                s.Stop()
                return nil, err
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}

func (e *dockerEngine) parseDeviceSpecs(devices []string) (deviceBindings []container.DeviceMapping, err error) <span class="cov0" title="0">{
        for _, device := range devices </span><span class="cov0" title="0">{
                deviceParts := strings.Split(device, ":")
                deviceMapping := container.DeviceMapping{}
                switch len(deviceParts) </span>{
                case 1:<span class="cov0" title="0">
                        deviceMapping.PathOnHost = deviceParts[0]
                        deviceMapping.PathInContainer = deviceParts[0]
                        deviceMapping.CgroupPermissions = "mrw"</span>
                case 2:<span class="cov0" title="0">
                        deviceMapping.PathOnHost = deviceParts[0]
                        deviceMapping.PathInContainer = deviceParts[1]
                        deviceMapping.CgroupPermissions = "mrw"</span>
                case 3:<span class="cov0" title="0">
                        deviceMapping.PathOnHost = deviceParts[0]
                        deviceMapping.PathInContainer = deviceParts[1]
                        deviceMapping.CgroupPermissions = deviceParts[2]</span>
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("invaild device mapping(%s)", device)
                        return</span>
                }
                <span class="cov0" title="0">deviceBindings = append(deviceBindings, deviceMapping)</span>
        }
        <span class="cov0" title="0">return</span>
}

func (e *dockerEngine) Close() error <span class="cov0" title="0">{
        return e.cli.Close()
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package docker

import (
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        "github.com/baetyl/baetyl/utils"
)

type attribute struct {
        Name      string `yaml:"name" json:"name"`
        Container struct {
                ID   string `yaml:"id" json:"id"`
                Name string `yaml:"name" json:"name"`
        } `yaml:"container" json:"container"`
}

func (a attribute) toPartialStats() engine.PartialStats <span class="cov0" title="0">{
        return engine.PartialStats{
                engine.KeyName: a.Name,
                "container":    a.Container,
        }
}</span>

// Instance instance of service
type dockerInstance struct {
        id      string
        name    string
        service *dockerService
        log     logger.Logger
        tomb    utils.Tomb
}

func (s *dockerService) newInstance(name string, params containerConfigs) (*dockerInstance, error) <span class="cov0" title="0">{
        log := s.log.WithField("instance", name)
        cid, err := s.engine.startContainer(name, params)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Warnln("failed to start instance, clean and retry")
                // remove and retry
                s.engine.removeContainerByName(name)
                cid, err = s.engine.startContainer(name, params)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).Warnln("failed to start instance again")
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">i := &amp;dockerInstance{
                service: s,
                id:      cid,
                name:    name,
                log:     log.WithField("cid", cid[:12]),
        }
        err = i.tomb.Go(func() error </span><span class="cov0" title="0">{
                return engine.Supervising(i)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                i.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">i.log.Infof("instance started")
        return i, nil</span>
}

func (i *dockerInstance) Service() engine.Service <span class="cov0" title="0">{
        return i.service
}</span>

func (i *dockerInstance) Name() string <span class="cov0" title="0">{
        return i.name
}</span>

func (i *dockerInstance) Info() engine.PartialStats <span class="cov0" title="0">{
        var attr attribute
        attr.Name = i.name
        attr.Container.ID = i.id
        attr.Container.Name = i.name
        return attr.toPartialStats()
}</span>

func (i *dockerInstance) Stats() engine.PartialStats <span class="cov0" title="0">{
        return i.service.engine.statsContainer(i.id)
}</span>

func (i *dockerInstance) Wait(s chan&lt;- error) <span class="cov0" title="0">{
        defer i.log.Infof("instance stopped")
        err := i.service.engine.waitContainer(i.id)
        s &lt;- err
}</span>

func (i *dockerInstance) Restart() error <span class="cov0" title="0">{
        err := i.service.engine.restartContainer(i.id)
        if err != nil </span><span class="cov0" title="0">{
                i.log.WithError(err).Errorf("failed to restart instance")
                return err
        }</span>
        <span class="cov0" title="0">i.log.Infof("instance restarted")
        return nil</span>
}

func (i *dockerInstance) Stop() <span class="cov0" title="0">{
        i.log.Infof("instance is stopping")
        err := i.service.engine.stopContainer(i.id)
        if err != nil </span><span class="cov0" title="0">{
                i.log.WithError(err).Errorf("failed to stop instance")
        }</span>
        <span class="cov0" title="0">i.service.engine.removeContainer(i.id)
        i.service.instances.Remove(i.name)</span>
}

func (i *dockerInstance) Dying() &lt;-chan struct{} <span class="cov0" title="0">{
        return i.tomb.Dying()
}</span>

func (i *dockerInstance) Close() error <span class="cov0" title="0">{
        i.log.Infof("instance is closing")
        i.tomb.Kill(nil)
        return i.tomb.Wait()
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package docker

import (
        "fmt"
        "sync"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        cmap "github.com/orcaman/concurrent-map"
)

const (
        fmtVolumeRW = "%s:%s:rw"
        fmtVolumeRO = "%s:%s:ro"
)

type dockerService struct {
        name      string
        cfg       baetyl.ComposeService
        params    containerConfigs
        engine    *dockerEngine
        instances cmap.ConcurrentMap
        log       logger.Logger
}

func (s *dockerService) Name() string <span class="cov0" title="0">{
        return s.name
}</span>

func (s *dockerService) Engine() engine.Engine <span class="cov0" title="0">{
        return s.engine
}</span>

func (s *dockerService) RestartPolicy() baetyl.RestartPolicyInfo <span class="cov0" title="0">{
        return s.cfg.Restart
}</span>

func (s *dockerService) Start() error <span class="cov0" title="0">{
        s.log.Debugf("%s replica: %d", s.name, s.cfg.Replica)
        var instanceName string
        for i := 0; i &lt; s.cfg.Replica; i++ </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        instanceName = s.name
                }</span> else<span class="cov0" title="0"> {
                        instanceName = fmt.Sprintf("%s.i%d", s.name, i)
                }</span>
                <span class="cov0" title="0">err := s.startInstance(instanceName, nil)
                if err != nil </span><span class="cov0" title="0">{
                        s.Stop()
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *dockerService) Stop() <span class="cov0" title="0">{
        var wg sync.WaitGroup
        for _, v := range s.instances.Items() </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(i *dockerInstance, wg *sync.WaitGroup) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        i.Close()
                }</span>(v.(*dockerInstance), &amp;wg)
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

func (s *dockerService) Stats() <span class="cov0" title="0">{
        for _, item := range s.instances.Items() </span><span class="cov0" title="0">{
                instance := item.(*dockerInstance)
                if stats := instance.Stats(); stats["error"] == nil </span><span class="cov0" title="0">{
                        s.engine.SetInstanceStats(s.Name(), instance.Name(), stats, false)
                }</span>
        }
}

func (s *dockerService) StartInstance(instanceName string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        return s.startInstance(instanceName, dynamicConfig)
}</span>

func (s *dockerService) startInstance(instanceName string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        s.StopInstance(instanceName)
        params := s.params
        params.config.Env = engine.GenerateInstanceEnv(instanceName, s.params.config.Env, dynamicConfig)
        i, err := s.newInstance(instanceName, params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.instances.Set(instanceName, i)
        return nil</span>
}

func (s *dockerService) StopInstance(instanceName string) error <span class="cov0" title="0">{
        i, ok := s.instances.Get(instanceName)
        if !ok </span><span class="cov0" title="0">{
                s.log.Debugf("instance (%s) not found", instanceName)
                return nil
        }</span>
        <span class="cov0" title="0">return i.(*dockerInstance).Close()</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package engine

import (
        "errors"
        "io"
        "time"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

// Factory create engine by given config
type Factory func(is InfoStats, opts Options) (Engine, error)

var factories map[string]Factory

func init() <span class="cov8" title="1">{
        factories = make(map[string]Factory)
}</span>

// Factories of engines
func Factories() map[string]Factory <span class="cov0" title="0">{
        return factories
}</span>

// Engine interface
type Engine interface {
        io.Closer
        Name() string
        Recover()
        Prepare(baetyl.ComposeAppConfig)
        SetInstanceStats(serviceName, instanceName string, partialStats PartialStats, persist bool)
        DelInstanceStats(serviceName, instanceName string, persist bool)
        DelServiceStats(serviceName string, persist bool)
        Run(string, baetyl.ComposeService, map[string]baetyl.ComposeVolume) (Service, error)
}

// Options engine options
type Options struct {
        Grace      time.Duration
        Pwd        string
        APIVersion string
}

// New engine by given name
func New(name string, is InfoStats, opts Options) (Engine, error) <span class="cov0" title="0">{
        if f, ok := factories[name]; ok </span><span class="cov0" title="0">{
                return f(is, opts)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("no such engine")</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package engine

// ServicesStats stats of all services
type ServicesStats map[string]InstancesStats

// InstancesStats stats of all instances of the service
type InstancesStats map[string]PartialStats

// PartialStats partial stats of the instance
type PartialStats map[string]interface{}

// NewPartialStatsByStatus creates a new stats by status
func NewPartialStatsByStatus(status string) PartialStats <span class="cov0" title="0">{
        return PartialStats{
                KeyStatus: status,
        }
}</span>

// InfoStats interfaces of the storage of info and stats
type InfoStats interface {
        LoadStats(sss interface{}) bool
        SetInstanceStats(serviceName, instanceName string, partialStats PartialStats, persist bool)
        DelInstanceStats(serviceName, instanceName string, persist bool)
        DelServiceStats(serviceName string, persist bool)
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package engine

import (
        "fmt"
        "io"
        "strings"

        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
)

// all status
const (
        KeyName       = "name"
        KeyStatus     = "status"
        KeyCreateTime = "create_time"
        KeyStartTime  = "start_time"
        KeyFinishTime = "finish_time"

        // Created    = "created"    // 
        Running = "running" // 
        // Paused     = "paused"     // 
        Restarting = "restarting" // 
        // Removing   = "removing"   // 
        // Exited     = "exited"     // 
        Dead = "dead" // 
        // Offline    = "offline"    // 
)

// Instance interfaces of instance
type Instance interface {
        Service() Service
        Name() string
        Info() PartialStats
        Stats() PartialStats
        Wait(w chan&lt;- error)
        Dying() &lt;-chan struct{}
        Restart() error
        Stop()
        io.Closer
}

// GenerateInstanceEnv generates new env of the instance
func GenerateInstanceEnv(name string, static []string, dynamic map[string]string) []string <span class="cov0" title="0">{
        env := []string{}
        dyn := dynamic != nil
        for _, v := range static </span><span class="cov0" title="0">{
                // remove auth token info for dynamic instances
                if dyn </span><span class="cov0" title="0">{
                        if strings.HasPrefix(v, baetyl.EnvKeyServiceToken) || strings.HasPrefix(v, baetyl.EnvServiceTokenKey) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">env = append(env, v)</span>
        }
        <span class="cov0" title="0">env = append(env, fmt.Sprintf("%s=%s", baetyl.EnvKeyServiceInstanceName, name))
        // TODO: remove, backward compatibility
        env = append(env, fmt.Sprintf("%s=%s", baetyl.EnvServiceInstanceNameKey, name))
        if dyn </span><span class="cov0" title="0">{
                for k, v := range dynamic </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", k, v))
                }</span>
        }
        <span class="cov0" title="0">return env</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package native

import (
        "fmt"
        "os"
        "path"
        "strings"
        "time"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
        cmap "github.com/orcaman/concurrent-map"
        "github.com/shirou/gopsutil/process"
)

// NAME of this engine
const NAME = "native"

func init() <span class="cov8" title="1">{
        engine.Factories()[NAME] = New
}</span>

// New native engine
func New(stats engine.InfoStats, opts engine.Options) (engine.Engine, error) <span class="cov0" title="0">{
        e := &amp;nativeEngine{
                InfoStats: stats,
                pwd:       opts.Pwd,
                grace:     opts.Grace,
                log:       logger.WithField("engine", NAME),
        }
        return e, nil
}</span>

type nativeEngine struct {
        engine.InfoStats
        pwd   string // work directory
        grace time.Duration
        log   logger.Logger
}

// Name of engine
func (e *nativeEngine) Name() string <span class="cov0" title="0">{
        return NAME
}</span>

// Recover recover old services when master restart
func (e *nativeEngine) Recover() <span class="cov0" title="0">{
        // clean old services in native mode
        e.clean()
}</span>

// Prepare prepares all images
func (e *nativeEngine) Prepare(baetyl.ComposeAppConfig) {<span class="cov0" title="0">
        // do nothing in native mode
}</span>

// Clean clean all old instances
func (e *nativeEngine) clean() <span class="cov0" title="0">{
        sss := map[string]map[string]attribute{}
        if e.LoadStats(&amp;sss) </span><span class="cov0" title="0">{
                for sn, instances := range sss </span><span class="cov0" title="0">{
                        for in, instance := range instances </span><span class="cov0" title="0">{
                                id := int32(instance.Process.ID)
                                if id == 0 </span><span class="cov0" title="0">{
                                        e.log.Warnf("[%s][%s] process id not found, maybe running mode changed", sn, in)
                                        continue</span>
                                }
                                <span class="cov0" title="0">name := instance.Process.Name
                                p, err := process.NewProcess(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        e.log.WithError(err).Warnf("[%s][%s] failed to get old process (%d)", sn, in, id)
                                        continue</span>
                                }
                                <span class="cov0" title="0">pn, err := p.Name()
                                if err != nil </span><span class="cov0" title="0">{
                                        e.log.WithError(err).Warnf("[%s][%s] failed to get name of old process (%d)", sn, in, id)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if pn != name </span><span class="cov0" title="0">{
                                        e.log.Debugf("[%s][%s] name of old process (%d) not matched, %s -&gt; %s", sn, in, id, name, pn)
                                        continue</span>
                                }
                                <span class="cov0" title="0">err = p.Kill()
                                if err != nil </span><span class="cov0" title="0">{
                                        e.log.Warnf("[%s][%s] failed to stop the old process (%d)", sn, in, id)
                                }</span> else<span class="cov0" title="0"> {
                                        e.log.Infof("[%s][%s] old process (%d) stopped", sn, in, id)
                                }</span>
                        }
                }
        }
}

// Run new service
func (e *nativeEngine) Run(name string, cfg baetyl.ComposeService, _ map[string]baetyl.ComposeVolume) (engine.Service, error) <span class="cov0" title="0">{
        spwd := path.Join(e.pwd, "var", "run", "baetyl", "services", name)
        err := os.RemoveAll(spwd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mountAll(e.pwd, spwd, cfg.Volumes)
        if err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(spwd)
                return nil, err
        }</span>
        <span class="cov0" title="0">var pkg packageConfig
        image := strings.Replace(strings.TrimSpace(cfg.Image), ":", "/", -1)
        pkgDir := path.Join(spwd, "lib", "baetyl", image)
        err = utils.LoadYAML(path.Join(pkgDir, packageConfigPath), &amp;pkg)
        if err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(spwd)
                return nil, err
        }</span>
        <span class="cov0" title="0">params := processConfigs{
                exec: path.Join(pkgDir, pkg.Entry),
                env:  utils.AppendEnv(cfg.Environment.Envs, true),
                argv: cfg.Command.Cmd,
                pwd:  spwd,
        }
        s := &amp;nativeService{
                name:      name,
                cfg:       cfg,
                engine:    e,
                params:    params,
                instances: cmap.New(),
                log:       e.log.WithField("service", name),
        }
        err = s.Start()
        if err != nil </span><span class="cov0" title="0">{
                s.Stop()
                return nil, err
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}

// Close engine
func (e *nativeEngine) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func mountAll(epwd, spwd string, ms []baetyl.ServiceVolume) error <span class="cov0" title="0">{
        for _, m := range ms </span><span class="cov0" title="0">{
                if len(m.Source) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("host path is empty")
                }</span>
                // for preventing path escape
                <span class="cov0" title="0">m.Source = path.Join(epwd, path.Join("/", m.Source))
                err := mount(m.Source, path.Join(spwd, strings.TrimSpace(m.Target)))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">sock := utils.GetEnv(baetyl.EnvKeyMasterAPISocket)
        if sock != "" </span><span class="cov0" title="0">{
                return mount(sock, path.Join(spwd, baetyl.DefaultSockFile))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func mount(src, dst string) error <span class="cov8" title="1">{
        // if it is a file mapping, the file must exist, otherwise it
        // will be used as a dir mapping and make the dir.
        if !utils.PathExists(src) </span><span class="cov8" title="1">{
                err := os.MkdirAll(src, 0755)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">err := os.MkdirAll(path.Dir(dst), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.Symlink(src, dst)</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package native

import (
        "os"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        "github.com/baetyl/baetyl/utils"
        "github.com/shirou/gopsutil/process"
)

type attribute struct {
        Name    string `yaml:"name" json:"name"`
        Process struct {
                ID   int    `yaml:"id" json:"id"`
                Name string `yaml:"name" json:"name"`
        } `yaml:"process" json:"process"`
}

func (a attribute) toPartialStats() engine.PartialStats <span class="cov0" title="0">{
        return engine.PartialStats{
                engine.KeyName: a.Name,
                "process":      a.Process,
        }
}</span>

// Instance instance of service
type nativeInstance struct {
        name    string
        service *nativeService
        params  processConfigs
        proc    *os.Process
        tomb    utils.Tomb
        log     logger.Logger
}

func (s *nativeService) newInstance(name string, params processConfigs) (*nativeInstance, error) <span class="cov0" title="0">{
        log := s.log.WithField("instance", name)
        p, err := s.engine.startProcess(params)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Warnf("failed to start instance")
                // retry
                p, err = s.engine.startProcess(params)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).Warnf("failed to start instance again")
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">i := &amp;nativeInstance{
                name:    name,
                service: s,
                params:  params,
                proc:    p,
                log:     log.WithField("pid", p.Pid),
        }
        err = i.tomb.Go(func() error </span><span class="cov0" title="0">{
                return engine.Supervising(i)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                i.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">i.log.Infof("instance started")
        return i, nil</span>
}

func (i *nativeInstance) Service() engine.Service <span class="cov0" title="0">{
        return i.service
}</span>

func (i *nativeInstance) Name() string <span class="cov0" title="0">{
        return i.name
}</span>

func (i *nativeInstance) Info() engine.PartialStats <span class="cov0" title="0">{
        var pn string
        p, err := process.NewProcess(int32(i.proc.Pid))
        if err != nil </span><span class="cov0" title="0">{
                i.log.Warnf("failed to create the process (%s) to get its name", i.proc.Pid)
        }</span> else<span class="cov0" title="0"> {
                pn, err = p.Name()
                if err != nil </span><span class="cov0" title="0">{
                        i.log.Warnf("failed to get the process (%s) name", i.proc.Pid)
                }</span>
        }
        <span class="cov0" title="0">var attr attribute
        attr.Name = i.name
        attr.Process.ID = i.proc.Pid
        attr.Process.Name = pn
        return attr.toPartialStats()</span>
}

func (i *nativeInstance) Stats() engine.PartialStats <span class="cov0" title="0">{
        return i.service.engine.statsProcess(i.proc)
}</span>

func (i *nativeInstance) Wait(s chan&lt;- error) <span class="cov0" title="0">{
        defer i.log.Infof("instance stopped")
        err := i.service.engine.waitProcess(i.proc)
        s &lt;- err
}</span>

func (i *nativeInstance) Restart() error <span class="cov0" title="0">{
        p, err := i.service.engine.startProcess(i.params)
        if err != nil </span><span class="cov0" title="0">{
                i.log.WithError(err).Errorf("failed to restart instance")
                return err
        }</span>
        <span class="cov0" title="0">i.proc = p
        i.log = i.log.WithField("pid", p.Pid)
        i.log.Infof("instance restarted")
        return nil</span>
}

func (i *nativeInstance) Stop() <span class="cov0" title="0">{
        i.log.Infof("instance is stopping")
        err := i.service.engine.stopProcess(i.proc)
        if err != nil </span><span class="cov0" title="0">{
                i.log.Debugf("failed to stop instance: %s", err.Error())
        }</span>
        <span class="cov0" title="0">i.service.instances.Remove(i.name)</span>
}

func (i *nativeInstance) Dying() &lt;-chan struct{} <span class="cov0" title="0">{
        return i.tomb.Dying()
}</span>

func (i *nativeInstance) Close() error <span class="cov0" title="0">{
        i.log.Infof("instance is closing")
        i.tomb.Kill(nil)
        return i.tomb.Wait()
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package native

import (
        "fmt"
        "os"
        "syscall"
        "time"

        "github.com/baetyl/baetyl/master/engine"
        "github.com/baetyl/baetyl/utils"
        "github.com/shirou/gopsutil/process"
)

type processConfigs struct {
        exec string
        pwd  string
        argv []string
        env  []string
}

func (e *nativeEngine) startProcess(cfg processConfigs) (*os.Process, error) <span class="cov0" title="0">{
        os.Chmod(cfg.exec, os.ModePerm)
        p, err := os.StartProcess(
                cfg.exec,
                cfg.argv,
                &amp;os.ProcAttr{
                        Dir: cfg.pwd,
                        Env: cfg.env,
                        Files: []*os.File{
                                os.Stdin,
                                os.Stdout,
                                os.Stderr,
                        },
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to start process")
                return nil, err
        }</span>
        <span class="cov0" title="0">e.log.Debugf("process (%d) started", p.Pid)
        return p, nil</span>
}

func (e *nativeEngine) waitProcess(p *os.Process) error <span class="cov0" title="0">{
        ps, err := p.Wait()
        if err != nil </span><span class="cov0" title="0">{
                e.log.WithError(err).Warnf("failed to wait process (%d)", p.Pid)
                return err
        }</span>
        <span class="cov0" title="0">e.log.Debugf("process (%d) %s", p.Pid, ps.String())
        if !ps.Success() </span><span class="cov0" title="0">{
                return fmt.Errorf("process exit code: %s", ps.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e *nativeEngine) stopProcess(p *os.Process) error <span class="cov0" title="0">{
        e.log.Debugf("process (%d) is stopping", p.Pid)

        err := p.Signal(syscall.SIGTERM)
        if err != nil </span><span class="cov0" title="0">{
                e.log.Debugf("failed to stop process (%d): %s", p.Pid, err.Error())
                return nil
        }</span>

        <span class="cov0" title="0">done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                _, err := p.Wait()
                done &lt;- err
        }</span>()
        <span class="cov0" title="0">select </span>{
        case &lt;-time.After(e.grace):<span class="cov0" title="0">
                e.log.Warnf("timed out to wait process (%d)", p.Pid)
                err = p.Kill()
                if err != nil </span><span class="cov0" title="0">{
                        e.log.WithError(err).Warnf("failed to kill process (%d)", p.Pid)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("timed out to wait process (%d)", p.Pid)</span>
        case err := &lt;-done:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        e.log.Debugf("failed to wait process (%d): %s", p.Pid, err.Error())
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func (e *nativeEngine) statsProcess(p *os.Process) engine.PartialStats <span class="cov0" title="0">{
        proc, err := process.NewProcess(int32(p.Pid))
        if err != nil </span><span class="cov0" title="0">{
                return engine.PartialStats{"error": err.Error()}
        }</span>
        <span class="cov0" title="0">cpu := utils.CPUInfo{Time: time.Now().UTC()}
        cpu.UsedPercent, err = proc.CPUPercent()
        if err != nil </span><span class="cov0" title="0">{
                cpu.Error = err.Error()
        }</span>
        <span class="cov0" title="0">mem := utils.MemInfo{Time: time.Now().UTC()}
        meminfo, err := proc.MemoryInfo()
        if err != nil </span><span class="cov0" title="0">{
                mem.Error = err.Error()
        }</span> else<span class="cov0" title="0"> {
                mem.Used = meminfo.RSS
                mem.SwapUsed = meminfo.Swap
                mup, err := proc.MemoryPercent()
                if err != nil </span><span class="cov0" title="0">{
                        mem.Error = err.Error()
                }</span> else<span class="cov0" title="0"> {
                        mem.UsedPercent = float64(mup)
                }</span>
        }
        <span class="cov0" title="0">return engine.PartialStats{
                "cpu_stats": cpu,
                "mem_stats": mem,
        }</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package native

import (
        "fmt"
        "os"
        "sync"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        cmap "github.com/orcaman/concurrent-map"
)

const packageConfigPath = "package.yml"

type packageConfig struct {
        Entry string `yaml:"entry" json:"entry"`
}

type nativeService struct {
        name      string
        cfg       baetyl.ComposeService
        params    processConfigs
        engine    *nativeEngine
        instances cmap.ConcurrentMap
        wdir      string
        log       logger.Logger
}

func (s *nativeService) Name() string <span class="cov0" title="0">{
        return s.name
}</span>

func (s *nativeService) Engine() engine.Engine <span class="cov0" title="0">{
        return s.engine
}</span>

func (s *nativeService) RestartPolicy() baetyl.RestartPolicyInfo <span class="cov0" title="0">{
        return s.cfg.Restart
}</span>

func (s *nativeService) Start() error <span class="cov0" title="0">{
        s.log.Debugf("%s replica: %d", s.name, s.cfg.Replica)
        var instanceName string
        for i := 0; i &lt; s.cfg.Replica; i++ </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        instanceName = s.name
                }</span> else<span class="cov0" title="0"> {
                        instanceName = fmt.Sprintf("%s.i%d", s.name, i)
                }</span>
                <span class="cov0" title="0">err := s.startInstance(instanceName, nil)
                if err != nil </span><span class="cov0" title="0">{
                        s.Stop()
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *nativeService) Stop() <span class="cov0" title="0">{
        defer os.RemoveAll(s.params.pwd)
        var wg sync.WaitGroup
        for _, v := range s.instances.Items() </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(i *nativeInstance, wg *sync.WaitGroup) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        i.Close()
                }</span>(v.(*nativeInstance), &amp;wg)
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

func (s *nativeService) Stats() <span class="cov0" title="0">{
        for _, item := range s.instances.Items() </span><span class="cov0" title="0">{
                instance := item.(*nativeInstance)
                if stats := instance.Stats(); stats["error"] == nil </span><span class="cov0" title="0">{
                        s.engine.SetInstanceStats(s.Name(), instance.Name(), stats, false)
                }</span>
        }
}

func (s *nativeService) StartInstance(instanceName string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        return s.startInstance(instanceName, dynamicConfig)
}</span>

func (s *nativeService) startInstance(instanceName string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        s.StopInstance(instanceName)
        params := s.params
        params.argv = append([]string{instanceName}, s.params.argv...)
        params.env = engine.GenerateInstanceEnv(instanceName, s.params.env, dynamicConfig)
        i, err := s.newInstance(instanceName, params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.instances.Set(instanceName, i)
        return nil</span>
}

func (s *nativeService) StopInstance(instanceName string) error <span class="cov0" title="0">{
        i, ok := s.instances.Get(instanceName)
        if !ok </span><span class="cov0" title="0">{
                s.log.Debugf("instance (%s) not found", instanceName)
                return nil
        }</span>
        <span class="cov0" title="0">return i.(*nativeInstance).Close()</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package engine

import (
        "fmt"
        "time"

        "github.com/baetyl/baetyl/logger"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/jpillora/backoff"
)

// Supervising supervise an instance
func Supervising(instance Instance) error <span class="cov0" title="0">{
        service := instance.Service()
        _engine := service.Engine()
        serviceName := service.Name()
        instanceName := instance.Name()
        defer _engine.DelInstanceStats(serviceName, instanceName, true)
        defer instance.Stop()

        c := 0
        p := instance.Service().RestartPolicy()
        b := &amp;backoff.Backoff{
                Min:    p.Backoff.Min,
                Max:    p.Backoff.Max,
                Factor: p.Backoff.Factor,
        }
        l := logger.Global.WithField("service", serviceName).WithField("instance", instanceName)
        s := make(chan error, 1)
        for </span><span class="cov0" title="0">{
                instanceInfo := instance.Info()
                instanceInfo[KeyStatus] = Running
                instanceInfo[KeyStartTime] = time.Now().UTC()
                _engine.SetInstanceStats(serviceName, instanceName, instanceInfo, true)
                go instance.Wait(s)
                select </span>{
                case &lt;-instance.Dying():<span class="cov0" title="0">
                        return nil</span>
                case err := &lt;-s:<span class="cov0" title="0">
                        switch p.Policy </span>{
                        case baetyl.RestartOnFailure:<span class="cov0" title="0">
                                // TODO: to test
                                if err == nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">_engine.SetInstanceStats(serviceName, instanceName, NewPartialStatsByStatus(Restarting), true)
                                goto RESTART</span>
                        case baetyl.RestartAlways:<span class="cov0" title="0">
                                _engine.SetInstanceStats(serviceName, instanceName, NewPartialStatsByStatus(Restarting), true)
                                goto RESTART</span>
                        case baetyl.RestartNo:<span class="cov0" title="0">
                                // TODO: to test
                                return nil</span>
                        default:<span class="cov0" title="0">
                                l.Errorf("Restart policy (%s) invalid", p.Policy)
                                return fmt.Errorf("Restart policy invalid")</span>
                        }
                }

        RESTART:
                <span class="cov0" title="0">c++
                if p.Retry.Max &gt; 0 &amp;&amp; c &gt; p.Retry.Max </span><span class="cov0" title="0">{
                        l.Errorf("retry too much (%d)", c)
                        return fmt.Errorf("retry too much")
                }</span>

                <span class="cov0" title="0">select </span>{
                case &lt;-time.After(b.Duration()):<span class="cov0" title="0"></span>
                case &lt;-instance.Dying():<span class="cov0" title="0">
                        return nil</span>
                }

                <span class="cov0" title="0">err := instance.Restart()
                if err != nil </span><span class="cov0" title="0">{
                        l.Errorf("failed to restart module, keep to restart")
                        goto RESTART</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package master

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "runtime"
        "sync"
        "time"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/engine"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
        "gopkg.in/yaml.v2"
)

type infoStats struct {
        baetyl.Inspect
        services engine.ServicesStats
        file     string
        sync.RWMutex
}

func newInfoStats(pwd, mode, version, revision, file string) *infoStats <span class="cov8" title="1">{
        return &amp;infoStats{
                file:     file,
                services: engine.ServicesStats{},
                Inspect: baetyl.Inspect{
                        Software: baetyl.Software{
                                OS:          runtime.GOOS,
                                Arch:        runtime.GOARCH,
                                GoVersion:   runtime.Version(),
                                PWD:         pwd,
                                Mode:        mode,
                                BinVersion:  version,
                                GitRevision: revision,
                        },
                        Hardware: baetyl.Hardware{
                                HostInfo: utils.GetHostInfo(),
                                NetInfo:  utils.GetNetInfo(),
                        },
                },
        }
}</span>

func (is *infoStats) SetInstanceStats(serviceName, instanceName string, partialStats engine.PartialStats, persist bool) <span class="cov8" title="1">{
        is.Lock()
        service, ok := is.services[serviceName]
        if !ok </span><span class="cov8" title="1">{
                service = engine.InstancesStats{}
                is.services[serviceName] = service
        }</span>
        <span class="cov8" title="1">instance, ok := service[instanceName]
        if !ok </span><span class="cov8" title="1">{
                instance = partialStats
                service[instanceName] = instance
        }</span> else<span class="cov0" title="0"> {
                for k, v := range partialStats </span><span class="cov0" title="0">{
                        instance[k] = v
                }</span>
        }
        <span class="cov8" title="1">if persist </span><span class="cov8" title="1">{
                is.persistStats()
        }</span>
        <span class="cov8" title="1">is.Unlock()</span>
}

func (is *infoStats) DelInstanceStats(serviceName, instanceName string, persist bool) <span class="cov8" title="1">{
        is.Lock()
        defer is.Unlock()
        service, ok := is.services[serviceName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, ok = service[instanceName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">delete(service, instanceName)
        if len(service) == 0 </span><span class="cov8" title="1">{
                delete(is.services, serviceName)
        }</span>
        <span class="cov8" title="1">if persist </span><span class="cov8" title="1">{
                is.persistStats()
        }</span>
}

func (is *infoStats) DelServiceStats(serviceName string, persist bool) <span class="cov8" title="1">{
        is.Lock()
        defer is.Unlock()
        _, ok := is.services[serviceName]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">delete(is.services, serviceName)
        if persist </span><span class="cov0" title="0">{
                is.persistStats()
        }</span>
}

func (is *infoStats) setVersion(ver string) <span class="cov8" title="1">{
        is.Lock()
        is.Inspect.Software.ConfVersion = ver
        is.Unlock()
}</span>

func (is *infoStats) getVersion() string <span class="cov8" title="1">{
        is.RLock()
        defer is.RUnlock()
        return is.Inspect.Software.ConfVersion
}</span>

func (is *infoStats) setError(err error) <span class="cov8" title="1">{
        is.Lock()
        if err == nil </span><span class="cov8" title="1">{
                is.Inspect.Error = ""
        }</span> else<span class="cov8" title="1"> {
                is.Inspect.Error = err.Error()
        }</span>
        <span class="cov8" title="1">is.Unlock()</span>
}

func (is *infoStats) getError() string <span class="cov8" title="1">{
        is.RLock()
        defer is.RUnlock()
        return is.Inspect.Error
}</span>

// func genVolumesStats(cfg []baetyl.VolumeInfo) baetyl.Volumes {
//         volumes := baetyl.Volumes{}
//         for _, item := range cfg {
//                 volumes = append(volumes, baetyl.VolumeStatus{
//                         Name:    item.Name,
//                         Version: item.Meta.Version,
//                 })
//         }
//         return volumes
// }

func (is *infoStats) persistStats() <span class="cov8" title="1">{
        data, err := yaml.Marshal(is.services)
        if err != nil </span><span class="cov0" title="0">{
                logger.Global.WithError(err).Warnf("failed to persist services stats")
                return
        }</span>
        <span class="cov8" title="1">err = ioutil.WriteFile(is.file, data, 0755)
        if err != nil </span><span class="cov0" title="0">{
                logger.Global.WithError(err).Warnf("failed to persist services stats")
        }</span>
}

func (is *infoStats) LoadStats(services interface{}) bool <span class="cov0" title="0">{
        if !utils.FileExists(is.file) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">data, err := ioutil.ReadFile(is.file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Global.WithError(err).Warnf("failed to read old stats")
                os.Rename(is.file, fmt.Sprintf("%s.%d", is.file, time.Now().Unix()))
                return false
        }</span>
        <span class="cov0" title="0">err = yaml.Unmarshal(data, services)
        if err != nil </span><span class="cov0" title="0">{
                logger.Global.WithError(err).Warnf("failed to unmarshal old stats")
                os.Rename(is.file, fmt.Sprintf("%s.%d", is.file, time.Now().Unix()))
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (is *infoStats) stats() <span class="cov0" title="0">{
        t := time.Now().UTC()
        gi := utils.GetGPUInfo()
        mi := utils.GetMemInfo()
        ci := utils.GetCPUInfo()
        di := utils.GetDiskInfo("/")

        is.Lock()
        is.Inspect.Time = t
        is.Inspect.Hardware.GPUInfo = gi
        is.Inspect.Hardware.MemInfo = mi
        is.Inspect.Hardware.CPUInfo = ci
        is.Inspect.Hardware.DiskInfo = di
        is.Unlock()
}</span>

func (is *infoStats) serializeStats() ([]byte, error) <span class="cov0" title="0">{
        is.Lock()
        defer is.Unlock()

        result := is.Inspect
        result.Services = baetyl.Services{}
        for serviceName, serviceStats := range is.services </span><span class="cov0" title="0">{
                service := baetyl.NewServiceStatus(serviceName)
                for _, instanceStats := range serviceStats </span><span class="cov0" title="0">{
                        service.Instances = append(service.Instances, map[string]interface{}(instanceStats))
                }</span>
                <span class="cov0" title="0">result.Services = append(result.Services, service)</span>
        }
        <span class="cov0" title="0">return json.Marshal(result)</span>
}

// InspectSystem inspects info and stats of baetyl system
func (m *Master) InspectSystem() ([]byte, error) <span class="cov0" title="0">{
        defer utils.Trace("InspectSystem", logger.Global.Debugf)()
        var wg sync.WaitGroup
        for item := range m.services.IterBuffered() </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(s engine.Service) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        s.Stats()
                }</span>(item.Val.(engine.Service))
        }
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                m.infostats.stats()
        }</span>()
        <span class="cov0" title="0">wg.Wait()

        return m.infostats.serializeStats()</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package master

import (
        "fmt"
        "os"
        "os/signal"
        "path"
        "syscall"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/master/api"
        "github.com/baetyl/baetyl/master/database"
        "github.com/baetyl/baetyl/master/engine"
        "github.com/baetyl/baetyl/protocol/http"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        cmap "github.com/orcaman/concurrent-map"
)

// Master master manages all modules and connects with cloud
type Master struct {
        cfg       Config
        ver       string
        pwd       string
        server    *api.Server
        engine    engine.Engine
        apiserver *api.APIServer
        services  cmap.ConcurrentMap
        database  database.DB
        accounts  cmap.ConcurrentMap
        infostats *infoStats
        sig       chan os.Signal
        log       logger.Logger
}

// New creates a new master
func New(pwd string, cfg Config, ver string, revision string) (*Master, error) <span class="cov0" title="0">{
        err := os.MkdirAll(baetyl.DefaultDBDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make db directory: %s", err.Error())
        }</span>

        <span class="cov0" title="0">log := logger.InitLogger(cfg.Logger, "baetyl", "master")
        m := &amp;Master{
                cfg:       cfg,
                ver:       ver,
                pwd:       pwd,
                log:       log,
                sig:       make(chan os.Signal, 1),
                services:  cmap.New(),
                accounts:  cmap.New(),
                infostats: newInfoStats(pwd, cfg.Mode, ver, revision, path.Join(baetyl.DefaultDBDir, baetyl.AppStatsFileName)),
        }
        log.Infof("mode: %s; grace: %d; pwd: %s; api: %s", cfg.Mode, cfg.Grace, pwd, cfg.Server.Address)

        opts := engine.Options{
                Grace:      cfg.Grace,
                Pwd:        pwd,
                APIVersion: cfg.Docker.APIVersion,
        }
        m.engine, err = engine.New(cfg.Mode, m.infostats, opts)
        if err != nil </span><span class="cov0" title="0">{
                m.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infoln("engine started")

        err = os.MkdirAll(cfg.Database.Path, 0755)
        if err != nil </span><span class="cov0" title="0">{
                m.Close()
                return nil, fmt.Errorf("failed to make db directory: %s", err.Error())
        }</span>
        <span class="cov0" title="0">m.database, err = database.New(database.Conf{Driver: cfg.Database.Driver, Source: path.Join(cfg.Database.Path, "kv.db")})
        if err != nil </span><span class="cov0" title="0">{
                m.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infoln("db inited")

        m.apiserver = api.NewAPIServer(cfg.API)
        m.apiserver.RegisterKVService(api.NewKVService(m.database))
        err = m.apiserver.Start()
        if err != nil </span><span class="cov0" title="0">{
                m.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infoln("api server started")

        sc := http.ServerInfo{
                Address:     m.cfg.Server.Address,
                Timeout:     m.cfg.Server.Timeout,
                Certificate: m.cfg.Server.Certificate,
        }
        m.server, err = api.New(sc, m)
        if err != nil </span><span class="cov0" title="0">{
                m.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infoln("server started")

        // TODO: implement recover logic when master restarts
        // Now it will stop all old services
        m.engine.Recover()

        // start application
        err = m.UpdateAPP("", "")
        if err != nil </span><span class="cov0" title="0">{
                m.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infoln("services started")
        return m, nil</span>
}

// Close closes agent
func (m *Master) Close() error <span class="cov8" title="1">{
        if m.server != nil </span><span class="cov0" title="0">{
                m.server.Close()
                m.log.Infoln("server stopped")
        }</span>
        <span class="cov8" title="1">if m.apiserver != nil </span><span class="cov0" title="0">{
                m.apiserver.Close()
                m.log.Infoln("api server stopped")
        }</span>
        <span class="cov8" title="1">if m.database != nil </span><span class="cov0" title="0">{
                m.database.Close()
                m.log.Infoln("db closed")
        }</span>
        <span class="cov8" title="1">m.stopServices(map[string]struct{}{})
        if m.engine != nil </span><span class="cov8" title="1">{
                m.engine.Close()
                m.log.Infoln("engine stopped")
        }</span>
        <span class="cov8" title="1">select </span>{
        case m.sig &lt;- syscall.SIGQUIT:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Wait waits until master closes
func (m *Master) Wait() error <span class="cov8" title="1">{
        signal.Notify(m.sig, syscall.SIGTERM, syscall.SIGINT)
        signal.Ignore(syscall.SIGPIPE)
        &lt;-m.sig
        return nil
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package master

import (
        "fmt"
        "reflect"
        "sync"

        "github.com/baetyl/baetyl/master/engine"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/docker/distribution/uuid"
)

// Auth auth api request from services
func (m *Master) Auth(username, password string) bool <span class="cov0" title="0">{
        v, ok := m.accounts.Get(username)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">p, ok := v.(string)
        return ok &amp;&amp; p == password</span>
}

func (m *Master) startServices(cur baetyl.ComposeAppConfig) error <span class="cov8" title="1">{
        for _, name := range ServiceSort(cur.Services) </span><span class="cov8" title="1">{
                s := cur.Services[name]
                if _, ok := m.services.Get(name); ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if s.ContainerName != "" </span><span class="cov0" title="0">{
                        name = s.ContainerName
                }</span>
                <span class="cov8" title="1">token := uuid.Generate().String()
                m.accounts.Set(name, token)
                s.Environment.Envs[baetyl.EnvKeyServiceName] = name
                s.Environment.Envs[baetyl.EnvKeyServiceToken] = token
                // TODO: remove, backward compatibility
                s.Environment.Envs[baetyl.EnvServiceNameKey] = name
                s.Environment.Envs[baetyl.EnvServiceTokenKey] = token
                nxt, err := m.engine.Run(name, s, cur.Volumes)
                if err != nil </span><span class="cov8" title="1">{
                        m.log.Infof("failed to start service (%s)", name)
                        return err
                }</span>
                <span class="cov8" title="1">m.services.Set(name, nxt)
                m.log.Infof("service (%s) started", name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *Master) stopServices(keepServices map[string]struct{}) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        for item := range m.services.IterBuffered() </span><span class="cov8" title="1">{
                s := item.Val.(engine.Service)
                // skip the service not changed
                if _, ok := keepServices[s.Name()]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">service, ok := m.services.Get(s.Name())
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">wg.Add(1)
                go func(s engine.Service) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        s.Stop()
                        m.services.Remove(s.Name())
                        m.accounts.Remove(s.Name())
                        m.engine.DelServiceStats(s.Name(), true)
                        m.log.Infof("service (%s) stopped", s.Name())
                }</span>(service.(engine.Service))
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

// ReportInstance reports the stats of the instance of the service
func (m *Master) ReportInstance(serviceName, instanceName string, partialStats engine.PartialStats) error <span class="cov0" title="0">{
        _, ok := m.services.Get(serviceName)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("service (%s) not found", serviceName)
        }</span>
        <span class="cov0" title="0">m.infostats.SetInstanceStats(serviceName, instanceName, partialStats, false)
        return nil</span>
}

// StartInstance starts a service instance
func (m *Master) StartInstance(service, instance string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        s, ok := m.services.Get(service)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("service (%s) not found", service)
        }</span>
        <span class="cov0" title="0">return s.(engine.Service).StartInstance(instance, dynamicConfig)</span>
}

// StopInstance stops a service instance
func (m *Master) StopInstance(service, instance string) error <span class="cov0" title="0">{
        s, ok := m.services.Get(service)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("service (%s) not found", service)
        }</span>
        <span class="cov0" title="0">return s.(engine.Service).StopInstance(instance)</span>
}

// DiffServices returns the services not changed
func diffServices(cur, old baetyl.ComposeAppConfig) map[string]struct{} <span class="cov8" title="1">{
        // find the volumes updated
        updateVolumes := make(map[string]struct{})
        for name, c := range cur.Volumes </span><span class="cov0" title="0">{
                if !reflect.DeepEqual(c, old.Volumes[name]) </span><span class="cov0" title="0">{
                        updateVolumes[name] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">updateNetworks := make(map[string]struct{})
        for name, c := range cur.Networks </span><span class="cov0" title="0">{
                if !reflect.DeepEqual(c, old.Networks[name]) </span><span class="cov0" title="0">{
                        updateNetworks[name] = struct{}{}
                }</span>
        }
        // find the services not changed
        <span class="cov8" title="1">keepServices := map[string]struct{}{}
        for name, c := range cur.Services </span><span class="cov8" title="1">{
                o, ok := old.Services[name]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !reflect.DeepEqual(c, o) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">changed := false
                for _, m := range c.Volumes </span><span class="cov8" title="1">{
                        if _, changed = updateVolumes[m.Source]; changed </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">for name := range c.Networks.ServiceNetworks </span><span class="cov0" title="0">{
                        if _, changed = updateNetworks[name]; changed </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">if changed </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">keepServices[name] = struct{}{}</span>
        }
        <span class="cov8" title="1">return keepServices</span>
}

// ServiceSort sort service
func ServiceSort(services map[string]baetyl.ComposeService) []string <span class="cov8" title="1">{
        g := map[string][]string{}
        inDegrees := map[string]int{}
        res := []string{}
        for name, s := range services </span><span class="cov8" title="1">{
                for _, r := range s.DependsOn </span><span class="cov8" title="1">{
                        if g[r] == nil </span><span class="cov8" title="1">{
                                g[r] = []string{}
                        }</span>
                        <span class="cov8" title="1">g[r] = append(g[r], name)</span>
                }
                <span class="cov8" title="1">inDegrees[name] = len(s.DependsOn)</span>
        }
        <span class="cov8" title="1">queue := []string{}
        for n, i := range inDegrees </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        queue = append(queue, n)
                        inDegrees[n] = -1
                }</span>
        }
        <span class="cov8" title="1">for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                i := queue[0]
                res = append(res, i)
                queue = queue[1:]
                for _, v := range g[i] </span><span class="cov8" title="1">{
                        inDegrees[v]--
                        if inDegrees[v] == 0 </span><span class="cov8" title="1">{
                                inDegrees[v] = -1
                                queue = append(queue, v)
                        }</span>
                }
        }
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package master

import (
        "fmt"
        "os"
        "os/exec"
        "path"
        "strings"

        "github.com/baetyl/baetyl/logger"
        baetyl "github.com/baetyl/baetyl/sdk/baetyl-go"
        "github.com/baetyl/baetyl/utils"
        "github.com/inconshreveable/go-update"
)

var appDir = path.Join("var", "db", "baetyl")
var appConfigFile = path.Join(appDir, baetyl.AppConfFileName)
var appBackupFile = path.Join(appDir, baetyl.AppBackupFileName)

// UpdateSystem updates application or master
func (m *Master) UpdateSystem(trace, tp, target string) (err error) <span class="cov8" title="1">{
        switch tp </span>{
        case baetyl.OTAMST:<span class="cov0" title="0">
                err = m.UpdateMST(trace, target, baetyl.DefaultBinBackupFile)</span>
        default:<span class="cov8" title="1">
                err = m.UpdateAPP(trace, target)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to update system: %s", err.Error())
                m.log.Errorf(err.Error())
        }</span>
        <span class="cov8" title="1">m.infostats.setError(err)
        return err</span>
}

// UpdateAPP updates application
func (m *Master) UpdateAPP(trace, target string) error <span class="cov8" title="1">{
        log := m.log
        isOTA := target != "" || utils.FileExists(m.cfg.OTALog.Path)
        if isOTA </span><span class="cov8" title="1">{
                log = logger.New(m.cfg.OTALog, baetyl.OTAKeyTrace, trace, baetyl.OTAKeyType, baetyl.OTAAPP)
                log.WithField(baetyl.OTAKeyStep, baetyl.OTAUpdating).Infof("app is updating")
        }</span>

        <span class="cov8" title="1">cur, old, err := m.loadAPPConfig(target)
        if err != nil </span><span class="cov8" title="1">{
                log.WithField(baetyl.OTAKeyStep, baetyl.OTARollingBack).WithError(err).Errorf("failed to reload config")
                rberr := m.rollBackAPP()
                if rberr != nil </span><span class="cov0" title="0">{
                        log.WithField(baetyl.OTAKeyStep, baetyl.OTAFailure).WithError(rberr).Errorf("failed to roll back")
                        return fmt.Errorf("failed to reload config: %s; failed to roll back: %s", err.Error(), rberr.Error())
                }</span>
                <span class="cov8" title="1">log.WithField(baetyl.OTAKeyStep, baetyl.OTARolledBack).Infof("app is rolled back")
                return fmt.Errorf("failed to reload config: %s", err.Error())</span>
        }

        // prepare services
        <span class="cov8" title="1">keepServices := diffServices(cur, old)
        m.engine.Prepare(cur)

        // stop all removed or updated services
        m.stopServices(keepServices)
        // start all updated or added services
        err = m.startServices(cur)
        if err != nil </span><span class="cov8" title="1">{
                log.WithField(baetyl.OTAKeyStep, baetyl.OTARollingBack).WithError(err).Errorf("failed to start app")
                rberr := m.rollBackAPP()
                if rberr != nil </span><span class="cov0" title="0">{
                        log.WithField(baetyl.OTAKeyStep, baetyl.OTAFailure).WithError(rberr).Errorf("failed to roll back")
                        return fmt.Errorf("failed to start app: %s; failed to roll back: %s", err.Error(), rberr.Error())
                }</span>
                // stop all updated or added services
                <span class="cov8" title="1">m.stopServices(keepServices)
                // start all removed or updated services
                rberr = m.startServices(old)
                if rberr != nil </span><span class="cov8" title="1">{
                        log.WithField(baetyl.OTAKeyStep, baetyl.OTAFailure).WithError(rberr).Errorf("failed to roll back")
                        return fmt.Errorf("failed to restart old app: %s; failed to roll back: %s", err.Error(), rberr.Error())
                }</span>
                <span class="cov8" title="1">m.commitAPP(old.AppVersion)
                log.WithField(baetyl.OTAKeyStep, baetyl.OTARolledBack).Infof("app is rolled back")
                return fmt.Errorf("failed to start app: %s", err.Error())</span>
        }
        <span class="cov8" title="1">m.commitAPP(cur.AppVersion)
        if isOTA </span><span class="cov8" title="1">{
                log.WithField(baetyl.OTAKeyStep, baetyl.OTAUpdated).Infof("app is updated")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *Master) loadAPPConfig(target string) (cur, old baetyl.ComposeAppConfig, err error) <span class="cov8" title="1">{
        if target != "" </span><span class="cov8" title="1">{
                // backup
                if utils.FileExists(appConfigFile) </span><span class="cov8" title="1">{
                        // application.yml --&gt; application.yml.old
                        err = os.Rename(appConfigFile, appBackupFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        // none --&gt; application.yml.old (empty)
                        var f *os.File
                        f, err = os.Create(appBackupFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">f.Close()</span>
                }

                <span class="cov8" title="1">if utils.FileExists(target) </span><span class="cov8" title="1">{
                        // copy {target} to application.yml
                        err = utils.CopyFile(target, appConfigFile)
                }</span> else<span class="cov8" title="1"> {
                        // copy {target}/application.yml to application.yml
                        err = utils.CopyFile(path.Join(target, baetyl.AppConfFileName), appConfigFile)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">if utils.FileExists(appConfigFile) </span><span class="cov8" title="1">{
                cur, err = baetyl.LoadComposeAppConfigCompatible(appConfigFile)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">if utils.FileExists(appBackupFile) </span><span class="cov8" title="1">{
                old, err = baetyl.LoadComposeAppConfigCompatible(appBackupFile)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (m *Master) rollBackAPP() error <span class="cov8" title="1">{
        if !utils.FileExists(appBackupFile) </span><span class="cov8" title="1">{
                return nil
        }</span>
        // application.yml.old --&gt; application.yml
        <span class="cov8" title="1">return os.Rename(appBackupFile, appConfigFile)</span>
}

func (m *Master) commitAPP(ver string) <span class="cov8" title="1">{
        defer m.log.Infof("app version (%s) committed", ver)

        // update config version
        m.infostats.setVersion(ver)
        // remove application.yml.old
        err := os.RemoveAll(appBackupFile)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Errorf("failed to remove backup file (%s)", appBackupFile)
        }</span>
}

// UpdateMST updates master
func (m *Master) UpdateMST(trace, target, backup string) (err error) <span class="cov0" title="0">{
        log := logger.New(m.cfg.OTALog, baetyl.OTAKeyTrace, trace, baetyl.OTAKeyType, baetyl.OTAMST)

        if err = m.check(target); err != nil </span><span class="cov0" title="0">{
                log.WithField(baetyl.OTAKeyStep, baetyl.OTAFailure).WithError(err).Errorf("failed to check master")
                return fmt.Errorf("failed to check master: %s", err.Error())
        }</span>

        <span class="cov0" title="0">log.WithField(baetyl.OTAKeyStep, baetyl.OTAUpdating).Infof("master is updating")
        if err = apply(target, backup); err != nil </span><span class="cov0" title="0">{
                log.WithField(baetyl.OTAKeyStep, baetyl.OTARollingBack).WithError(err).Errorf("failed to apply master")
                rberr := RollBackMST()
                if rberr != nil </span><span class="cov0" title="0">{
                        log.WithField(baetyl.OTAKeyStep, baetyl.OTAFailure).WithError(rberr).Errorf("failed to roll back")
                        return fmt.Errorf("failed to apply master: %s; failed to roll back: %s", err.Error(), rberr.Error())
                }</span>
                <span class="cov0" title="0">log.WithField(baetyl.OTAKeyStep, baetyl.OTARolledBack).Infof("master is rolled back")
                return fmt.Errorf("failed to apply master: %s", err.Error())</span>
        }

        <span class="cov0" title="0">log.WithField(baetyl.OTAKeyStep, baetyl.OTARestarting).Infof("master is restarting")
        return m.Close()</span>
}

// RollBackMST rolls back master
func RollBackMST() error <span class="cov0" title="0">{
        // backward compatibility
        backup := baetyl.DefaultBinBackupFile
        if !utils.FileExists(backup) </span><span class="cov0" title="0">{
                if !utils.FileExists(baetyl.PreviousBinBackupFile) </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        backup = baetyl.PreviousBinBackupFile
                }</span>
        }
        <span class="cov0" title="0">err := apply(backup, "")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Errorf("failed to apply backup master")
        }</span>
        <span class="cov0" title="0">err = os.RemoveAll(backup)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Errorf("failed to remove backup file (%s)", backup)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CommitMST commits master
func CommitMST() bool <span class="cov0" title="0">{
        var backup string
        if utils.PathExists(baetyl.PreviousBinBackupFile) </span><span class="cov0" title="0">{
                backup = baetyl.PreviousBinBackupFile
        }</span> else<span class="cov0" title="0"> {
                backup = baetyl.DefaultBinBackupFile
        }</span>
        <span class="cov0" title="0">if !utils.FileExists(backup) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">err := os.RemoveAll(backup)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Errorf("failed to remove backup file (%s)", backup)
        }</span>

        <span class="cov0" title="0">return true</span>
}

func apply(target, backup string) error <span class="cov0" title="0">{
        f, err := os.Open(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open binary: %s", err.Error())
        }</span>
        <span class="cov0" title="0">defer f.Close()
        err = update.Apply(f, update.Options{OldSavePath: backup})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply binary: %s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Master) check(target string) error <span class="cov0" title="0">{
        m.log.Debugf("new binary: %s", target)
        os.Chmod(target, 0755)
        cmd := exec.Command(target, "check", "-w", m.pwd, "-c", m.cfg.File)
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check result: %s", err.Error())
        }</span>
        <span class="cov0" title="0">if !strings.Contains(string(out), baetyl.CheckOK) </span><span class="cov0" title="0">{
                return fmt.Errorf("check result: OK expected, but get %s", string(out))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package http

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "strings"

        "github.com/baetyl/baetyl/utils"
        "github.com/creasty/defaults"
        "github.com/docker/go-connections/sockets"
)

const (
        headerKeyUsername = "x-openedge-username"
        headerKeyPassword = "x-openedge-password"
)

var errAccountUnauthorized = errors.New("account unauthorized")

// Client client of http server
type Client struct {
        cli *http.Client
        url *url.URL
        cfg ClientInfo
}

// NewClient creates a new http client
func NewClient(c ClientInfo) (*Client, error) <span class="cov8" title="1">{
        defaults.Set(&amp;c)

        tls, err := utils.NewTLSClientConfig(c.Certificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
        }

        var url *url.URL
        if c.Address != "" </span><span class="cov8" title="1">{
                url, err = utils.ParseURL(c.Address)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = sockets.ConfigureTransport(transport, url.Scheme, url.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if url.Scheme == "unix" </span><span class="cov8" title="1">{
                        url.Host = "baetyl"
                }</span>
                <span class="cov8" title="1">if url.Scheme != "http" &amp;&amp; url.Scheme != "https" </span><span class="cov8" title="1">{
                        url.Scheme = "http"
                }</span>
        }
        <span class="cov8" title="1">return &amp;Client{
                cfg: c,
                url: url,
                cli: &amp;http.Client{
                        Timeout:   c.Timeout,
                        Transport: transport,
                },
        }, nil</span>
}

// Get sends get request
func (c *Client) Get(path string, params ...interface{}) ([]byte, error) <span class="cov8" title="1">{
        return c.SendPath("GET", fmt.Sprintf(path, params...), nil, c.genHeader())
}</span>

// Put sends put request
func (c *Client) Put(body []byte, path string, params ...interface{}) ([]byte, error) <span class="cov8" title="1">{
        return c.SendPath("PUT", fmt.Sprintf(path, params...), body, c.genHeader())
}</span>

// Post sends post request
func (c *Client) Post(body []byte, path string, params ...interface{}) ([]byte, error) <span class="cov8" title="1">{
        return c.SendPath("POST", fmt.Sprintf(path, params...), body, c.genHeader())
}</span>

// SendPath sends http request by path
func (c *Client) SendPath(method, path string, body []byte, header map[string]string) ([]byte, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s://%s%s", c.url.Scheme, c.url.Host, path)
        res, err := c.SendUrl(method, url, bytes.NewBuffer(body), header)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var resBody []byte
        if res != nil </span><span class="cov8" title="1">{
                defer res.Close()
                resBody, err = ioutil.ReadAll(res)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return resBody, nil</span>
}

// SendUrl sends http request by url
func (c *Client) SendUrl(method, url string, body io.Reader, header map[string]string) (io.ReadCloser, error) <span class="cov8" title="1">{
        req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header = Headers{}
        if header != nil </span><span class="cov8" title="1">{
                for k, v := range header </span><span class="cov8" title="1">{
                        req.Header.Set(k, v)
                }</span>
        }
        <span class="cov8" title="1">res, err := c.cli.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if res.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                var resBody []byte
                if res.Body != nil </span><span class="cov8" title="1">{
                        defer res.Body.Close()
                        resBody, _ = ioutil.ReadAll(res.Body)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("[%d] %s", res.StatusCode, strings.TrimRight(string(resBody), "\n"))</span>
        }
        <span class="cov8" title="1">return res.Body, nil</span>
}

func (c *Client) genHeader() map[string]string <span class="cov8" title="1">{
        header := map[string]string{"Content-Type": "application/json"}
        if c.cfg.Username != "" </span><span class="cov8" title="1">{
                header[headerKeyUsername] = c.cfg.Username
        }</span>
        <span class="cov8" title="1">if c.cfg.Password != "" </span><span class="cov8" title="1">{
                header[headerKeyPassword] = c.cfg.Password
        }</span>
        <span class="cov8" title="1">return header</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package http

import (
        "context"
        "io/ioutil"
        "net"
        "net/http"
        "net/url"
        "syscall"
        "time"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/utils"
        "github.com/creasty/defaults"
        "github.com/gorilla/mux"
)

// Params http params
type Params = map[string]string

// Headers http headers
type Headers = http.Header

// Server http server
type Server struct {
        cfg    ServerInfo
        svr    *http.Server
        uri    *url.URL
        addr   string
        auth   func(u, p string) bool
        router *mux.Router
        log    logger.Logger
}

// NewServer creates a new http server
func NewServer(c ServerInfo, a func(u, p string) bool) (*Server, error) <span class="cov8" title="1">{
        defaults.Set(&amp;c)

        uri, err := utils.ParseURL(c.Address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tls, err := utils.NewTLSServerConfig(c.Certificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">router := mux.NewRouter()
        return &amp;Server{
                cfg:    c,
                auth:   a,
                uri:    uri,
                router: router,
                svr: &amp;http.Server{
                        WriteTimeout: c.Timeout,
                        ReadTimeout:  c.Timeout,
                        TLSConfig:    tls,
                        Handler:      router,
                },
                log: logger.WithField("api", "server"),
        }, nil</span>
}

// Handle handle requests
func (s *Server) Handle(handle func(Params, []byte) ([]byte, error), method, path string, params ...string) <span class="cov8" title="1">{
        s.router.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                s.log.Infof("[%s] %s", req.Method, req.URL.String())
                if s.auth != nil </span><span class="cov8" title="1">{
                        if !s.auth(req.Header.Get(headerKeyUsername), req.Header.Get(headerKeyPassword)) </span><span class="cov8" title="1">{
                                http.Error(res, errAccountUnauthorized.Error(), 401)
                                s.log.Errorf("[%s] %s %s", req.Method, req.URL.String(), errAccountUnauthorized.Error())
                                return
                        }</span>
                }
                <span class="cov8" title="1">var err error
                var reqBody []byte
                if req.Body != nil </span><span class="cov8" title="1">{
                        defer req.Body.Close()
                        reqBody, err = ioutil.ReadAll(req.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(res, err.Error(), 400)
                                s.log.Errorf("[%s] %s %s", req.Method, req.URL.String(), err.Error())
                                return
                        }</span>
                }
                <span class="cov8" title="1">resBody, err := handle(mux.Vars(req), reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), 400)
                        s.log.Errorf("[%s] %s %s", req.Method, req.URL.String(), err.Error())
                        return
                }</span>
                <span class="cov8" title="1">if resBody != nil </span><span class="cov8" title="1">{
                        res.Write(resBody)
                }</span>
        }).Methods(method).Queries(params...)
}

// Start starts server
func (s *Server) Start() error <span class="cov8" title="1">{
        if s.uri.Scheme == "unix" </span><span class="cov8" title="1">{
                if err := syscall.Unlink(s.uri.Host); err != nil </span><span class="cov8" title="1">{
                        s.log.Errorf(err.Error())
                }</span>
        }

        <span class="cov8" title="1">l, err := net.Listen(s.uri.Scheme, s.uri.Host)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if s.uri.Scheme == "tcp" </span><span class="cov8" title="1">{
                l = tcpKeepAliveListener{l.(*net.TCPListener)}
        }</span>
        <span class="cov8" title="1">s.addr = l.Addr().String()
        go s.svr.Serve(l)
        return nil</span>
}

// Close closese server
func (s *Server) Close() error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), s.svr.IdleTimeout)
        defer cancel()
        return s.svr.Shutdown(ctx)
}</span>

// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted
// connections. It's used by ListenAndServe and ListenAndServeTLS so
// dead TCP connections (e.g. closing laptop mid-download) eventually
// go away.
type tcpKeepAliveListener struct {
        *net.TCPListener
}

func (ln tcpKeepAliveListener) Accept() (net.Conn, error) <span class="cov8" title="1">{
        tc, err := ln.AcceptTCP()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tc.SetKeepAlive(true)
        tc.SetKeepAlivePeriod(3 * time.Minute)
        return tc, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package mqtt

import (
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/256dpi/gomqtt/client"
        "github.com/256dpi/gomqtt/packet"
        "github.com/256dpi/gomqtt/transport"
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/utils"
        "github.com/creasty/defaults"
        tomb "gopkg.in/tomb.v2"
)

// A Client connects to a broker and handles the transmission of packets
type Client struct {
        conn            transport.Conn
        config          ClientInfo
        tracker         *client.Tracker
        connectFuture   *Future
        subscribeFuture *Future
        handler         Handler
        finish          sync.Once
        tomb            utils.Tomb
        log             logger.Logger
}

// NewClient returns a new client
func NewClient(cc ClientInfo, handler Handler, log logger.Logger) (*Client, error) <span class="cov8" title="1">{
        defaults.Set(&amp;cc)
        if log == nil </span><span class="cov8" title="1">{
                log = logger.Global
        }</span>

        <span class="cov8" title="1">dialer, err := NewDialer(cc.Certificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">conn, err := dialer.Dial(cc.Address)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c := &amp;Client{
                conn:            conn,
                config:          cc,
                handler:         handler,
                connectFuture:   NewFuture(),
                subscribeFuture: NewFuture(),
                tracker:         client.NewTracker(cc.KeepAlive),
                log:             log.WithField("mqtt", "client"),
        }
        err = c.connect()
        if err != nil </span><span class="cov8" title="1">{
                c.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">return c, nil</span>
}

func (c *Client) connect() (err error) <span class="cov8" title="1">{
        // allocate packet
        connect := packet.NewConnect()
        connect.ClientID = c.config.ClientID
        connect.KeepAlive = uint16(c.config.KeepAlive.Seconds())
        connect.CleanSession = c.config.CleanSession
        connect.Username = c.config.Username
        connect.Password = c.config.Password
        // connect.Will = c.config.WillMessage

        // send connect packet
        err = c.send(connect, false)
        if err != nil </span><span class="cov0" title="0">{
                return c.die(err)
        }</span>

        // start process routine
        <span class="cov8" title="1">c.tomb.Go(c.processor)

        if len(c.config.Subscriptions) == 0 </span><span class="cov8" title="1">{
                err = c.connectFuture.Wait(c.config.Timeout)
                if err != nil </span><span class="cov8" title="1">{
                        return c.die(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // allocate subscribe packet
        <span class="cov8" title="1">subscribe := packet.NewSubscribe()
        subscribe.ID = 1
        subscribe.Subscriptions = make([]packet.Subscription, 0)
        for _, s := range c.config.Subscriptions </span><span class="cov8" title="1">{
                subscribe.Subscriptions = append(subscribe.Subscriptions, packet.Subscription{
                        Topic: s.Topic,
                        QOS:   packet.QOS(s.QOS),
                })
        }</span>

        // send packet
        <span class="cov8" title="1">err = c.send(subscribe, true)
        if err != nil </span><span class="cov0" title="0">{
                return c.die(err)
        }</span>

        <span class="cov8" title="1">err = c.connectFuture.Wait(c.config.Timeout)
        if err != nil </span><span class="cov0" title="0">{
                return c.die(fmt.Errorf("failed to wait connect ack: %s", err.Error()))
        }</span>
        <span class="cov8" title="1">c.log.Debugf("connected")

        err = c.subscribeFuture.Wait(c.config.Timeout)
        if err != nil </span><span class="cov8" title="1">{
                return c.die(fmt.Errorf("failed to wait subscribe ack: %s", err.Error()))
        }</span>
        <span class="cov8" title="1">c.log.Debugf("subscribed")
        return nil</span>
}

// Send sends a generic packet
func (c *Client) Send(p packet.Generic) (err error) <span class="cov8" title="1">{
        err = c.send(p, true)
        if err != nil </span><span class="cov0" title="0">{
                c.die(err)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Dying returns the channel that can be used to wait until client closed
func (c *Client) Dying() &lt;-chan struct{} <span class="cov0" title="0">{
        return c.tomb.Dying()
}</span>

// Close closes the client after sending a disconnect packet
func (c *Client) Close() error <span class="cov8" title="1">{
        c.die(nil)
        return c.tomb.Wait()
}</span>

/* processor goroutine */

// processes incoming packets
func (c *Client) processor() error <span class="cov8" title="1">{
        c.log.Debugln("processor starting ")
        defer c.log.Debugln("processor stopped")

        if c.config.KeepAlive &gt; 0 </span><span class="cov8" title="1">{
                c.tomb.Go(c.pinger)
        }</span>

        <span class="cov8" title="1">first := true

        for </span><span class="cov8" title="1">{
                // get next packet from connection
                pkt, err := c.conn.Receive()
                if err != nil </span><span class="cov8" title="1">{
                        if !c.tomb.Alive() </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                                err = client.ErrClientNotConnected
                        }</span>
                        <span class="cov8" title="1">return c.die(err)</span>
                }

                <span class="cov8" title="1">if first </span><span class="cov8" title="1">{
                        first = false
                        connack, ok := pkt.(*packet.Connack)
                        if !ok </span><span class="cov8" title="1">{
                                err = client.ErrClientExpectedConnack
                                return c.die(err)
                        }</span>

                        <span class="cov8" title="1">if connack.ReturnCode != packet.ConnectionAccepted </span><span class="cov8" title="1">{
                                err = fmt.Errorf(connack.ReturnCode.String())
                                return c.die(err)
                        }</span>

                        <span class="cov8" title="1">c.connectFuture.Complete()
                        continue</span>
                }

                <span class="cov8" title="1">switch p := pkt.(type) </span>{
                case *packet.Publish:<span class="cov8" title="1">
                        c.log.Debugf("received: %s, pid: %d, qos: %d, topic: %s", p.Type(), p.ID, p.Message.QOS, p.Message.Topic)
                        if c.handler != nil </span><span class="cov8" title="1">{
                                err = c.handler.ProcessPublish(p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return c.die(err)
                                }</span>
                        }
                case *packet.Puback:<span class="cov8" title="1">
                        c.log.Debugf("received: %s, pid: %d", p.Type(), p.ID)
                        if c.handler != nil </span><span class="cov8" title="1">{
                                err = c.handler.ProcessPuback(p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return c.die(err)
                                }</span>
                        }
                case *packet.Suback:<span class="cov8" title="1">
                        c.log.Debugf("received: %s, pid: %d", p.Type(), p.ID)
                        if c.config.ValidateSubs </span><span class="cov8" title="1">{
                                for _, code := range p.ReturnCodes </span><span class="cov8" title="1">{
                                        if code == packet.QOSFailure </span><span class="cov8" title="1">{
                                                err = client.ErrFailedSubscription
                                                return c.die(err)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">c.subscribeFuture.Complete()</span>
                case *packet.Pingresp:<span class="cov8" title="1">
                        c.log.Debugln("received:", p.Type())
                        c.tracker.Pong()</span>
                case *packet.Connack:<span class="cov8" title="1">
                        c.log.Debugln("received:", p.Type())
                        err = client.ErrClientAlreadyConnecting
                        return c.die(err)</span>
                default:<span class="cov0" title="0">
                        return c.die(fmt.Errorf("packet (%v) not supported", p))</span>
                }
        }
}

/* pinger goroutine */

// manages the sending of ping packets to keep the connection alive
func (c *Client) pinger() (err error) <span class="cov8" title="1">{
        c.log.Debugln("pinger starting")
        defer c.log.Debugln("pinger stopped")

        for </span><span class="cov8" title="1">{
                // get current window
                window := c.tracker.Window()

                // check if ping is due
                if window &lt; 0 </span><span class="cov8" title="1">{
                        // check if a pong has already been sent
                        if c.tracker.Pending() </span><span class="cov8" title="1">{
                                err = client.ErrClientMissingPong
                                return c.die(err)
                        }</span>

                        // send pingreq packet
                        <span class="cov8" title="1">err = c.send(packet.NewPingreq(), false)
                        if err != nil </span><span class="cov0" title="0">{
                                return c.die(err)
                        }</span>

                        // save ping attempt
                        <span class="cov8" title="1">c.tracker.Ping()</span>
                }

                <span class="cov8" title="1">select </span>{
                case &lt;-c.tomb.Dying():<span class="cov8" title="1">
                        return tomb.ErrDying</span>
                case &lt;-time.After(window):<span class="cov8" title="1">
                        continue</span>
                }
        }
}

/* helpers */

// sends packet and updates lastSend
func (c *Client) send(pkt packet.Generic, async bool) error <span class="cov8" title="1">{

        // reset keep alive tracker
        c.tracker.Reset()

        // send packet
        err := c.conn.Send(pkt, async)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.log.Debugln("sent:", pkt.Type())

        return nil</span>
}

// used for closing and cleaning up from internal goroutines
func (c *Client) die(err error) error <span class="cov8" title="1">{
        c.finish.Do(func() </span><span class="cov8" title="1">{
                if err == nil </span><span class="cov8" title="1">{
                        c.send(packet.NewDisconnect(), false)
                }</span> else<span class="cov8" title="1"> {
                        if c.handler != nil </span><span class="cov8" title="1">{
                                c.handler.ProcessError(err)
                        }</span>
                        // c.log.WithError(err).Errorln("MQTT client raises error")
                }
                <span class="cov8" title="1">c.tomb.Kill(err)
                c.connectFuture.Cancel(err)
                c.subscribeFuture.Cancel(err)
                if c.conn != nil </span><span class="cov8" title="1">{
                        c.conn.Close()
                }</span>
        })
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package mqtt

import (
        "net/url"

        "github.com/256dpi/gomqtt/transport"
        "github.com/baetyl/baetyl/utils"
)

// The Dialer handles connecting to a server and creating a connection.
type Dialer struct {
        *transport.Dialer
}

// NewDialer returns a new Dialer.
func NewDialer(c utils.Certificate) (*Dialer, error) <span class="cov8" title="1">{
        tls, err := utils.NewTLSClientConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">d := &amp;Dialer{Dialer: transport.NewDialer()}
        d.TLSConfig = tls
        return d, nil</span>
}

// Dial initiates a connection based in information extracted from an URL.
func (d *Dialer) Dial(urlString string) (transport.Conn, error) <span class="cov8" title="1">{
        uri, err := url.ParseRequestURI(urlString)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if uri.Scheme == "ssl" </span><span class="cov0" title="0">{
                uri.Scheme = "tls"
        }</span>
        <span class="cov8" title="1">return d.Dialer.Dial(uri.String())</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package mqtt

import (
        "fmt"
        "time"

        "github.com/256dpi/gomqtt/packet"
        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/utils"
        "github.com/jpillora/backoff"
)

// ErrDispatcherClosed is returned if the dispatcher is closed
var ErrDispatcherClosed = fmt.Errorf("dispatcher already closed")

// Dispatcher dispatcher of mqtt client
type Dispatcher struct {
        config  ClientInfo
        channel chan packet.Generic
        backoff *backoff.Backoff
        tomb    utils.Tomb
        log     logger.Logger
}

// NewDispatcher creates a new dispatcher
func NewDispatcher(cc ClientInfo, log logger.Logger) *Dispatcher <span class="cov0" title="0">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.Global
        }</span>
        <span class="cov0" title="0">return &amp;Dispatcher{
                config:  cc,
                channel: make(chan packet.Generic, cc.BufferSize),
                backoff: &amp;backoff.Backoff{
                        Min:    time.Millisecond * 500,
                        Max:    cc.Interval,
                        Factor: 2,
                },
                log: log.WithField("mqtt", "dispatcher").WithField("cid", cc.ClientID),
        }</span>
}

// Publish sends a publish packet
func (d *Dispatcher) Publish(pid uint16, qos uint32, topic string, payload []byte, retain bool, duplicate bool) error <span class="cov0" title="0">{
        pkt := packet.NewPublish()
        pkt.ID = packet.ID(pid)
        pkt.Dup = duplicate
        pkt.Message.QOS = packet.QOS(qos)
        pkt.Message.Topic = topic
        pkt.Message.Payload = payload
        pkt.Message.Retain = retain
        return d.Send(pkt)
}</span>

// Send sends a generic packet
func (d *Dispatcher) Send(pkt packet.Generic) error <span class="cov0" title="0">{
        select </span>{
        case d.channel &lt;- pkt:<span class="cov0" title="0"></span>
        case &lt;-d.tomb.Dying():<span class="cov0" title="0">
                return ErrDispatcherClosed</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Start starts dispatcher
func (d *Dispatcher) Start(h Handler) error <span class="cov0" title="0">{
        return d.tomb.Go(func() error </span><span class="cov0" title="0">{
                return d.supervisor(h)
        }</span>)
}

// Close closes dispatcher
func (d *Dispatcher) Close() error <span class="cov0" title="0">{
        d.tomb.Kill(nil)
        return d.tomb.Wait()
}</span>

// Supervisor the supervised reconnect loop
func (d *Dispatcher) supervisor(handler Handler) error <span class="cov0" title="0">{
        first := true
        var dying bool
        var current packet.Generic

        for </span><span class="cov0" title="0">{
                if first </span><span class="cov0" title="0">{
                        // no delay on first attempt
                        first = false
                }</span> else<span class="cov0" title="0"> {
                        // get backoff duration
                        next := d.backoff.Duration()

                        d.log.Debugln("delay reconnect:", next)

                        // sleep but return on Stop
                        select </span>{
                        case &lt;-time.After(next):<span class="cov0" title="0"></span>
                        case &lt;-d.tomb.Dying():<span class="cov0" title="0">
                                return nil</span>
                        }
                }

                <span class="cov0" title="0">d.log.Debugln("next reconnect")

                client, err := NewClient(d.config, handler, d.log)
                if err != nil </span><span class="cov0" title="0">{
                        d.log.WithError(err).Errorln("failed to create new client")
                        continue</span>
                }

                // run callback
                <span class="cov0" title="0">d.log.Debugln("client online")

                // run dispatcher on client
                current, dying = d.dispatcher(client, current)

                // run callback
                d.log.Debugln("client offline")

                // return goroutine if dying
                if dying </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
}

// reads from the queues and calls the current client
func (d *Dispatcher) dispatcher(client *Client, current packet.Generic) (packet.Generic, bool) <span class="cov0" title="0">{
        defer client.Close()

        if current != nil </span><span class="cov0" title="0">{
                err := client.Send(current)
                if err != nil </span><span class="cov0" title="0">{
                        return current, false
                }</span>
        }

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case pkt := &lt;-d.channel:<span class="cov0" title="0">
                        err := client.Send(pkt)
                        if err != nil </span><span class="cov0" title="0">{
                                return pkt, false
                        }</span>
                case &lt;-client.Dying():<span class="cov0" title="0">
                        return nil, false</span>
                case &lt;-d.tomb.Dying():<span class="cov0" title="0">
                        return nil, true</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package mqtt

import (
        "time"

        "github.com/256dpi/gomqtt/client/future"
)

const errorKey = "error"

// A Future is a low-level future type that can be extended to transport
// custom information.
type Future struct {
        f *future.Future
}

// NewFuture will return a new Future.
func NewFuture() *Future <span class="cov8" title="1">{
        return &amp;Future{
                f: future.New(),
        }
}</span>

// Wait will wait the given amount of time and return whether the future has been
// completed, canceled or the request timed out.
func (f *Future) Wait(timeout time.Duration) (err error) <span class="cov8" title="1">{
        err = f.f.Wait(timeout)
        if err != nil </span><span class="cov8" title="1">{
                actaul, ok := f.f.Data.Load(errorKey)
                if ok </span><span class="cov8" title="1">{
                        err = actaul.(error)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Complete will complete the future.
func (f *Future) Complete() <span class="cov8" title="1">{
        f.f.Complete()
}</span>

// Cancel will cancel the future with an error.
func (f *Future) Cancel(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                f.f.Data.Store(errorKey, err)
        }</span>
        <span class="cov8" title="1">f.f.Cancel()</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package mqtt

import "github.com/256dpi/gomqtt/packet"

// ProcessPublish handles publish packet
type ProcessPublish func(*packet.Publish) error

// ProcessPuback handles puback packet
type ProcessPuback func(*packet.Puback) error

// ProcessError handles error
type ProcessError func(error)

// Handler MQTT message handler interface
type Handler interface {
        ProcessPublish(*packet.Publish) error
        ProcessPuback(*packet.Puback) error
        ProcessError(error)
}

// HandlerWrapper MQTT message handler wrapper
type HandlerWrapper struct {
        onPublish ProcessPublish
        onPuback  ProcessPuback
        onError   ProcessError
}

// NewHandlerWrapper creates a new handler wrapper
func NewHandlerWrapper(onPublish ProcessPublish, onPuback ProcessPuback, onError ProcessError) *HandlerWrapper <span class="cov0" title="0">{
        return &amp;HandlerWrapper{
                onPublish: onPublish,
                onPuback:  onPuback,
                onError:   onError,
        }
}</span>

// ProcessPublish handles publish packet
func (h *HandlerWrapper) ProcessPublish(pkt *packet.Publish) error <span class="cov0" title="0">{
        if h.onPublish == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return h.onPublish(pkt)</span>
}

// ProcessPuback handles puback packet
func (h *HandlerWrapper) ProcessPuback(pkt *packet.Puback) error <span class="cov0" title="0">{
        if h.onPuback == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return h.onPuback(pkt)</span>
}

// ProcessError handles error
func (h *HandlerWrapper) ProcessError(err error) <span class="cov0" title="0">{
        if h.onError == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.onError(err)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package mqtt

import (
        "net/url"

        "github.com/256dpi/gomqtt/transport"
        "github.com/baetyl/baetyl/utils"
)

// The Launcher helps with launching a server and accepting connections.
type Launcher struct {
        transport.Launcher
}

// NewLauncher returns a new Launcher.
func NewLauncher(c utils.Certificate) (*Launcher, error) <span class="cov0" title="0">{
        t, err := utils.NewTLSServerConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Launcher{Launcher: transport.Launcher{TLSConfig: t}}, nil</span>
}

// Launch will launch a server based on information extracted from an URL.
func (l *Launcher) Launch(urlString string) (transport.Server, error) <span class="cov0" title="0">{
        uri, err := url.ParseRequestURI(urlString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if uri.Scheme == "ssl" </span><span class="cov0" title="0">{
                uri.Scheme = "tls"
        }</span>
        <span class="cov0" title="0">return l.Launcher.Launch(uri.String())</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package mqtt

import (
        "crypto/tls"
        "net"

        "github.com/256dpi/gomqtt/transport"
)

// IsTwoWayTLS check two-way tls connection
func IsTwoWayTLS(conn transport.Conn) bool <span class="cov0" title="0">{
        var inner net.Conn
        if tcps, ok := conn.(*transport.NetConn); ok </span><span class="cov0" title="0">{
                inner = tcps.UnderlyingConn()
        }</span> else<span class="cov0" title="0"> if wss, ok := conn.(*transport.WebSocketConn); ok </span><span class="cov0" title="0">{
                inner = wss.UnderlyingConn().UnderlyingConn()
        }</span>
        <span class="cov0" title="0">tlsconn, ok := inner.(*tls.Conn)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">state := tlsconn.ConnectionState()
        if !state.HandshakeComplete </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return len(state.PeerCertificates) &gt; 0</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package baetyl

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/baetyl/baetyl/protocol/http"
)

// Client client of api server
type Client struct {
        cli *http.Client
        ver string
}

// NewEnvClient creates a new client by env
func NewEnvClient() (*Client, error) <span class="cov8" title="1">{
        addr := os.Getenv(EnvKeyMasterAPIAddress)
        name := os.Getenv(EnvKeyServiceName)
        token := os.Getenv(EnvKeyServiceToken)
        version := os.Getenv(EnvKeyMasterAPIVersion)
        if len(addr) == 0 </span><span class="cov8" title="1">{
                // TODO: remove, backward compatibility
                addr = os.Getenv(EnvMasterAPIKey)
                if len(addr) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Env (%s) not found", EnvKeyMasterAPIAddress)
                }</span>
                <span class="cov8" title="1">name = os.Getenv(EnvServiceNameKey)
                token = os.Getenv(EnvServiceTokenKey)
                version = os.Getenv(EnvMasterAPIVersionKey)</span>
        }
        <span class="cov8" title="1">c := http.ClientInfo{
                Address:  addr,
                Username: name,
                Password: token,
        }
        return NewClient(c, version)</span>
}

// NewClient creates a new client
func NewClient(c http.ClientInfo, ver string) (*Client, error) <span class="cov8" title="1">{
        cli, err := http.NewClient(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if ver != "" &amp;&amp; !strings.HasPrefix(ver, "/") </span><span class="cov8" title="1">{
                ver = "/" + ver
        }</span>
        <span class="cov8" title="1">return &amp;Client{
                cli: cli,
                ver: ver,
        }, nil</span>
}

// InspectSystem inspect all stats
func (c *Client) InspectSystem() (*Inspect, error) <span class="cov0" title="0">{
        body, err := c.cli.Get(c.ver + "/system/inspect")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s := new(Inspect)
        err = json.Unmarshal(body, s)
        return s, err</span>
}

// UpdateSystem updates and reloads config
func (c *Client) UpdateSystem(trace, tp, path string) error <span class="cov0" title="0">{
        data, err := json.Marshal(map[string]string{
                "type":  tp,
                "path":  path,
                "file":  path, // backward compatibility, master version &lt; 0.1.4
                "trace": trace,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = c.cli.Put(data, c.ver+"/system/update")
        return err</span>
}

// GetAvailablePort gets available port
func (c *Client) GetAvailablePort() (string, error) <span class="cov0" title="0">{
        res, err := c.cli.Get(c.ver + "/ports/available")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">info := make(map[string]string)
        err = json.Unmarshal(res, &amp;info)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">port, ok := info["port"]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid response, port not found")
        }</span>
        <span class="cov0" title="0">return port, nil</span>
}

// ReportInstance reports the stats of the instance of the service
func (c *Client) ReportInstance(serviceName, instanceName string, stats map[string]interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(stats)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = c.cli.Put(data, c.ver+"/services/%s/instances/%s/report", serviceName, instanceName)
        return err</span>
}

// StartInstance starts a new service instance with dynamic config
func (c *Client) StartInstance(serviceName, instanceName string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        data, err := json.Marshal(dynamicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = c.cli.Put(data, c.ver+"/services/%s/instances/%s/start", serviceName, instanceName)
        return err</span>
}

// StopInstance stops a service instance
func (c *Client) StopInstance(serviceName, instanceName string) error <span class="cov0" title="0">{
        _, err := c.cli.Put(nil, c.ver+"/services/%s/instances/%s/stop", serviceName, instanceName)
        return err
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package baetyl

import (
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/protocol/mqtt"
        "github.com/baetyl/baetyl/utils"
        units "github.com/docker/go-units"
)

// ServiceConfig base config of service
type ServiceConfig struct {
        Hub    mqtt.ClientInfo `yaml:"hub" json:"hub"`
        Logger logger.LogInfo  `yaml:"logger" json:"logger"`
}

// RestartPolicies
const (
        RestartNo        = "no"
        RestartAlways    = "always"
        RestartOnFailure = "on-failure"
)

// RestartPolicyInfo holds the policy of a module
type RestartPolicyInfo struct {
        Retry struct {
                Max int `yaml:"max" json:"max"`
        } `yaml:"retry" json:"retry"`
        Policy  string      `yaml:"policy" json:"policy" default:"always"`
        Backoff BackoffInfo `yaml:"backoff" json:"backoff"`
}

// BackoffInfo holds backoff value
type BackoffInfo struct {
        Min    time.Duration `yaml:"min" json:"min" default:"1s" validate:"min=1000000000"`
        Max    time.Duration `yaml:"max" json:"max" default:"5m" validate:"min=1000000000"`
        Factor float64       `yaml:"factor" json:"factor" default:"2" validate:"min=1"`
}

// Resources resources config
type Resources struct {
        CPU    CPU    `yaml:"cpu" json:"cpu"`
        Pids   Pids   `yaml:"pids" json:"pids"`
        Memory Memory `yaml:"memory" json:"memory"`
}

// CPU cpu config
type CPU struct {
        Cpus    float64 `yaml:"cpus" json:"cpus"`
        SetCPUs string  `yaml:"setcpus" json:"setcpus"`
}

// Pids pids config
type Pids struct {
        Limit int64 `yaml:"limit" json:"limit"`
}

// Memory memory config
type Memory struct {
        Limit int64 `yaml:"limit" json:"limit"`
        Swap  int64 `yaml:"swap" json:"swap"`
}

type memory struct {
        Limit string `yaml:"limit" json:"limit"`
        Swap  string `yaml:"swap" json:"swap"`
}

// UnmarshalYAML customizes unmarshal
func (m *Memory) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov0" title="0">{
        var ms memory
        err := unmarshal(&amp;ms)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ms.Limit != "" </span><span class="cov0" title="0">{
                m.Limit, err = units.RAMInBytes(ms.Limit)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if ms.Swap != "" </span><span class="cov0" title="0">{
                m.Swap, err = units.RAMInBytes(ms.Swap)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

/* function */

// FunctionClientConfig function client config
type FunctionClientConfig struct {
        Address string `yaml:"address" json:"address"`
        Message struct {
                Length utils.Length `yaml:"length" json:"length" default:"{\"max\":4194304}"`
        } `yaml:"message" json:"message"`
        Backoff struct {
                Max time.Duration `yaml:"max" json:"max" default:"1m"`
        } `yaml:"backoff" json:"backoff"`
        Timeout time.Duration `yaml:"timeout" json:"timeout" default:"30s"`
}

// FunctionServerConfig function server config
type FunctionServerConfig struct {
        Address string        `yaml:"address" json:"address"`
        Timeout time.Duration `yaml:"timeout" json:"timeout" default:"2m"`
        Message struct {
                Length utils.Length `yaml:"length" json:"length" default:"{\"max\":4194304}"`
        } `yaml:"message" json:"message"`
        Concurrent struct {
                Max uint32 `yaml:"max" json:"max"`
        } `yaml:"concurrent" json:"concurrent"`
        // for python function server
        Workers struct {
                Max uint32 `yaml:"max" json:"max"`
        } `yaml:"workers" json:"workers"`
        utils.Certificate `yaml:",inline" json:",inline"`
}

// NetworksInfo network configurations of service
type NetworksInfo struct {
        ServiceNetworks map[string]ServiceNetwork `yaml:"networks" json:"networks"`
}

// ServiceNetwork specific network configuration of service
type ServiceNetwork struct {
        Aliases     []string `yaml:"aliases" json:"aliases"`
        Ipv4Address string   `yaml:"ipv4_address" json:"ipv4_address"`
}

// UnmarshalYAML customizes unmarshal
func (sn *NetworksInfo) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        if sn.ServiceNetworks == nil </span><span class="cov8" title="1">{
                sn.ServiceNetworks = make(map[string]ServiceNetwork)
        }</span>
        <span class="cov8" title="1">var networks interface{}
        err := unmarshal(&amp;networks)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch reflect.ValueOf(networks).Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                for _, item := range networks.([]interface{}) </span><span class="cov8" title="1">{
                        name := item.(string)
                        sn.ServiceNetworks[name] = ServiceNetwork{}
                }</span>
        case reflect.Map:<span class="cov8" title="1">
                return unmarshal(&amp;sn.ServiceNetworks)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to parse service network: unexpected type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ComposeAppConfig application configuration of compose
type ComposeAppConfig struct {
        // specifies the version of compose file
        Version string `yaml:"version" json:"version"`
        // specifies the app version of the application configuration
        AppVersion string `yaml:"app_version" json:"app_version"`
        // specifies the service information of the application
        Services map[string]ComposeService `yaml:"services" json:"services" default:"{}"`
        // specifies the storage volume information of the application
        Volumes map[string]ComposeVolume `yaml:"volumes" json:"volumes" default:"{}"`
        // specifies the network information of the application
        Networks map[string]ComposeNetwork `yaml:"networks" json:"networks" default:"{}"`
}

// ComposeService service configuration of compose
type ComposeService struct {
        // specifies the unique name of the service
        ContainerName string `yaml:"container_name" json:"container_name"`
        // specifies the hostname of the service
        Hostname string `yaml:"hostname" json:"hostname"`
        // specifies the image of the service, usually using the Docker image name
        Image string `yaml:"image" json:"image" validate:"nonzero"`
        // specifies the number of instances started
        Replica int `yaml:"replica" json:"replica" validate:"min=0"`
        // specifies the storage volumes that the service needs, map the storage volume to the directory in the container
        Volumes []ServiceVolume `yaml:"volumes" json:"volumes"`
        // specifies the network mode of the service
        NetworkMode string `yaml:"network_mode" json:"network_mode" validate:"regexp=^(bridge|host|none)?$"`
        // specifies the network that the service needs
        Networks NetworksInfo `yaml:"networks" json:"networks"`
        // specifies the port bindings which exposed by the service, only for Docker container mode
        Ports []string `yaml:"ports" json:"ports" default:"[]"`
        // specifies the device bindings which used by the service, only for Docker container mode
        Devices []string `yaml:"devices" json:"devices" default:"[]"`
        // specified other depended services
        DependsOn []string `yaml:"depends_on" json:"depends_on" default:"[]"`
        // specifies the startup arguments of the service program, but does not include `arg[0]`
        Command Command `yaml:"command" json:"command"`
        // specifies the environment variable of the service program
        Environment Environment `yaml:"environment" json:"environment" default:"{}"`
        // specifies the restart policy of the instance of the service
        Restart RestartPolicyInfo `yaml:"restart" json:"restart"`
        // specifies resource limits for a single instance of the service,  only for Docker container mode
        Resources Resources `yaml:"resources" json:"resources"`
        // specifies runtime to use, only for Docker container mode
        Runtime string `yaml:"runtime" json:"runtime"`
}

// ComposeVolume volume configuration of compose
type ComposeVolume struct {
        // specified driver for the storage volume
        Driver string `yaml:"driver" json:"driver" default:"local"`
        // specified driver options for the storage volume
        DriverOpts map[string]string `yaml:"driver_opts" json:"driver_opts" default:"{}"`
        // specified labels for the storage volume
        Labels map[string]string `yaml:"labels" json:"labels" default:"{}"`
}

// ComposeNetwork network configuration
type ComposeNetwork struct {
        // specifies driver for network
        Driver string `yaml:"driver" json:"driver" default:"bridge"`
        // specified driver options for network
        DriverOpts map[string]string `yaml:"driver_opts" json:"driver_opts" default:"{}"`
        // specifies labels to add metadata
        Labels map[string]string `yaml:"labels" json:"labels" default:"{}"`
}

// Environment environment
type Environment struct {
        Envs map[string]string `yaml:"envs" json:"envs" default:"{}"`
}

// UnmarshalYAML customize unmarshal
func (e *Environment) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        if e.Envs == nil </span><span class="cov8" title="1">{
                e.Envs = make(map[string]string)
        }</span>
        <span class="cov8" title="1">var envs interface{}
        err := unmarshal(&amp;envs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if envs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch reflect.ValueOf(envs).Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                for _, env := range envs.([]interface{}) </span><span class="cov8" title="1">{
                        envStr := env.(string)
                        es := strings.Split(envStr, "=")
                        if len(es) != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("environment format error")
                        }</span>
                        <span class="cov8" title="1">e.Envs[es[0]] = es[1]</span>
                }
        case reflect.Map:<span class="cov8" title="1">
                return unmarshal(&amp;e.Envs)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to parse environment: unexpected type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ServiceVolume specific volume configuration of service
type ServiceVolume struct {
        // specifies type of volume
        Type string `yaml:"type" json:"type" validate:"regexp=^(volume|bind)?$"`
        // specifies source of volume
        Source string `yaml:"source" json:"source"`
        // specifies target of volume
        Target string `yaml:"target" json:"target"`
        // specifies if the volume is read-only
        ReadOnly bool `yaml:"read_only" json:"read_only"`
}

// UnmarshalYAML customize ServiceVolume unmarshal
func (sv *ServiceVolume) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        var volume interface{}
        err := unmarshal(&amp;volume)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if volume == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">switch reflect.ValueOf(volume).Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                volumeStr := volume.(string)
                info := strings.Split(volumeStr, ":")
                length := len(info)
                if length &lt; 2 || length &gt; 3 </span><span class="cov0" title="0">{
                        return fmt.Errorf("servie volume format error")
                }</span>
                <span class="cov8" title="1">sv.Source = info[0]
                sv.Target = info[1]
                if length == 3 &amp;&amp; info[2] == "ro" </span><span class="cov0" title="0">{
                        sv.ReadOnly = true
                }</span>
        case reflect.Map:<span class="cov8" title="1">
                type VolumeInfo ServiceVolume
                var volumeInfo VolumeInfo
                err := unmarshal(&amp;volumeInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*sv = ServiceVolume(volumeInfo)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to parse service volume: unexpected type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Command command configuration of the service
type Command struct {
        Cmd []string `yaml:"cmd" json:"cmd" default:"[]"`
}

//UnmarshalYAML customize Command unmarshal
func (c *Command) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        if c.Cmd == nil </span><span class="cov8" title="1">{
                c.Cmd = make([]string, 0)
        }</span>
        <span class="cov8" title="1">var cmd interface{}
        err := unmarshal(&amp;cmd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch reflect.ValueOf(cmd).Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                c.Cmd = strings.Split(cmd.(string), " ")</span>
        case reflect.Slice:<span class="cov8" title="1">
                return unmarshal(&amp;c.Cmd)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// VolumeInfo storage volume configuration
type VolumeInfo struct {
        // specifies a unique name for the storage volume
        Name string `yaml:"name" json:"name" validate:"regexp=^[a-zA-Z0-9][a-zA-Z0-9_-]{0\\,63}$"`
        // specifies the directory where the storage volume is on the host
        Path string `yaml:"path" json:"path" validate:"nonzero"`
        // specifies the metadata of the storage volume
        Meta struct {
                URL     string `yaml:"url" json:"url"`
                MD5     string `yaml:"md5" json:"md5"`
                Version string `yaml:"version" json:"version"`
        } `yaml:"meta" json:"meta"`
}

// LoadComposeAppConfigCompatible load compose app config or old compatible config
func LoadComposeAppConfigCompatible(configFile string) (ComposeAppConfig, error) <span class="cov8" title="1">{
        var cfg ComposeAppConfig
        err := utils.LoadYAML(configFile, &amp;cfg)
        if err != nil </span><span class="cov8" title="1">{
                var c AppConfig
                err = utils.LoadYAML(configFile, &amp;c)
                if err != nil </span><span class="cov0" title="0">{
                        return cfg, err
                }</span>
                <span class="cov8" title="1">cfg = c.ToComposeAppConfig()</span>
        }
        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package baetyl

// deprecated

import (
        "path"

        "github.com/baetyl/baetyl/utils"
)

// AppConfig application configuration
type AppConfig struct {
        // specifies the version of the application configuration
        Version string `yaml:"version" json:"version"`
        // specifies the service information of the application
        Services []ServiceInfo `yaml:"services" json:"services" default:"[]"`
        // specifies the storage volume information of the application
        Volumes []VolumeInfo `yaml:"volumes" json:"volumes" default:"[]"`
        // specifies the network information of the application
        Networks map[string]ComposeNetwork `yaml:"networks" json:"networks" default:"{}"`
}

// ServiceInfo service configuration
type ServiceInfo struct {
        // specifies the unique name of the service
        Name string `yaml:"name" json:"name" validate:"regexp=^[a-zA-Z0-9][a-zA-Z0-9_-]{0\\,63}$"`
        // specifies the image of the service, usually using the Docker image name
        Image string `yaml:"image" json:"image" validate:"nonzero"`
        // specifies the number of instances started
        Replica int `yaml:"replica" json:"replica" validate:"min=0"`
        // specifies the storage volumes that the service needs, map the storage volume to the directory in the container
        Mounts []MountInfo `yaml:"mounts" json:"mounts" default:"[]"`
        // specifies the network that the service used
        Networks NetworksInfo `yaml:"networks" json:"networks"`
        // specifies the network mode of the service
        NetworkMode string `yaml:"network_mode" json:"network_mode" validate:"regexp=^(bridge|host|none)?$"`
        // specifies the port bindings which exposed by the service, only for Docker container mode
        Ports []string `yaml:"ports" json:"ports" default:"[]"`
        // specifies the device bindings which used by the service, only for Docker container mode
        Devices []string `yaml:"devices" json:"devices" default:"[]"`
        // specifies the startup arguments of the service program, but does not include `arg[0]`
        Args []string `yaml:"args" json:"args" default:"[]"`
        // specifies the environment variable of the service program
        Env map[string]string `yaml:"env" json:"env" default:"{}"`
        // specifies the restart policy of the instance of the service
        Restart RestartPolicyInfo `yaml:"restart" json:"restart"`
        // specifies resource limits for a single instance of the service,  only for Docker container mode
        Resources Resources `yaml:"resources" json:"resources"`
        // specifies runtime to use, only for Docker container mode
        Runtime string `yaml:"runtime" json:"runtime"`
}

// MountInfo storage volume mapping configuration
type MountInfo struct {
        // specifies the name of the mapped storage volume
        Name string `yaml:"name" json:"name" validate:"regexp=^[a-zA-Z0-9][a-zA-Z0-9_-]{0\\,63}$"`
        // specifies the directory where the storage volume is in the container
        Path string `yaml:"path" json:"path" validate:"nonzero"`
        // specifies the operation permission of the storage volume, read-only or writable
        ReadOnly bool `yaml:"readonly" json:"readonly"`
}

// ToComposeAppConfig transform AppConfig into ComposeAppConfig
func (cfg AppConfig) ToComposeAppConfig() ComposeAppConfig <span class="cov8" title="1">{
        composeCfg := ComposeAppConfig{
                Version:    "3",
                AppVersion: cfg.Version,
                Networks:   cfg.Networks,
        }
        composeCfg.Volumes = map[string]ComposeVolume{}
        utils.SetDefaults(&amp;composeCfg.Volumes)
        services := map[string]ComposeService{}
        utils.SetDefaults(&amp;services)
        var previous string
        first := true
        for _, service := range cfg.Services </span><span class="cov8" title="1">{
                info := ComposeService{
                        Image:       service.Image,
                        NetworkMode: service.NetworkMode,
                        Networks:    service.Networks,
                        Ports:       service.Ports,
                        Devices:     service.Devices,
                        Command: Command{
                                Cmd: service.Args,
                        },
                        Environment: Environment{
                                Envs: service.Env,
                        },
                        Replica:   service.Replica,
                        Restart:   service.Restart,
                        Resources: service.Resources,
                        Runtime:   service.Runtime,
                }
                if first </span><span class="cov8" title="1">{
                        first = false
                        info.DependsOn = []string{}
                }</span> else<span class="cov8" title="1"> {
                        info.DependsOn = []string{previous}
                }</span>
                <span class="cov8" title="1">previous = service.Name
                vs := make([]ServiceVolume, 0)
                for _, mount := range service.Mounts </span><span class="cov8" title="1">{
                        var p string
                        for _, v := range cfg.Volumes </span><span class="cov8" title="1">{
                                if v.Name == mount.Name </span><span class="cov8" title="1">{
                                        p = v.Path
                                }</span>
                        }
                        <span class="cov8" title="1">v := ServiceVolume{
                                Source:   p,
                                Target:   path.Join("/", mount.Path),
                                ReadOnly: mount.ReadOnly,
                        }
                        vs = append(vs, v)</span>
                }
                <span class="cov8" title="1">info.Volumes = vs
                services[service.Name] = info</span>
        }
        <span class="cov8" title="1">composeCfg.Services = services
        return composeCfg</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package baetyl

import (
        fmt "fmt"
        "os"
        "os/signal"
        "syscall"

        "github.com/baetyl/baetyl/logger"
        "github.com/baetyl/baetyl/protocol/mqtt"
        "github.com/baetyl/baetyl/utils"
)

// Mode keys
const (
        ModeNative = "native"
        ModeDocker = "docker"
)

// OTA types
const (
        OTAAPP = "APP"
        OTAMST = "MST"
)

// OTA steps
const (
        OTAKeyStep  = "step"
        OTAKeyType  = "type"
        OTAKeyTrace = "trace"

        OTAReceived    = "RECEIVED"    // [agent] ota event is received
        OTAUpdating    = "UPDATING"    // [master] to update app or master
        OTAUpdated     = "UPDATED"     // [master][finished] app or master is updated
        OTARestarting  = "RESTARTING"  // [master] to restart master
        OTARestarted   = "RESTARTED"   // [master] master is restarted
        OTARollingBack = "ROLLINGBACK" // [master] to roll back app or master
        OTARolledBack  = "ROLLEDBACK"  // [master][finished] app or master is rolled back
        OTAFailure     = "FAILURE"     // [master/agent][finished] failed to update app or master
        OTATimeout     = "TIMEOUT"     // [agent][finished] ota is timed out
)

// CheckOK print OK if binary is valid
const CheckOK = "OK!"

// Env keys
const (
        // deprecated
        EnvHostID                    = "OPENEDGE_HOST_ID"
        EnvHostOSKey                 = "OPENEDGE_HOST_OS"
        EnvMasterAPIKey              = "OPENEDGE_MASTER_API"
        EnvMasterAPIVersionKey       = "OPENEDGE_MASTER_API_VERSION"
        EnvRunningModeKey            = "OPENEDGE_RUNNING_MODE"
        EnvServiceNameKey            = "OPENEDGE_SERVICE_NAME"
        EnvServiceTokenKey           = "OPENEDGE_SERVICE_TOKEN"
        EnvServiceAddressKey         = "OPENEDGE_SERVICE_ADDRESS" // deprecated
        EnvServiceInstanceNameKey    = "OPENEDGE_SERVICE_INSTANCE_NAME"
        EnvServiceInstanceAddressKey = "OPENEDGE_SERVICE_INSTANCE_ADDRESS"

        // new envs
        EnvKeyHostID                 = "BAETYL_HOST_ID"
        EnvKeyHostOS                 = "BAETYL_HOST_OS"
        EnvKeyHostSN                 = "BAETYL_HOST_SN"
        EnvKeyMasterAPISocket        = "BAETYL_MASTER_API_SOCKET"
        EnvKeyMasterAPIAddress       = "BAETYL_MASTER_API_ADDRESS"
        EnvKeyMasterAPIVersion       = "BAETYL_MASTER_API_VERSION"
        EnvKeyServiceMode            = "BAETYL_SERVICE_MODE"
        EnvKeyServiceName            = "BAETYL_SERVICE_NAME"
        EnvKeyServiceToken           = "BAETYL_SERVICE_TOKEN"
        EnvKeyServiceInstanceName    = "BAETYL_SERVICE_INSTANCE_NAME"
        EnvKeyServiceInstanceAddress = "BAETYL_SERVICE_INSTANCE_ADDRESS"
)

// Path keys
const (
        // AppConfFileName application config file name
        AppConfFileName = "application.yml"
        // AppBackupFileName application backup configuration file
        AppBackupFileName = "application.yml.old"
        // AppStatsFileName application stats file name
        AppStatsFileName = "application.stats"
        // MetadataFileName application metadata file name
        MetadataFileName = "metadata.yml"

        // BinFile the file path of master binary
        DefaultBinFile = "bin/baetyl"
        // DefaultBinBackupFile the backup file path of master binary
        DefaultBinBackupFile = "bin/baetyl.old"
        // DefaultSockFile sock file of baetyl by default
        DefaultSockFile = "var/run/baetyl.sock"
        // DefaultConfFile config path of the service by default
        DefaultConfFile = "etc/baetyl/service.yml"
        // DefaultDBDir db dir of the service by default
        DefaultDBDir = "var/db/baetyl"
        // DefaultRunDir  run dir of the service by default
        DefaultRunDir = "var/run/baetyl"
        // DefaultLogDir  log dir of the service by default
        DefaultLogDir = "var/log/baetyl"
        // DefaultMasterConfDir master config dir by default
        DefaultMasterConfDir = "etc/baetyl"
        // DefaultMasterConfFile master config file by default
        DefaultMasterConfFile = "etc/baetyl/conf.yml"

        // backward compatibility
        // PreviousDBDir previous db dir of the service
        PreviousDBDir = "var/db/openedge"
        // PreviousMasterConfDir previous master config dir
        PreviousMasterConfDir = "etc/openedge"
        // PreviousMasterConfFile previous master config file
        PreviousMasterConfFile = "etc/openedge/openedge.yml"
        // PreviousBinBackupFile the backup file path of master binary
        PreviousBinBackupFile = "bin/openedge.old"
        // PreviousLogDir  log dir of the service by default
        PreviousLogDir = "var/log/openedge"
)

// Context of service
type Context interface {
        // returns the system configuration of the service, such as hub and logger
        Config() *ServiceConfig
        // loads the custom configuration of the service
        LoadConfig(interface{}) error
        // creates a Client that connects to the Hub through system configuration,
        // you can specify the Client ID and the topic information of the subscription.
        NewHubClient(string, []mqtt.TopicInfo) (*mqtt.Dispatcher, error)
        // returns logger interface
        Log() logger.Logger
        // check running mode
        IsNative() bool
        // waiting to exit, receiving SIGTERM and SIGINT signals
        Wait()
        // returns wait channel
        WaitChan() &lt;-chan os.Signal

        // Master RESTful API

        // updates application or master
        UpdateSystem(trace, tp, path string) error
        // inspects system stats
        InspectSystem() (*Inspect, error)
        // gets an available port of the host
        GetAvailablePort() (string, error)
        // reports the stats of the instance of the service
        ReportInstance(stats map[string]interface{}) error
        // starts an instance of the service
        StartInstance(serviceName, instanceName string, dynamicConfig map[string]string) error
        // stop the instance of the service
        StopInstance(serviceName, instanceName string) error
}

type ctx struct {
        sn  string // service name
        in  string // instance name
        md  string // running mode
        cli *Client
        cfg ServiceConfig
        log logger.Logger
}

func newContext() (*ctx, error) <span class="cov0" title="0">{
        var cfg ServiceConfig
        md := os.Getenv(EnvKeyServiceMode)
        sn := os.Getenv(EnvKeyServiceName)
        in := os.Getenv(EnvKeyServiceInstanceName)
        if md == "" </span><span class="cov0" title="0">{
                md = os.Getenv(EnvRunningModeKey)
                sn = os.Getenv(EnvServiceNameKey)
                in = os.Getenv(EnvServiceInstanceNameKey)
        }</span>

        <span class="cov0" title="0">err := utils.LoadYAML(DefaultConfFile, &amp;cfg)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[%s][%s] failed to load config: %s\n", sn, in, err.Error())
        }</span>
        <span class="cov0" title="0">log := logger.InitLogger(cfg.Logger, "service", sn, "instance", in)
        cli, err := NewEnvClient()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[%s][%s] failed to create master client: %s\n", sn, in, err.Error())
                log.WithError(err).Errorf("failed to create master client")
        }</span>
        <span class="cov0" title="0">return &amp;ctx{
                sn:  sn,
                in:  in,
                md:  md,
                cfg: cfg,
                cli: cli,
                log: log,
        }, nil</span>
}

func (c *ctx) NewHubClient(cid string, subs []mqtt.TopicInfo) (*mqtt.Dispatcher, error) <span class="cov0" title="0">{
        if c.cfg.Hub.Address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hub not configured")
        }</span>
        <span class="cov0" title="0">cc := c.cfg.Hub
        if cid != "" </span><span class="cov0" title="0">{
                cc.ClientID = cid
        }</span>
        <span class="cov0" title="0">if subs != nil </span><span class="cov0" title="0">{
                cc.Subscriptions = subs
        }</span>
        <span class="cov0" title="0">return mqtt.NewDispatcher(cc, c.log.WithField("cid", cid)), nil</span>
}

func (c *ctx) LoadConfig(cfg interface{}) error <span class="cov0" title="0">{
        return utils.LoadYAML(DefaultConfFile, cfg)
}</span>

func (c *ctx) Config() *ServiceConfig <span class="cov0" title="0">{
        return &amp;c.cfg
}</span>

func (c *ctx) Log() logger.Logger <span class="cov0" title="0">{
        return c.log
}</span>

func (c *ctx) Wait() <span class="cov0" title="0">{
        &lt;-c.WaitChan()
}</span>

func (c *ctx) IsNative() bool <span class="cov0" title="0">{
        return c.md == ModeNative
}</span>

func (c *ctx) WaitChan() &lt;-chan os.Signal <span class="cov0" title="0">{
        sig := make(chan os.Signal, 1)
        signal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)
        signal.Ignore(syscall.SIGPIPE)
        return sig
}</span>

// InspectSystem inspect all stats
func (c *ctx) InspectSystem() (*Inspect, error) <span class="cov0" title="0">{
        return c.cli.InspectSystem()
}</span>

// UpdateSystem updates and reloads config
func (c *ctx) UpdateSystem(trace, tp, path string) error <span class="cov0" title="0">{
        return c.cli.UpdateSystem(trace, tp, path)
}</span>

// GetAvailablePort gets available port
func (c *ctx) GetAvailablePort() (string, error) <span class="cov0" title="0">{
        return c.cli.GetAvailablePort()
}</span>

// ReportInstance reports the stats of the instance of the service
func (c *ctx) ReportInstance(stats map[string]interface{}) error <span class="cov0" title="0">{
        return c.cli.ReportInstance(c.sn, c.in, stats)
}</span>

// StartInstance starts a new service instance with dynamic config
func (c *ctx) StartInstance(serviceName, instanceName string, dynamicConfig map[string]string) error <span class="cov0" title="0">{
        return c.cli.StartInstance(serviceName, instanceName, dynamicConfig)
}</span>

// StopInstance stops a service instance
func (c *ctx) StopInstance(serviceName, instanceName string) error <span class="cov0" title="0">{
        return c.cli.StopInstance(serviceName, instanceName)
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: function.proto

package baetyl

import (
        context "context"
        fmt "fmt"
        proto "github.com/golang/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// FunctionMessage function message
type FunctionMessage struct {
        ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        QOS                  uint32   `protobuf:"varint,2,opt,name=QOS,proto3" json:"QOS,omitempty"`
        Topic                string   `protobuf:"bytes,3,opt,name=Topic,proto3" json:"Topic,omitempty"`
        Payload              []byte   `protobuf:"bytes,4,opt,name=Payload,proto3" json:"Payload,omitempty"`
        Timestamp            int64    `protobuf:"zigzag64,10,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
        FunctionName         string   `protobuf:"bytes,11,opt,name=FunctionName,proto3" json:"FunctionName,omitempty"`
        FunctionInvokeID     string   `protobuf:"bytes,12,opt,name=FunctionInvokeID,proto3" json:"FunctionInvokeID,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *FunctionMessage) Reset()         <span class="cov8" title="1">{ *m = FunctionMessage{} }</span>
func (m *FunctionMessage) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*FunctionMessage) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*FunctionMessage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_8ac74addf543d91a, []int{0}
}</span>

func (m *FunctionMessage) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_FunctionMessage.Unmarshal(m, b)
}</span>
func (m *FunctionMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_FunctionMessage.Marshal(b, m, deterministic)
}</span>
func (m *FunctionMessage) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_FunctionMessage.Merge(m, src)
}</span>
func (m *FunctionMessage) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_FunctionMessage.Size(m)
}</span>
func (m *FunctionMessage) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_FunctionMessage.DiscardUnknown(m)
}</span>

var xxx_messageInfo_FunctionMessage proto.InternalMessageInfo

func (m *FunctionMessage) GetID() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *FunctionMessage) GetQOS() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.QOS
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *FunctionMessage) GetTopic() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Topic
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *FunctionMessage) GetPayload() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Payload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *FunctionMessage) GetTimestamp() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *FunctionMessage) GetFunctionName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FunctionName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *FunctionMessage) GetFunctionInvokeID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FunctionInvokeID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*FunctionMessage)(nil), "baetyl.FunctionMessage")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("function.proto", fileDescriptor_8ac74addf543d91a) }</span>

var fileDescriptor_8ac74addf543d91a = []byte{
        // 223 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4b, 0x2b, 0xcd, 0x4b,
        0x2e, 0xc9, 0xcc, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x4b, 0x4a, 0x4c, 0x2d,
        0xa9, 0xcc, 0x51, 0xba, 0xc8, 0xc8, 0xc5, 0xef, 0x06, 0x95, 0xf2, 0x4d, 0x2d, 0x2e, 0x4e, 0x4c,
        0x4f, 0x15, 0xe2, 0xe3, 0x62, 0xf2, 0x74, 0x91, 0x60, 0x54, 0x60, 0xd4, 0x60, 0x09, 0x62, 0xf2,
        0x74, 0x11, 0x12, 0xe0, 0x62, 0x0e, 0xf4, 0x0f, 0x96, 0x60, 0x52, 0x60, 0xd4, 0xe0, 0x0d, 0x02,
        0x31, 0x85, 0x44, 0xb8, 0x58, 0x43, 0xf2, 0x0b, 0x32, 0x93, 0x25, 0x98, 0x15, 0x18, 0x35, 0x38,
        0x83, 0x20, 0x1c, 0x21, 0x09, 0x2e, 0xf6, 0x80, 0xc4, 0xca, 0x9c, 0xfc, 0xc4, 0x14, 0x09, 0x16,
        0x05, 0x46, 0x0d, 0x9e, 0x20, 0x18, 0x57, 0x48, 0x86, 0x8b, 0x33, 0x24, 0x33, 0x37, 0xb5, 0xb8,
        0x24, 0x31, 0xb7, 0x40, 0x82, 0x4b, 0x81, 0x51, 0x43, 0x28, 0x08, 0x21, 0x20, 0xa4, 0xc4, 0xc5,
        0x03, 0x73, 0x82, 0x5f, 0x62, 0x6e, 0xaa, 0x04, 0x37, 0xd8, 0x50, 0x14, 0x31, 0x21, 0x2d, 0x2e,
        0x01, 0x18, 0xdf, 0x33, 0xaf, 0x2c, 0x3f, 0x3b, 0xd5, 0xd3, 0x45, 0x82, 0x07, 0xac, 0x0e, 0x43,
        0xdc, 0xc8, 0x8d, 0x8b, 0x03, 0x26, 0x26, 0x64, 0xc5, 0xc5, 0xe2, 0x9c, 0x98, 0x93, 0x23, 0x24,
        0xae, 0x07, 0xf1, 0xb0, 0x1e, 0x9a, 0x67, 0xa5, 0x70, 0x49, 0x28, 0x31, 0x24, 0xb1, 0x81, 0x83,
        0xca, 0x18, 0x10, 0x00, 0x00, 0xff, 0xff, 0xe1, 0x5d, 0x88, 0x32, 0x3c, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FunctionClient is the client API for Function service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FunctionClient interface {
        Call(ctx context.Context, in *FunctionMessage, opts ...grpc.CallOption) (*FunctionMessage, error)
}

type functionClient struct {
        cc *grpc.ClientConn
}

func NewFunctionClient(cc *grpc.ClientConn) FunctionClient <span class="cov8" title="1">{
        return &amp;functionClient{cc}
}</span>

func (c *functionClient) Call(ctx context.Context, in *FunctionMessage, opts ...grpc.CallOption) (*FunctionMessage, error) <span class="cov8" title="1">{
        out := new(FunctionMessage)
        err := c.cc.Invoke(ctx, "/baetyl.Function/Call", in, out, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// FunctionServer is the server API for Function service.
type FunctionServer interface {
        Call(context.Context, *FunctionMessage) (*FunctionMessage, error)
}

// UnimplementedFunctionServer can be embedded to have forward compatible implementations.
type UnimplementedFunctionServer struct {
}

func (*UnimplementedFunctionServer) Call(ctx context.Context, req *FunctionMessage) (*FunctionMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Call not implemented")
}</span>

func RegisterFunctionServer(s *grpc.Server, srv FunctionServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_Function_serviceDesc, srv)
}</span>

func _Function_Call_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(FunctionMessage)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov8" title="1">{
                return srv.(FunctionServer).Call(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/baetyl.Function/Call",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FunctionServer).Call(ctx, req.(*FunctionMessage))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Function_serviceDesc = grpc.ServiceDesc{
        ServiceName: "baetyl.Function",
        HandlerType: (*FunctionServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Call",
                        Handler:    _Function_Call_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "function.proto",
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package baetyl

import (
        context "golang.org/x/net/context"
        "google.golang.org/grpc"
)

var callopt = grpc.FailFast(false)

// FClient client of functions server
type FClient struct {
        cli  FunctionClient
        cfg  FunctionClientConfig
        conn *grpc.ClientConn
}

// NewFClient creates a new client of functions server
func NewFClient(cc FunctionClientConfig) (*FClient, error) <span class="cov8" title="1">{
        ctx, cel := context.WithTimeout(context.Background(), cc.Timeout)
        defer cel()
        conn, err := grpc.DialContext(
                ctx,
                cc.Address,
                grpc.WithBlock(),
                grpc.WithInsecure(),
                grpc.WithTimeout(cc.Timeout),
                grpc.WithBackoffMaxDelay(cc.Backoff.Max),
                grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(int(cc.Message.Length.Max))),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;FClient{
                cfg:  cc,
                conn: conn,
                cli:  NewFunctionClient(conn),
        }, nil</span>
}

// Call sends request to functions server
func (c *FClient) Call(msg *FunctionMessage) (*FunctionMessage, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.TODO(), c.cfg.Timeout)
        defer cancel()
        return c.cli.Call(ctx, msg, callopt)
}</span>

// Close closes the client
func (c *FClient) Close() error <span class="cov8" title="1">{
        return c.conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package baetyl

import (
        fmt "fmt"
        "net"

        "github.com/baetyl/baetyl/utils"
        context "golang.org/x/net/context"
        grpc "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/reflection"
)

// Call message handler
type Call func(context.Context, *FunctionMessage) (*FunctionMessage, error)

// FServer functions server to handle message
type FServer struct {
        addr string
        cfg  FunctionServerConfig
        svr  *grpc.Server
        call Call
}

// NewFServer creates a new functions server
func NewFServer(c FunctionServerConfig, call Call) (*FServer, error) <span class="cov8" title="1">{
        lis, err := net.Listen("tcp", c.Address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // TODO: to test
        <span class="cov8" title="1">tls, err := utils.NewTLSServerConfig(c.Certificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">opts := []grpc.ServerOption{
                grpc.MaxConcurrentStreams(c.Concurrent.Max),
                grpc.MaxRecvMsgSize(int(c.Message.Length.Max)),
                grpc.MaxSendMsgSize(int(c.Message.Length.Max)),
        }
        if tls != nil </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Creds(credentials.NewTLS(tls)))
        }</span>
        <span class="cov8" title="1">svr := grpc.NewServer(opts...)
        s := &amp;FServer{cfg: c, call: call, svr: svr, addr: lis.Addr().String()}
        RegisterFunctionServer(svr, s)
        reflection.Register(svr)
        go s.svr.Serve(lis)
        return s, nil</span>
}

// Call handles message
func (s *FServer) Call(c context.Context, m *FunctionMessage) (*FunctionMessage, error) <span class="cov8" title="1">{
        if s.call == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("handle not implemented")
        }</span>
        <span class="cov8" title="1">return s.call(c, m)</span>
}

// Close closes server
func (s *FServer) Close() <span class="cov8" title="1">{
        if s.svr != nil </span><span class="cov8" title="1">{
                s.svr.GracefulStop()
        }</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package baetyl

import (
        "time"

        "github.com/baetyl/baetyl/utils"
)

// Inspect all baetyl information and status inspected
type Inspect struct {
        // exception information
        Error string `json:"error,omitempty"`
        // inspect time
        Time time.Time `json:"time,omitempty"`
        // software information
        Software Software `json:"software,omitempty"`
        // hardware information
        Hardware Hardware `json:"hardware,omitempty"`
        // service information, including service name, instance running status, etc.
        Services Services `json:"services,omitempty"`
        // storage volume information, including name and version
        Volumes Volumes `json:"volumes,omitempty"`
}

// Software software information
type Software struct {
        // operating system information of host
        OS string `json:"os,omitempty"`
        // CPU information of host
        Arch string `json:"arch,omitempty"`
        // Baetyl process work directory
        PWD string `json:"pwd,omitempty"`
        // Baetyl running mode of application services
        Mode string `json:"mode,omitempty"`
        // Baetyl compiled Golang version
        GoVersion string `json:"go_version,omitempty"`
        // Baetyl release version
        BinVersion string `json:"bin_version,omitempty"`
        // Baetyl git revision
        GitRevision string `json:"git_revision,omitempty"`
        // Baetyl loaded application configuration version
        ConfVersion string `json:"conf_version,omitempty"`
}

// Hardware hardware information
type Hardware struct {
        // host information
        HostInfo *utils.HostInfo `json:"host_stats,omitempty"`
        // net information of host
        NetInfo *utils.NetInfo `json:"net_stats,omitempty"`
        // memory usage information of host
        MemInfo *utils.MemInfo `json:"mem_stats,omitempty"`
        // CPU usage information of host
        CPUInfo *utils.CPUInfo `json:"cpu_stats,omitempty"`
        // disk usage information of host
        DiskInfo *utils.DiskInfo `json:"disk_stats,omitempty"`
        // CPU usage information of host
        GPUInfo *utils.GPUInfo `json:"gpu_stats,omitempty"`
}

// Services all services' information
type Services []ServiceStatus

// ServiceStatus service status
type ServiceStatus struct {
        Name      string           `json:"name,omitempty"`
        Instances []InstanceStatus `json:"instances,omitempty"`
}

// InstanceStatus service instance status
type InstanceStatus map[string]interface{}

// NewInspect create a new information inspected
func NewInspect() *Inspect <span class="cov0" title="0">{
        return &amp;Inspect{
                Services: Services{},
        }
}</span>

// NewServiceStatus create a new service status
func NewServiceStatus(name string) ServiceStatus <span class="cov0" title="0">{
        return ServiceStatus{
                Name:      name,
                Instances: []InstanceStatus{},
        }
}</span>

// Volumes all volumes' information
type Volumes []VolumeStatus

// VolumeStatus volume status
type VolumeStatus struct {
        Name    string `json:"name,omitempty"`
        Version string `json:"version,omitempty"`
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kv.proto

package baetyl

import (
        context "context"
        fmt "fmt"
        proto "github.com/golang/protobuf/proto"
        empty "github.com/golang/protobuf/ptypes/empty"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// KV kv message
type KV struct {
        // key is the key, in bytes, to put into the key-value store.
        Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        // value is the value, in bytes, to associate with the key in the key-value store.
        Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KV) Reset()         <span class="cov0" title="0">{ *m = KV{} }</span>
func (m *KV) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KV) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KV) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2216fe83c9c12408, []int{0}
}</span>

func (m *KV) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_KV.Unmarshal(m, b)
}</span>
func (m *KV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_KV.Marshal(b, m, deterministic)
}</span>
func (m *KV) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KV.Merge(m, src)
}</span>
func (m *KV) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_KV.Size(m)
}</span>
func (m *KV) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KV.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KV proto.InternalMessageInfo

func (m *KV) GetKey() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *KV) GetValue() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// KVs kvs message
type KVs struct {
        Kvs                  []*KV    `protobuf:"bytes,1,rep,name=kvs,proto3" json:"kvs,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KVs) Reset()         <span class="cov0" title="0">{ *m = KVs{} }</span>
func (m *KVs) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KVs) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KVs) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2216fe83c9c12408, []int{1}
}</span>

func (m *KVs) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_KVs.Unmarshal(m, b)
}</span>
func (m *KVs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_KVs.Marshal(b, m, deterministic)
}</span>
func (m *KVs) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KVs.Merge(m, src)
}</span>
func (m *KVs) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_KVs.Size(m)
}</span>
func (m *KVs) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KVs.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KVs proto.InternalMessageInfo

func (m *KVs) GetKvs() []*KV <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Kvs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*KV)(nil), "baetyl.KV")
        proto.RegisterType((*KVs)(nil), "baetyl.KVs")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("kv.proto", fileDescriptor_2216fe83c9c12408) }</span>

var fileDescriptor_2216fe83c9c12408 = []byte{
        // 208 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xc8, 0x2e, 0xd3, 0x2b,
        0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x4b, 0x4a, 0x4c, 0x2d, 0xa9, 0xcc, 0x91, 0x92, 0x4e, 0xcf,
        0xcf, 0x4f, 0xcf, 0x49, 0xd5, 0x07, 0x8b, 0x26, 0x95, 0xa6, 0xe9, 0xa7, 0xe6, 0x16, 0x94, 0x54,
        0x42, 0x14, 0x29, 0xe9, 0x70, 0x31, 0x79, 0x87, 0x09, 0x09, 0x70, 0x31, 0x67, 0xa7, 0x56, 0x4a,
        0x30, 0x2a, 0x30, 0x6a, 0xf0, 0x04, 0x81, 0x98, 0x42, 0x22, 0x5c, 0xac, 0x65, 0x89, 0x39, 0xa5,
        0xa9, 0x12, 0x4c, 0x60, 0x31, 0x08, 0x47, 0x49, 0x99, 0x8b, 0xd9, 0x3b, 0xac, 0x58, 0x48, 0x86,
        0x8b, 0x39, 0xbb, 0xac, 0x58, 0x82, 0x51, 0x81, 0x59, 0x83, 0xdb, 0x88, 0x4b, 0x0f, 0x62, 0x8f,
        0x9e, 0x77, 0x58, 0x10, 0x48, 0xd8, 0x68, 0x25, 0x23, 0x17, 0xa7, 0x77, 0x58, 0x70, 0x6a, 0x51,
        0x59, 0x66, 0x72, 0xaa, 0x90, 0x36, 0x17, 0x73, 0x70, 0x6a, 0x89, 0x10, 0x92, 0x2a, 0x29, 0x31,
        0x3d, 0x88, 0x8b, 0xf4, 0x60, 0x2e, 0xd2, 0x73, 0x05, 0xb9, 0x48, 0x89, 0x41, 0x48, 0x9e, 0x8b,
        0xd9, 0x1d, 0x4d, 0x31, 0x12, 0x5b, 0x89, 0x01, 0x64, 0x9a, 0x4b, 0x6a, 0x0e, 0x91, 0xa6, 0x29,
        0x72, 0xb1, 0xf8, 0x64, 0x16, 0xa3, 0x1a, 0xc7, 0x8d, 0x60, 0x17, 0x2b, 0x31, 0x24, 0xb1, 0x81,
        0x35, 0x19, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x88, 0xb3, 0x78, 0xc9, 0x36, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KVServiceClient is the client API for KVService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KVServiceClient interface {
        Set(ctx context.Context, in *KV, opts ...grpc.CallOption) (*empty.Empty, error)
        Get(ctx context.Context, in *KV, opts ...grpc.CallOption) (*KV, error)
        Del(ctx context.Context, in *KV, opts ...grpc.CallOption) (*empty.Empty, error)
        List(ctx context.Context, in *KV, opts ...grpc.CallOption) (*KVs, error)
}

type kVServiceClient struct {
        cc *grpc.ClientConn
}

func NewKVServiceClient(cc *grpc.ClientConn) KVServiceClient <span class="cov0" title="0">{
        return &amp;kVServiceClient{cc}
}</span>

func (c *kVServiceClient) Set(ctx context.Context, in *KV, opts ...grpc.CallOption) (*empty.Empty, error) <span class="cov0" title="0">{
        out := new(empty.Empty)
        err := c.cc.Invoke(ctx, "/baetyl.KVService/Set", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVServiceClient) Get(ctx context.Context, in *KV, opts ...grpc.CallOption) (*KV, error) <span class="cov0" title="0">{
        out := new(KV)
        err := c.cc.Invoke(ctx, "/baetyl.KVService/Get", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVServiceClient) Del(ctx context.Context, in *KV, opts ...grpc.CallOption) (*empty.Empty, error) <span class="cov0" title="0">{
        out := new(empty.Empty)
        err := c.cc.Invoke(ctx, "/baetyl.KVService/Del", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *kVServiceClient) List(ctx context.Context, in *KV, opts ...grpc.CallOption) (*KVs, error) <span class="cov0" title="0">{
        out := new(KVs)
        err := c.cc.Invoke(ctx, "/baetyl.KVService/List", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// KVServiceServer is the server API for KVService service.
type KVServiceServer interface {
        Set(context.Context, *KV) (*empty.Empty, error)
        Get(context.Context, *KV) (*KV, error)
        Del(context.Context, *KV) (*empty.Empty, error)
        List(context.Context, *KV) (*KVs, error)
}

// UnimplementedKVServiceServer can be embedded to have forward compatible implementations.
type UnimplementedKVServiceServer struct {
}

func (*UnimplementedKVServiceServer) Set(ctx context.Context, req *KV) (*empty.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}</span>
func (*UnimplementedKVServiceServer) Get(ctx context.Context, req *KV) (*KV, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}</span>
func (*UnimplementedKVServiceServer) Del(ctx context.Context, req *KV) (*empty.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Del not implemented")
}</span>
func (*UnimplementedKVServiceServer) List(ctx context.Context, req *KV) (*KVs, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}</span>

func RegisterKVServiceServer(s *grpc.Server, srv KVServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_KVService_serviceDesc, srv)
}</span>

func _KVService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(KV)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).Set(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/baetyl.KVService/Set",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).Set(ctx, req.(*KV))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(KV)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).Get(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/baetyl.KVService/Get",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).Get(ctx, req.(*KV))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVService_Del_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(KV)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).Del(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/baetyl.KVService/Del",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).Del(ctx, req.(*KV))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _KVService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(KV)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).List(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/baetyl.KVService/List",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(KVServiceServer).List(ctx, req.(*KV))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _KVService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "baetyl.KVService",
        HandlerType: (*KVServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Set",
                        Handler:    _KVService_Set_Handler,
                },
                {
                        MethodName: "Get",
                        Handler:    _KVService_Get_Handler,
                },
                {
                        MethodName: "Del",
                        Handler:    _KVService_Del_Handler,
                },
                {
                        MethodName: "List",
                        Handler:    _KVService_List_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "kv.proto",
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package baetyl

import (
        "fmt"
        "os"
        "runtime/debug"

        "github.com/baetyl/baetyl/logger"
)

// Run service
func Run(handle func(Context) error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "service is stopped with panic: %s\n%s", r, string(debug.Stack()))
                }</span>
        }()
        <span class="cov0" title="0">c, err := newContext()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[%s][%s] failed to create context: %s\n", c.sn, c.in, err.Error())
                logger.WithError(err).Errorln("failed to create context")
                return
        }</span>
        <span class="cov0" title="0">logger.Infoln("service starting: ", os.Args)
        err = handle(c)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[%s][%s] service is stopped with error: %s\n", c.sn, c.in, err.Error())
                logger.WithError(err).Errorln("service is stopped with error")
        }</span> else<span class="cov0" title="0"> {
                logger.Infoln("service stopped")
        }</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package utils

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "math/rand"
)

// AES aes
const (
        AesIvLen      = 16
        AesKeyLen     = 32
        AesKeyCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
)

// AesEncrypt encrypts data using the specified key
func AesEncrypt(plaintext, key []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">plaintext = paddingPKCS7(plaintext, block.BlockSize())
        ciphertext := make([]byte, len(plaintext))
        iv := make([]byte, AesIvLen)

        blockModel := cipher.NewCBCEncrypter(block, iv)
        blockModel.CryptBlocks(ciphertext, plaintext)
        return ciphertext, nil</span>
}

// AesDecrypt decrypts data using the specified key
func AesDecrypt(ciphertext, key []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">iv := make([]byte, AesIvLen)
        plaintext := make([]byte, len(ciphertext))

        blockModel := cipher.NewCBCDecrypter(block, iv)
        blockModel.CryptBlocks(plaintext, ciphertext)
        plaintext = unpaddingPKCS7(plaintext, block.BlockSize())
        return plaintext, nil</span>
}

// NewAesKey news AES key
func NewAesKey() []byte <span class="cov0" title="0">{
        key := make([]byte, AesKeyLen)
        for i := range key </span><span class="cov0" title="0">{
                key[i] = AesKeyCharSet[rand.Intn(len(AesKeyCharSet))]
        }</span>
        <span class="cov0" title="0">return key</span>
}

func paddingPKCS7(ciphertext []byte, blockSize int) []byte <span class="cov8" title="1">{
        padding := blockSize - len(ciphertext)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(ciphertext, padtext...)
}</span>

func unpaddingPKCS7(plaintext []byte, blockSize int) []byte <span class="cov8" title="1">{
        length := len(plaintext)
        unpadding := int(plaintext[length-1])
        return plaintext[:(length - unpadding)]
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package utils

import (
        "crypto/x509"
        "encoding/pem"
        "io/ioutil"
)

// GetSerialNumber gets serial number from pem
func GetSerialNumber(file string) (string, error) <span class="cov8" title="1">{
        raw, err := ioutil.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">block, _ := pem.Decode(raw)
        x509Cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return x509Cert.SerialNumber.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package utils

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "strings"
        "text/template"

        "github.com/docker/go-units"
        "gopkg.in/validator.v2"
        "gopkg.in/yaml.v2"
)

// LoadYAML config into out interface, with defaults and validates
func LoadYAML(path string, out interface{}) error <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">res, err := ParseEnv(data)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "config parse error: %s", err.Error())
                res = data
        }</span>
        <span class="cov8" title="1">return UnmarshalYAML(res, out)</span>
}

// ParseEnv pasre env
func ParseEnv(data []byte) ([]byte, error) <span class="cov8" title="1">{
        text := string(data)
        envs := os.Environ()
        envMap := make(map[string]string)
        for _, s := range envs </span><span class="cov8" title="1">{
                t := strings.Split(s, "=")
                envMap[t[0]] = t[1]
        }</span>
        <span class="cov8" title="1">tmpl, err := template.New("template").Option("missingkey=error").Parse(text)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">buffer := bytes.NewBuffer(nil)
        err = tmpl.Execute(buffer, envMap)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}

// UnmarshalYAML unmarshals, defaults and validates
func UnmarshalYAML(in []byte, out interface{}) error <span class="cov8" title="1">{
        err := yaml.Unmarshal(in, out)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = SetDefaults(out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = validator.Validate(out)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UnmarshalJSON unmarshals, defaults and validates
func UnmarshalJSON(in []byte, out interface{}) error <span class="cov8" title="1">{
        err := json.Unmarshal(in, out)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = SetDefaults(out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = validator.Validate(out)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Length length
type Length struct {
        Max int64 `yaml:"max" json:"max"`
}

// UnmarshalYAML customizes unmarshal
func (l *Length) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        var ls length
        err := unmarshal(&amp;ls)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if ls.Max != "" </span><span class="cov8" title="1">{
                l.Max, err = units.RAMInBytes(ls.Max)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type length struct {
        Max string `yaml:"max" json:"max"`
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package utils

import (
        "fmt"
        "reflect"

        "github.com/creasty/defaults"
)

// SetDefaults set default values
func SetDefaults(ptr interface{}) error <span class="cov8" title="1">{
        err := defaults.Set(ptr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%v: %s", ptr, err.Error())
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(ptr).Elem()
        t := v.Type()

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                tf := t.Field(i)
                vf := v.Field(i)
                if tf.Type.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        for j := 0; j &lt; vf.Len(); j++ </span><span class="cov8" title="1">{
                                item := vf.Index(j)
                                if item.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">err := setDefaults(item)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">if tf.Type.Kind() == reflect.Map </span><span class="cov8" title="1">{
                        for _, k := range vf.MapKeys() </span><span class="cov8" title="1">{
                                item := vf.MapIndex(k)
                                if item.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">tmp := reflect.New(item.Type())
                                tmp.Elem().Set(item)
                                err := setDefaults(tmp.Elem())
                                vf.SetMapIndex(k, tmp.Elem())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func setDefaults(v reflect.Value) error <span class="cov8" title="1">{
        tmp := reflect.New(v.Type())
        tmp.Elem().Set(v)
        err := SetDefaults(tmp.Interface())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">v.Set(tmp.Elem())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package utils

import (
        "fmt"
        "os"
        "sync"
)

// TODO: to improve or remove
type s struct {
        kvs map[string]string
        sync.RWMutex
}

var env = s{kvs: map[string]string{}}

// SetEnv sets env
func SetEnv(key, value string) <span class="cov0" title="0">{
        env.Lock()
        defer env.Unlock()
        env.kvs[key] = value
}</span>

// GetEnv gets env
func GetEnv(key string) string <span class="cov0" title="0">{
        env.RLock()
        defer env.RUnlock()
        return env.kvs[key]
}</span>

// AppendEnv appends envs
func AppendEnv(paramEnv map[string]string, includeHostEnv bool) []string <span class="cov0" title="0">{
        out := []string{}
        if includeHostEnv </span><span class="cov0" title="0">{
                out = os.Environ()
        }</span>
        <span class="cov0" title="0">for k, v := range paramEnv </span><span class="cov0" title="0">{
                out = append(out, fmt.Sprintf("%s=%s", k, v))
        }</span>
        <span class="cov0" title="0">env.RLock()
        defer env.RUnlock()
        for k, v := range env.kvs </span><span class="cov0" title="0">{
                out = append(out, fmt.Sprintf("%s=%s", k, v))
        }</span>
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package utils

import (
        "reflect"
)

// Equal compares two struct data
func Equal(a, b interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(a, b)
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package utils

import (
        "crypto/md5"
        "encoding/base64"
        "fmt"
        "io"
        "os"
)

// PathExists checks path exists
func PathExists(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsExist(err) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

// DirExists checks dir exists
func DirExists(path string) bool <span class="cov8" title="1">{
        fi, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return os.IsExist(err)
        }</span>
        <span class="cov8" title="1">return fi.IsDir()</span>
}

// FileExists checks file exists
func FileExists(path string) bool <span class="cov8" title="1">{
        fi, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return os.IsExist(err)
        }</span>
        <span class="cov8" title="1">return !fi.IsDir()</span>
}

// WriteFile writes data into file in chunk mode
func WriteFile(fn string, r io.Reader) error <span class="cov0" title="0">{
        f, err := os.Create(fn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        _, err = io.Copy(f, r)
        return err</span>
}

// CopyFile copy data from one file to another
func CopyFile(s, t string) error <span class="cov0" title="0">{
        sf, err := os.Open(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sf.Close()

        return WriteFile(t, sf)</span>
}

// CalculateFileMD5 calculates file MD5
func CalculateFileMD5(fn string) (string, error) <span class="cov0" title="0">{
        f, err := os.Open(fn)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        hasher := md5.New()
        _, err = io.Copy(hasher, f)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(hasher.Sum(nil)), nil</span>
}

// CreateSymlink create symlink of target
func CreateSymlink(target, symlink string) error <span class="cov8" title="1">{
        if PathExists(symlink) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := os.Symlink(target, symlink)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make symlink %s of %s: %s", target, symlink, err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package utils

import "net"

// GetAvailablePort finds an available port
func GetAvailablePort(host string) (int, error) <span class="cov8" title="1">{
        address, err := net.ResolveTCPAddr("tcp", host+":0")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">listener, err := net.ListenTCP("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer listener.Close()
        return listener.Addr().(*net.TCPAddr).Port, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package utils

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "math/big"
)

// copy from crypt/rsa/pkcs1v5.go
var hashPrefixes = map[crypto.Hash][]byte{
        crypto.MD5:       {0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},
        crypto.SHA1:      {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},
        crypto.SHA224:    {0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c},
        crypto.SHA256:    {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},
        crypto.SHA384:    {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},
        crypto.SHA512:    {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},
        crypto.MD5SHA1:   {}, // A special TLS case which doesn't use an ASN1 prefix.
        crypto.RIPEMD160: {0x30, 0x20, 0x30, 0x08, 0x06, 0x06, 0x28, 0xcf, 0x06, 0x03, 0x00, 0x31, 0x04, 0x14},
}

// RsaPublicEncrypt encrypts data using public key
func RsaPublicEncrypt(data, publicKey []byte) ([]byte, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(publicKey)
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public key error")
        }</span>
        <span class="cov8" title="1">pub, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p, ok := pub.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public key error")
        }</span>
        <span class="cov8" title="1">return rsa.EncryptPKCS1v15(rand.Reader, p, data)</span>
}

// RsaPrivateDecrypt decrypts data using private key
func RsaPrivateDecrypt(data, privateKey []byte) ([]byte, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(privateKey)
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key error")
        }</span>
        <span class="cov8" title="1">pri, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rsa.DecryptPKCS1v15(rand.Reader, pri, data)</span>
}

// RsaPrivateEncrypt encrypts data using private key
func RsaPrivateEncrypt(data, privateKey []byte) ([]byte, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(privateKey)
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key error")
        }</span>
        <span class="cov8" title="1">pri, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rsa.SignPKCS1v15(nil, pri, crypto.Hash(0), data)</span>
}

// RsaPublicDecrypt decrypts data using public key
func RsaPublicDecrypt(data, publicKey []byte) ([]byte, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(publicKey)
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public key error")
        }</span>
        <span class="cov8" title="1">pub, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p, ok := pub.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public key error")
        }</span>
        <span class="cov8" title="1">return publicDecrypt(p, crypto.Hash(0), nil, data)</span>
}

// copy&amp;modified from crypt/rsa/pkcs1v5.go
func publicDecrypt(pub *rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (out []byte, err error) <span class="cov8" title="1">{
        hashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tLen := len(prefix) + hashLen
        k := (pub.N.BitLen() + 7) / 8
        if k &lt; tLen+11 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("length illegal")
        }</span>

        <span class="cov8" title="1">c := new(big.Int).SetBytes(sig)
        m := encrypt(new(big.Int), pub, c)
        em := leftPad(m.Bytes(), k)
        out = unLeftPad(em)

        err = nil
        return</span>
}

// copy from crypt/rsa/pkcs1v5.go
func encrypt(c *big.Int, pub *rsa.PublicKey, m *big.Int) *big.Int <span class="cov8" title="1">{
        e := big.NewInt(int64(pub.E))
        c.Exp(m, e, pub.N)
        return c
}</span>

// copy from crypt/rsa/pkcs1v5.go
func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte, err error) <span class="cov8" title="1">{
        // Special case: crypto.Hash(0) is used to indicate that the data is
        // signed directly.
        if hash == 0 </span><span class="cov8" title="1">{
                return inLen, nil, nil
        }</span>

        <span class="cov0" title="0">hashLen = hash.Size()
        if inLen != hashLen </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("crypto/rsa: input must be hashed message")
        }</span>
        <span class="cov0" title="0">prefix, ok := hashPrefixes[hash]
        if !ok </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("crypto/rsa: unsupported hash function")
        }</span>
        <span class="cov0" title="0">return</span>
}

// copy from crypt/rsa/pkcs1v5.go
func leftPad(input []byte, size int) (out []byte) <span class="cov8" title="1">{
        n := len(input)
        if n &gt; size </span><span class="cov0" title="0">{
                n = size
        }</span>
        <span class="cov8" title="1">out = make([]byte, size)
        copy(out[len(out)-n:], input)
        return</span>
}

func unLeftPad(input []byte) (out []byte) <span class="cov8" title="1">{
        n := len(input)
        t := 2
        for i := 2; i &lt; n; i++ </span><span class="cov8" title="1">{
                if input[i] == 0xff </span><span class="cov8" title="1">{
                        t = t + 1
                }</span> else<span class="cov8" title="1"> {
                        if input[i] == input[0] </span><span class="cov8" title="1">{
                                t = t + int(input[1])
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">out = make([]byte, n-t)
        copy(out, input[t:])
        return</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package utils

import (
        "bytes"
        "fmt"
        "net"
        "os/exec"
        "strconv"
        "strings"
        "time"

        "github.com/containerd/containerd/platforms"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/disk"
        "github.com/shirou/gopsutil/host"
        "github.com/shirou/gopsutil/mem"
)

// HostInfo host information
type HostInfo struct {
        Time            time.Time `json:"time,omitempty"`
        Hostname        string    `json:"hostname,omitempty"`
        Uptime          uint64    `json:"uptime,omitempty"`
        BootTime        uint64    `json:"boot_time,omitempty"`
        ProcessNum      uint64    `json:"process_num,omitempty"`
        OS              string    `json:"os,omitempty"`
        Platform        string    `json:"platform,omitempty"`
        PlatformFamily  string    `json:"platform_family,omitempty"`
        PlatformVersion string    `json:"platform_version,omitempty"`
        Architecture    string    `json:"architecture,omitempty"`
        Variant         string    `json:"variant,omitempty"`
        KernelVersion   string    `json:"kernel_version,omitempty"`
        HostID          string    `json:"host_id,omitempty"`
        Error           string    `json:"error,omitempty"`
}

// GetHostInfo returns host information
func GetHostInfo() *HostInfo <span class="cov0" title="0">{
        pl := platforms.DefaultSpec()
        hi := &amp;HostInfo{Time: time.Now().UTC(), Architecture: pl.Architecture, Variant: pl.Variant}
        raw, err := host.Info()
        if err != nil </span><span class="cov0" title="0">{
                hi.Error = err.Error()
                return hi
        }</span>
        <span class="cov0" title="0">hi.Hostname = raw.Hostname
        hi.Uptime = raw.Uptime
        hi.BootTime = raw.BootTime
        hi.ProcessNum = raw.Procs
        hi.OS = raw.OS
        hi.Platform = raw.Platform
        hi.PlatformFamily = raw.PlatformFamily
        hi.PlatformVersion = raw.PlatformVersion
        hi.KernelVersion = raw.KernelVersion
        hi.HostID = raw.HostID
        return hi</span>
}

// FormatPlatformInfo format a brief platform information
func (hi *HostInfo) FormatPlatformInfo() string <span class="cov8" title="1">{
        if hi.OS == "" </span><span class="cov8" title="1">{
                return "unknown"
        }</span> else<span class="cov8" title="1"> if hi.Variant == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s/%s", hi.OS, hi.Architecture)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%s/%s/%s", hi.OS, hi.Architecture, hi.Variant)
        }</span>
}

// DiskInfo disk information
type DiskInfo struct {
        Time              time.Time `json:"time,omitempty"`
        Path              string    `json:"path,omitempty"`
        Fstype            string    `json:"fstype,omitempty"`
        Total             uint64    `json:"total,omitempty"`
        Free              uint64    `json:"free,omitempty"`
        Used              uint64    `json:"used,omitempty"`
        UsedPercent       float64   `json:"used_percent,omitempty"`
        InodesTotal       uint64    `json:"inodes_total,omitempty"`
        InodesUsed        uint64    `json:"inodes_used,omitempty"`
        InodesFree        uint64    `json:"inodes_free,omitempty"`
        InodesUsedPercent float64   `json:"inodes_used_percent,omitempty"`
        Error             string    `json:"error,omitempty"`
}

// GetDiskInfo gets disk information
func GetDiskInfo(path string) *DiskInfo <span class="cov0" title="0">{
        di := &amp;DiskInfo{Time: time.Now().UTC()}
        raw, err := disk.Usage(path)
        if err != nil </span><span class="cov0" title="0">{
                di.Error = err.Error()
                return di
        }</span>
        <span class="cov0" title="0">di.Path = raw.Path
        di.Fstype = raw.Fstype
        di.Total = raw.Total
        di.Free = raw.Free
        di.Used = raw.Used
        di.UsedPercent = raw.UsedPercent
        di.InodesTotal = raw.InodesTotal
        di.InodesUsed = raw.InodesUsed
        di.InodesFree = raw.InodesFree
        di.InodesUsedPercent = raw.InodesUsedPercent
        return di</span>
}

// MemInfo memory information
type MemInfo struct {
        Time            time.Time `json:"time,omitempty"`
        Total           uint64    `json:"total,omitempty"`
        Free            uint64    `json:"free,omitempty"`
        Used            uint64    `json:"used,omitempty"`
        UsedPercent     float64   `json:"used_percent,omitempty"`
        SwapTotal       uint64    `json:"swap_total,omitempty"`
        SwapFree        uint64    `json:"swap_free,omitempty"`
        SwapUsed        uint64    `json:"swap_used,omitempty"`
        SwapUsedPercent float64   `json:"swap_used_percent,omitempty"`
        Error           string    `json:"error,omitempty"`
}

// GetMemInfo gets memory information
func GetMemInfo() *MemInfo <span class="cov0" title="0">{
        mi := &amp;MemInfo{Time: time.Now().UTC()}
        vm, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                mi.Error = err.Error()
                return mi
        }</span>
        <span class="cov0" title="0">mi.Total = vm.Total
        mi.Free = vm.Free
        mi.Used = vm.Used
        mi.UsedPercent = vm.UsedPercent
        sm, err := mem.SwapMemory()
        if err != nil </span><span class="cov0" title="0">{
                mi.Error = err.Error()
                return mi
        }</span>
        <span class="cov0" title="0">mi.SwapTotal = sm.Total
        mi.SwapFree = sm.Free
        mi.SwapUsed = sm.Used
        mi.SwapUsedPercent = sm.UsedPercent
        return mi</span>
}

// NetInfo host information
type NetInfo struct {
        Time       time.Time   `json:"time,omitempty"`
        Interfaces []Interface `json:"interfaces,omitempty"`
        Error      string      `json:"error,omitempty"`
}

// Interface interface information
type Interface struct {
        Index int    `json:"index,omitempty"`
        Name  string `json:"name,omitempty"`
        MAC   string `json:"mac,omitempty"`
        Addrs []Addr `json:"addrs,omitempty"`
        Error string `json:"error,omitempty"`
}

// Addr network ip address
type Addr struct {
        Network string `json:"network,omitempty"`
        Address string `json:"address,omitempty"`
}

// GetNetInfo returns host information
func GetNetInfo() *NetInfo <span class="cov8" title="1">{
        ni := &amp;NetInfo{Time: time.Now().UTC(), Interfaces: []Interface{}}
        raw, err := net.Interfaces()
        if err != nil </span><span class="cov0" title="0">{
                ni.Error = err.Error()
                return ni
        }</span>
        <span class="cov8" title="1">for _, v := range raw </span><span class="cov8" title="1">{
                i := Interface{
                        Index: v.Index,
                        Name:  v.Name,
                        MAC:   v.HardwareAddr.String(),
                        Addrs: []Addr{},
                }
                va, err := v.Addrs()
                if err != nil </span><span class="cov0" title="0">{
                        i.Error = err.Error()
                }</span>
                <span class="cov8" title="1">for _, vaa := range va </span><span class="cov8" title="1">{
                        i.Addrs = append(i.Addrs, Addr{Network: vaa.Network(), Address: vaa.String()})
                }</span>
                <span class="cov8" title="1">ni.Interfaces = append(ni.Interfaces, i)</span>
        }
        <span class="cov8" title="1">return ni</span>
}

// CPUInfo CPU information
type CPUInfo struct {
        Time        time.Time `json:"time,omitempty"`
        Mhz         float64   `json:"mhz,omitempty"`
        Cores       int32     `json:"cores,omitempty"`
        CacheSize   int32     `json:"cache_size,omitempty"`
        ModelName   string    `json:"model_name,omitempty"`
        PhysicalID  string    `json:"physical_id,omitempty"`
        UsedPercent float64   `json:"used_percent,omitempty"`
        Error       string    `json:"error,omitempty"`
}

// PerCPUInfo one CPU information
type PerCPUInfo struct {
        UsedPercent float64 `json:"used_percent,omitempty"`
}

// GetCPUInfo gets CPU information
func GetCPUInfo() *CPUInfo <span class="cov8" title="1">{
        ci := &amp;CPUInfo{Time: time.Now().UTC()}
        info, err := cpu.Info()
        if err != nil </span><span class="cov0" title="0">{
                ci.Error = err.Error()
                return ci
        }</span>
        <span class="cov8" title="1">raw, err := cpu.Percent(0, false)
        if err != nil </span><span class="cov0" title="0">{
                ci.Error = err.Error()
                return ci
        }</span>
        // only get first CPU
        <span class="cov8" title="1">if len(info) &gt;= 1 </span><span class="cov8" title="1">{
                ci.Mhz = info[0].Mhz
                ci.Cores = info[0].Cores
                ci.CacheSize = info[0].CacheSize
                ci.ModelName = info[0].ModelName
                ci.PhysicalID = info[0].PhysicalID
        }</span>
        <span class="cov8" title="1">if len(raw) &gt;= 1 </span><span class="cov8" title="1">{
                ci.UsedPercent = raw[0]
        }</span>
        <span class="cov8" title="1">return ci</span>
}

// GPUInfo GPU information
type GPUInfo struct {
        Time  time.Time    `json:"time,omitempty"`
        GPUs  []PerGPUInfo `json:"gpus,omitempty"`
        Error string       `json:"error,omitempty"`
}

// PerGPUInfo one GPU information
type PerGPUInfo struct {
        Index          string  `json:"index,omitempty"`
        Model          string  `json:"model,omitempty"`
        MemTotal       uint64  `json:"mem_total,omitempty"`
        MemFree        uint64  `json:"mem_free,omitempty"`
        MemUsedPercent float64 `json:"mem_used_percent,omitempty"`
        GPUUsedPercent float64 `json:"gpu_used_percent,omitempty"`
}

/********************************************************************************************
* nvidia-smi --query-gpu=index,name,memory.total,memory.free,utilization.memory,utilization.gpu --format=csv,noheader,nounits
* 0, TITAN X (Pascal), 12189, 12187, 0, 0
* 1, TITAN X (Pascal), 12189, 12187, 0, 0
* 2, TITAN X (Pascal), 12189, 12187, 0, 0
* 3, TITAN X (Pascal), 12189, 12187, 0, 0
********************************************************************************************/

const (
        nvSmiBin    = "nvidia-smi"
        nvQueryArg  = "--query-gpu=index,name,memory.total,memory.free,utilization.memory,utilization.gpu"
        nvFormatArg = "--format=csv,noheader,nounits"
)

// GetGPUInfo gets GPU information
func GetGPUInfo() *GPUInfo <span class="cov0" title="0">{
        var stderr, stdout bytes.Buffer
        gi := &amp;GPUInfo{Time: time.Now().UTC()}
        cmd := exec.Command(nvSmiBin, nvQueryArg, nvFormatArg)
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                gi.Error = fmt.Sprintf("%s: %s", err.Error(), strings.Trim(stderr.String(), "\n"))
        }</span> else<span class="cov0" title="0"> {
                gi.GPUs = parseGPUInfo(stdout.String())
        }</span>
        <span class="cov0" title="0">return gi</span>
}

func parseGPUInfo(in string) []PerGPUInfo <span class="cov8" title="1">{
        var err error
        gpus := []PerGPUInfo{}
        for _, raw := range strings.Split(in, "\n") </span><span class="cov8" title="1">{
                var g PerGPUInfo
                parts := strings.Split(raw, ",")
                if len(parts) != 6 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">g.Index = strings.TrimSpace(parts[0])
                g.Model = strings.TrimSpace(parts[1])
                g.MemTotal, err = strconv.ParseUint(strings.TrimSpace(parts[2]), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">g.MemFree, err = strconv.ParseUint(strings.TrimSpace(parts[3]), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">g.MemUsedPercent, err = strconv.ParseFloat(strings.TrimSpace(parts[4]), 64)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">g.GPUUsedPercent, err = strconv.ParseFloat(strings.TrimSpace(parts[5]), 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">gpus = append(gpus, g)</span>
        }
        <span class="cov8" title="1">return gpus</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package utils

import (
        "compress/flate"

        "github.com/mholt/archiver"
)

var defaultTarGz = &amp;archiver.TarGz{
        CompressionLevel: flate.DefaultCompression,
        Tar: &amp;archiver.Tar{
                MkdirAll:          true,
                OverwriteExisting: true,
        },
}

// TarGz tarGz source files to destination file
func TarGz(sources []string, destination string) error <span class="cov8" title="1">{
        return defaultTarGz.Archive(sources, destination)
}</span>

// UntarGz untarGz source file to destination
func UntarGz(source, destination string) error <span class="cov8" title="1">{
        return defaultTarGz.Unarchive(source, destination)
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package utils

import (
        "crypto/tls"

        "github.com/docker/go-connections/tlsconfig"
)

// Certificate certificate config for mqtt server
type Certificate struct {
        CA       string `yaml:"ca" json:"ca"`
        Key      string `yaml:"key" json:"key"`
        Cert     string `yaml:"cert" json:"cert"`
        Insecure bool   `yaml:"insecure" json:"insecure"` // for client, for test purpose
}

// NewTLSServerConfig loads tls config for server
func NewTLSServerConfig(c Certificate) (*tls.Config, error) <span class="cov0" title="0">{
        if c.Cert == "" &amp;&amp; c.Key == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return tlsconfig.Server(tlsconfig.Options{CAFile: c.CA, KeyFile: c.Key, CertFile: c.Cert, ClientAuth: tls.VerifyClientCertIfGiven})</span>
}

// NewTLSClientConfig loads tls config for client
func NewTLSClientConfig(c Certificate) (*tls.Config, error) <span class="cov0" title="0">{
        return tlsconfig.Client(tlsconfig.Options{CAFile: c.CA, KeyFile: c.Key, CertFile: c.Cert, InsecureSkipVerify: c.Insecure})
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package utils

import (
        "fmt"
        "sync"

        tb "gopkg.in/tomb.v2"
)

const (
        ini = int32(0)
        gos = int32(1)
)

// Tomb wraps tomb.Tomb
type Tomb struct {
        t tb.Tomb
        s int32
        m sync.Mutex
}

// Go runs functions in new goroutines.
func (t *Tomb) Go(fs ...func() error) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov8" title="1">{
                        err = fmt.Errorf("%v", p)
                }</span>
        }()
        <span class="cov8" title="1">t.m.Lock()
        defer t.m.Unlock()
        t.s = gos
        for _, f := range fs </span><span class="cov8" title="1">{
                t.t.Go(f)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Kill puts the tomb in a dying state for the given reason.
func (t *Tomb) Kill(reason error) <span class="cov8" title="1">{
        t.t.Kill(reason)
}</span>

// Dying returns the channel that can be used to wait until
// t.Kill is called.
func (t *Tomb) Dying() &lt;-chan struct{} <span class="cov8" title="1">{
        return t.t.Dying()
}</span>

// Wait blocks until all goroutines have finished running, and
// then returns the reason for their death.
//
// If tomb does not start any goroutine, return quickly
func (t *Tomb) Wait() (err error) <span class="cov8" title="1">{
        t.m.Lock()
        if t.s == gos </span><span class="cov8" title="1">{
                err = t.t.Wait()
        }</span>
        <span class="cov8" title="1">t.m.Unlock()
        return</span>
}

// Alive returns true if the tomb is not in a dying or dead state.
func (t *Tomb) Alive() bool <span class="cov0" title="0">{
        return t.t.Alive()
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package utils

import "time"

// Trace print elapsed time
func Trace(name string, log func(format string, args ...interface{})) func() <span class="cov0" title="0">{
        start := time.Now()
        return func() </span><span class="cov0" title="0">{
                log("%s elapsed time: %v", name, time.Since(start))
        }</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package utils

import (
        "net/url"
        "strings"
)

// ParseURL parses a url string
func ParseURL(addr string) (*url.URL, error) <span class="cov8" title="1">{
        if strings.HasPrefix(addr, "unix://") </span><span class="cov8" title="1">{
                parts := strings.SplitN(addr, "://", 2)
                return &amp;url.URL{
                        Scheme: parts[0],
                        Host:   parts[1],
                }, nil
        }</span>
        <span class="cov8" title="1">return url.Parse(addr)</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package utils

import (
        "compress/flate"

        "github.com/mholt/archiver"
)

var defaultZip = &amp;archiver.Zip{
        CompressionLevel:     flate.DefaultCompression,
        MkdirAll:             true,
        SelectiveCompression: true,
        OverwriteExisting:    true,
}

// Zip zip source files to destination file
func Zip(sources []string, destination string) error <span class="cov8" title="1">{
        return defaultZip.Archive(sources, destination)
}</span>

// Unzip unzip source file to destination
func Unzip(source, destination string) error <span class="cov8" title="1">{
        return defaultZip.Unarchive(source, destination)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
